<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Working with Video Frames</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<h2>description: Working with Video Frames
ms.assetid: a5ad74dd-abfd-4810-a512-42e4b98a6c59
title: Working with Video Frames
ms.topic: article
ms.date: 4/26/2023
ms.custom: UpdateFrequency5</h2>
<h1>Working with Video Frames</h1>
<p>[The feature associated with this page, <a href="/windows/win32/directshow/directshow">DirectShow</a>, is a legacy feature. It has been superseded by <a href="/uwp/api/Windows.Media.Playback.MediaPlayer">MediaPlayer</a>, <a href="/windows/win32/api/mfmediaengine/nn-mfmediaengine-imfmediaengine">IMFMediaEngine</a>, and <a href="/windows/win32/medfound/audio-video-capture-in-media-foundation">Audio/Video Capture in Media Foundation</a>. Those features have been optimized for Windows 10 and Windows 11. Microsoft strongly recommends that new code use <strong>MediaPlayer</strong>, <strong>IMFMediaEngine</strong> and <strong>Audio/Video Capture in Media Foundation</strong> instead of <strong>DirectShow</strong>, when possible. Microsoft suggests that existing code that uses the legacy APIs be rewritten to use the new APIs if possible.]</p>
<p>Uncompressed video is a sequence of bitmaps played in rapid succession, typically at a rate of about 30 frames per second. Because most video enters a DirectShow filter graph in a compressed format, the video stream generally goes through a decoder for decompression. Many decoders output data in a YUV format and leave the final conversion to RGB for the video hardware just prior to rendering. If a decoder uses DirectX Video Acceleration, the video hardware performs additional work to decode the image. Thus, final decompression of the bitmaps may not be performed until the data reaches the video hardware.</p>
<p>But to perform many types of video analysis, processing, or editing, it is often necessary to work on uncompressed bitmaps in some type of RGB or YUV format before they are rendered or written to file. This work is typically done within a transform filter based on the <a href="ctransformfilter.html"><strong>CTransformFilter</strong></a> base class, specifically in the <strong>Transform</strong> method. This method receives a pointer to an <a href="/windows/desktop/api/Strmif/nn-strmif-imediasample"><strong>IMediaSample</strong></a> object that encapsulates the video data. The <strong>IMediaSample::GetPointer</strong> method returns a pointer to the first byte of the raw data. For uncompressed frames, this data consists of pixels that can be accessed or modified directly by the filter. The following sections provide background information that will help you work effectively with DIB data in this manner.</p>
<blockquote>
<p>[!Note]<br />
You can also modify the bits by using GDI, GDI+, DirectDraw or Direct3D functions, but these techniques are beyond the scope of this article.</p>
</blockquote>
<p>Â </p>
<p>This section contains the following topics:</p>
<ul>
<li><a href="top-down-vs--bottom-up-dibs.html">Top-Down vs. Bottom-Up DIBs</a></li>
<li><a href="working-with-16-bit-rgb.html">Working with 16-bit RGB</a></li>
</ul>
<p>Â </p>
<p>Â </p>
</body>
