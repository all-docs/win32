<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Common Functions (Windows Internet)</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<h2>title: Common Functions (Windows Internet)
description: The different Internet protocols (such as ftp and http) use several of the same WinINet functions to handle information on the Internet.
ms.assetid: c80768cf-c8c0-4bdf-9ea2-f82c92ade05a
ms.topic: article
ms.date: 05/31/2018</h2>
<h1>Common Functions (Windows Internet)</h1>
<p>The different Internet protocols (such as ftp and http) use several of the same WinINet functions to handle information on the Internet. These common functions handle their tasks in a consistent manner, regardless of the particular protocol to which they are being applied. Applications can use these functions to create general-purpose functions that handle tasks across the different protocols (such as reading files for ftp and http).</p>
<p>The common functions handle the following tasks:</p>
<ul>
<li>Downloading resources from the Internet (<a href="/windows/desktop/api/Wininet/nf-wininet-internetreadfile"><strong>InternetReadFile</strong></a>, <a href="/windows/desktop/api/Wininet/nf-wininet-internetsetfilepointer"><strong>InternetSetFilePointer</strong></a>, <a href="/windows/desktop/api/Wininet/nf-wininet-internetfindnextfilea"><strong>InternetFindNextFile</strong></a>, and <a href="/windows/desktop/api/Wininet/nf-wininet-internetquerydataavailable"><strong>InternetQueryDataAvailable</strong></a>).</li>
<li>Setting up asynchronous operations (<a href="/windows/desktop/api/Wininet/nf-wininet-internetsetstatuscallback"><strong>InternetSetStatusCallback</strong></a>).</li>
<li>Viewing and changing options (<a href="/windows/desktop/api/Wininet/nf-wininet-internetsetoptiona"><strong>InternetSetOption</strong></a> and <a href="/windows/desktop/api/Wininet/nf-wininet-internetqueryoptiona"><strong>InternetQueryOption</strong></a>).</li>
<li>Closing all types of <a href="appendix-a-hinternet-handles.html"><strong>HINTERNET</strong></a> handles (<a href="/windows/desktop/api/Wininet/nf-wininet-internetclosehandle"><strong>InternetCloseHandle</strong></a>).</li>
<li>Placing and removing locks on resources (<a href="/windows/desktop/api/Wininet/nf-wininet-internetlockrequestfile"><strong>InternetLockRequestFile</strong></a> and <a href="/windows/desktop/api/Wininet/nf-wininet-internetunlockrequestfile"><strong>InternetUnlockRequestFile</strong></a>).</li>
</ul>
<h2>Using Common Functions</h2>
<p>The following table lists the common functions included in the WinINet functions. The common functions can be used on different types of <a href="appendix-a-hinternet-handles.html"><strong>HINTERNET</strong></a> handles or can be used during different types of sessions.</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/windows/desktop/api/Wininet/nf-wininet-internetfindnextfilea"><strong>InternetFindNextFile</strong></a></td>
<td>Continues file enumeration or search. Requires a handle created by the <a href="/windows/desktop/api/Wininet/nf-wininet-ftpfindfirstfilea"><strong>FtpFindFirstFile</strong></a>, or <a href="/windows/desktop/api/Wininet/nf-wininet-internetopenurla"><strong>InternetOpenUrl</strong></a> function.</td>
</tr>
<tr>
<td><a href="/windows/desktop/api/Wininet/nf-wininet-internetlockrequestfile"><strong>InternetLockRequestFile</strong></a></td>
<td>Allows the user to place a lock on the file that is being used. This function requires a handle returned by the <a href="/windows/desktop/api/Wininet/nf-wininet-ftpopenfilea"><strong>FtpOpenFile</strong></a>, <a href="/windows/desktop/api/Wininet/nf-wininet-httpopenrequesta"><strong>HttpOpenRequest</strong></a>, or <a href="/windows/desktop/api/Wininet/nf-wininet-internetopenurla"><strong>InternetOpenUrl</strong></a> function.</td>
</tr>
<tr>
<td><a href="/windows/desktop/api/Wininet/nf-wininet-internetquerydataavailable"><strong>InternetQueryDataAvailable</strong></a></td>
<td>Retrieves the amount of data available. Requires a handle created by the <a href="/windows/desktop/api/Wininet/nf-wininet-ftpopenfilea"><strong>FtpOpenFile</strong></a>, or <a href="/windows/desktop/api/Wininet/nf-wininet-httpopenrequesta"><strong>HttpOpenRequest</strong></a> function.</td>
</tr>
<tr>
<td><a href="/windows/desktop/api/Wininet/nf-wininet-internetqueryoptiona"><strong>InternetQueryOption</strong></a></td>
<td>Retrieves the setting of an Internet option.</td>
</tr>
<tr>
<td><a href="/windows/desktop/api/Wininet/nf-wininet-internetreadfile"><strong>InternetReadFile</strong></a></td>
<td>Reads URL data. Requires a handle created by the <a href="/windows/desktop/api/Wininet/nf-wininet-internetopenurla"><strong>InternetOpenUrl</strong></a>, <a href="/windows/desktop/api/Wininet/nf-wininet-ftpopenfilea"><strong>FtpOpenFile</strong></a>, or <a href="/windows/desktop/api/Wininet/nf-wininet-httpopenrequesta"><strong>HttpOpenRequest</strong></a> function.</td>
</tr>
<tr>
<td><a href="/windows/desktop/api/Wininet/nf-wininet-internetsetfilepointer"><strong>InternetSetFilePointer</strong></a></td>
<td>Sets the position for the next read in a file. Requires a handle created by <a href="/windows/desktop/api/Wininet/nf-wininet-internetopenurla"><strong>InternetOpenUrl</strong></a> (on an HTTP URL only) or a handle created by <a href="/windows/desktop/api/Wininet/nf-wininet-httpopenrequesta"><strong>HttpOpenRequest</strong></a> using the GET HTTP verb.</td>
</tr>
<tr>
<td><a href="/windows/desktop/api/Wininet/nf-wininet-internetsetoptiona"><strong>InternetSetOption</strong></a></td>
<td>Sets an Internet option.</td>
</tr>
<tr>
<td><a href="/windows/desktop/api/Wininet/nf-wininet-internetsetstatuscallback"><strong>InternetSetStatusCallback</strong></a></td>
<td>Sets a callback function that receives status information. Assigns a callback function to the designated <a href="appendix-a-hinternet-handles.html"><strong>HINTERNET</strong></a> handle and all handles derived from it.</td>
</tr>
<tr>
<td><a href="/windows/desktop/api/Wininet/nf-wininet-internetunlockrequestfile"><strong>InternetUnlockRequestFile</strong></a></td>
<td>Unlocks a file that was locked using the <a href="/windows/desktop/api/Wininet/nf-wininet-internetlockrequestfile"><strong>InternetLockRequestFile</strong></a> function.</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>Reading files, finding the next file, manipulating options, and setting up asynchronous operations are common to the functions that support various protocols and <a href="appendix-a-hinternet-handles.html"><strong>HINTERNET</strong></a> handle types.</p>
<h3>Reading Files</h3>
<p>The <a href="/windows/desktop/api/Wininet/nf-wininet-internetreadfile"><strong>InternetReadFile</strong></a> function is used to download resources from an <a href="appendix-a-hinternet-handles.html"><strong>HINTERNET</strong></a> handle returned by the <a href="/windows/desktop/api/Wininet/nf-wininet-internetopenurla"><strong>InternetOpenUrl</strong></a>, <a href="/windows/desktop/api/Wininet/nf-wininet-ftpopenfilea"><strong>FtpOpenFile</strong></a>, or <a href="/windows/desktop/api/Wininet/nf-wininet-httpopenrequesta"><strong>HttpOpenRequest</strong></a> function.</p>
<p><a href="/windows/desktop/api/Wininet/nf-wininet-internetreadfile"><strong>InternetReadFile</strong></a> accepts a void pointer variable that contains the address of a buffer and a pointer to a variable that contains the length of the buffer. The function returns the data in the buffer and the amount of data downloaded into the buffer.</p>
<p>The WinINet functions provide two techniques to download an entire resource:</p>
<ul>
<li>The <a href="/windows/desktop/api/Wininet/nf-wininet-internetquerydataavailable"><strong>InternetQueryDataAvailable</strong></a> function.</li>
<li>The return values of <a href="/windows/desktop/api/Wininet/nf-wininet-internetreadfile"><strong>InternetReadFile</strong></a>.</li>
</ul>
<p><a href="/windows/desktop/api/Wininet/nf-wininet-internetquerydataavailable"><strong>InternetQueryDataAvailable</strong></a> takes the <a href="appendix-a-hinternet-handles.html"><strong>HINTERNET</strong></a> handle created by <a href="/windows/desktop/api/Wininet/nf-wininet-internetopenurla"><strong>InternetOpenUrl</strong></a>, <a href="/windows/desktop/api/Wininet/nf-wininet-ftpopenfilea"><strong>FtpOpenFile</strong></a>, or <a href="/windows/desktop/api/Wininet/nf-wininet-httpopenrequesta"><strong>HttpOpenRequest</strong></a> (after <a href="/windows/desktop/api/Wininet/nf-wininet-httpsendrequesta"><strong>HttpSendRequest</strong></a> has been called on the handle) and returns the number of bytes available. The application should allocate a buffer equal to the number of bytes available, plus 1 for the terminating <strong>null</strong> character, and use that buffer with <a href="/windows/desktop/api/Wininet/nf-wininet-internetreadfile"><strong>InternetReadFile</strong></a>. This method does not always work because <a href="/windows/desktop/api/Wininet/nf-wininet-internetquerydataavailable"><strong>InternetQueryDataAvailable</strong></a> is checking the file size listed in the header and not the actual file. The information in the header file could be outdated, or the header file could be missing, since it is not currently required under all standards.</p>
<p>The following example reads the contents of the resource accessed by the hResource handle and displayed in the edit box indicated by intCtrlID.</p>
<pre lang="C++"><code>int WINAPI Dumper(HWND hX, int intCtrlID, HINTERNET hResource)
{
    LPTSTR    lpszData;           // buffer for the data
    DWORD     dwSize;             // size of the data available
    DWORD     dwDownloaded;       // size of the downloaded data
    DWORD     dwSizeSum=0;        // size of the data in the text box
    LPTSTR    lpszHolding;        // buffer to merge the text box 
                                  // data and buffer

    // Set the cursor to an hourglass.
    SetCursor(LoadCursor(NULL,IDC_WAIT));

    // This loop handles reading the data.  
    do
    {
        // The call to InternetQueryDataAvailable determines the
        // amount of data available to download.
        if (!InternetQueryDataAvailable(hResource,&amp;dwSize,0,0))
        {
            ErrorOut(hX,GetLastError(),TEXT(&quot;InternetReadFile&quot;));
            SetCursor(LoadCursor(NULL,IDC_ARROW));
            return FALSE;
        }
        else
        {    
            // Allocate a buffer of the size returned by
            // InternetQueryDataAvailable.
            lpszData = new TCHAR[dwSize+1];

            // Read the data from the HINTERNET handle.
            if(!InternetReadFile(hResource,(LPVOID)lpszData,
                                 dwSize,&amp;dwDownloaded))
            {
                ErrorOut(hX,GetLastError(),TEXT(&quot;InternetReadFile&quot;));
                delete[] lpszData;
                break;
            }
            else
            {
                // Add a null terminator to the end of the 
                // data buffer.
                lpszData[dwDownloaded]='\0';

                // Allocate the holding buffer.
                lpszHolding = new TCHAR[dwSizeSum + dwDownloaded + 1];
                    
                // Check if there has been any data written to 
                // the text box.
                if (dwSizeSum != 0)
                {
                    // Retrieve the data stored in the text 
                    // box, if any.
                    GetDlgItemText(hX,intCtrlID,
                                   (LPTSTR)lpszHolding, 
                                   dwSizeSum);
                         
                    // Add a null terminator at the end of 
                    // the text box data.
                    lpszHolding[dwSizeSum]='\0';
                }
                else
                {
                    // Make the holding buffer an empty string. 
                    lpszHolding[0]='\0';
                }

                size_t cchDest = dwSizeSum + dwDownloaded + 
                                 dwDownloaded + 1;
                LPTSTR pszDestEnd;
                size_t cchRemaining;

                // Add the new data to the holding buffer.
                HRESULT hr = StringCchCatEx(lpszHolding, cchDest, 
                                            lpszData, &amp;pszDestEnd, 
                                            &amp;cchRemaining, 
                                            STRSAFE_NO_TRUNCATION);
                if(SUCCEEDED(hr))
                {
                    // Write the holding buffer to the text box.
                    SetDlgItemText(hX,intCtrlID,(LPTSTR)lpszHolding);

                    // Delete the two buffers.
                    delete[] lpszHolding;
                    delete[] lpszData;

                    // Add the size of the downloaded data to 
                    // the text box data size.
                    dwSizeSum = dwSizeSum + dwDownloaded + 1;

                    // Check the size of the remaining data.  
                    // If it is zero, break.
                    if (dwDownloaded == 0)
                    {
                        break;
                    }                    
                    else
                    {
                        //  Insert error handling code here.
                    }
                }
            }
        }
    }
    while(TRUE);

    // Close the HINTERNET handle.
    InternetCloseHandle(hResource);

    // Set the cursor back to an arrow.
    SetCursor(LoadCursor(NULL,IDC_ARROW));

    // Return.
    return TRUE;
}
</code></pre>
<p><a href="/windows/desktop/api/Wininet/nf-wininet-internetreadfile"><strong>InternetReadFile</strong></a> returns zero bytes read and completes successfully when all available data has been read. This allows an application to use <a href="/windows/desktop/api/Wininet/nf-wininet-internetreadfile"><strong>InternetReadFile</strong></a> in a loop to download the data and exit when it returns zero bytes read and completes successfully.</p>
<p>The following example reads the resource from the Internet and displays the resource in the edit box indicated by intCtrlID. The <a href="appendix-a-hinternet-handles.html"><strong>HINTERNET</strong></a> handle, hInternet, was returned by <a href="/windows/desktop/api/Wininet/nf-wininet-internetopenurla"><strong>InternetOpenUrl</strong></a>, <a href="/windows/desktop/api/Wininet/nf-wininet-ftpopenfilea"><strong>FtpOpenFile</strong></a>, or <a href="/windows/desktop/api/Wininet/nf-wininet-httpopenrequesta"><strong>HttpOpenRequest</strong></a> (after being sent by <a href="/windows/desktop/api/Wininet/nf-wininet-httpsendrequesta"><strong>HttpSendRequest</strong></a>).</p>
<pre lang="C++"><code>int WINAPI Dump(HWND hX, int intCtrlID, HINTERNET hResource)
{
     DWORD dwSize = 0;
     LPTSTR lpszData;
     LPTSTR lpszOutPut;
     LPTSTR lpszHolding = TEXT(&quot;&quot;);
     int nCounter = 1;
     int nBufferSize = 0;
     DWORD BigSize = 8000;

     // Set the cursor to an hourglass.
     SetCursor(LoadCursor(NULL,IDC_WAIT));

     // Begin the loop that reads the data.
     do
     {
          // Allocate the buffer.
          lpszData =new TCHAR[BigSize+1];

          // Read the data.
          if(!InternetReadFile(hResource,
                              (LPVOID)lpszData,
                              BigSize,&amp;dwSize))
          {
               ErrorOut(hX,GetLastError(),TEXT(&quot;InternetReadFile&quot;));
               delete []lpszData;
               break;
          }
          else
          {
               // Add a null terminator to the end of the buffer.
               lpszData[dwSize]='\0';

               // Check if all of the data has been read.  This should
               // never get called on the first time through the loop.
               if (dwSize == 0)
               {
                    // Write the final data to the text box.
                    SetDlgItemText(hX,intCtrlID,lpszHolding);

                    // Delete the existing buffers.
                    delete [] lpszData;
                    delete [] lpszHolding;
                    break;
               }

               // Determine the buffer size to hold the new data and
               // the data already written to the text box (if any).
               nBufferSize = (nCounter*BigSize)+1;

               // Increment the number of buffers read.
               nCounter++;               

               // Allocate the output buffer.
               lpszOutPut = new TCHAR[nBufferSize];

               // Make sure the buffer is not the initial buffer.
               if(nBufferSize != int(BigSize+1))
               {
                    // Copy the data in the holding buffer.
                    StringCchCopy(lpszOutPut,nBufferSize,lpszHolding);
                    // Add error handling code here.

                    // Concatenate the new buffer with the 
                    // output buffer.
                    StringCchCat(lpszOutPut, nBufferSize, lpszData);
                    // Add error handling code here.
     
                    // Delete the holding buffer.
                    delete [] lpszHolding;
               }
               else
               {
                    // Copy the data buffer.
                    StringCchCopy(lpszOutPut, nBufferSize, lpszData);
                    // Add error handling code here.
               }

               // Allocate a holding buffer.
               lpszHolding = new TCHAR[nBufferSize]; 

               // Copy the output buffer into the holding buffer.
               memcpy(lpszHolding,lpszOutPut,nBufferSize);

               // Delete the other buffers.
               delete [] lpszData;
               delete [] lpszOutPut;

          }

     }
     while (TRUE);

     // Close the HINTERNET handle.
     InternetCloseHandle(hResource);

     // Set the cursor back to an arrow.
     SetCursor(LoadCursor(NULL,IDC_ARROW));

     // Return.
     return TRUE;
}
</code></pre>
<h3>Finding the Next File</h3>
<p>The <a href="/windows/desktop/api/Wininet/nf-wininet-internetfindnextfilea"><strong>InternetFindNextFile</strong></a> function is used to find the next file in a file search, using the search parameters and <a href="appendix-a-hinternet-handles.html"><strong>HINTERNET</strong></a> handle from <a href="/windows/desktop/api/Wininet/nf-wininet-ftpfindfirstfilea"><strong>FtpFindFirstFile</strong></a>, or <a href="/windows/desktop/api/Wininet/nf-wininet-internetopenurla"><strong>InternetOpenUrl</strong></a>.</p>
<p>To complete a file search, continue to call <a href="/windows/desktop/api/Wininet/nf-wininet-internetfindnextfilea"><strong>InternetFindNextFile</strong></a> using the <a href="appendix-a-hinternet-handles.html"><strong>HINTERNET</strong></a> handle returned by <a href="/windows/desktop/api/Wininet/nf-wininet-ftpfindfirstfilea"><strong>FtpFindFirstFile</strong></a>, or <a href="/windows/desktop/api/Wininet/nf-wininet-internetopenurla"><strong>InternetOpenUrl</strong></a> until the function fails with the extended error message <a href="wininet-errors.html">ERROR_NO_MORE_FILES</a>. To get the extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror"><strong>GetLastError</strong></a> function.</p>
<p>The following example displays the contents of an FTP directory in the list box indicated by lstDirectory. The <a href="appendix-a-hinternet-handles.html"><strong>HINTERNET</strong></a> handle, hConnect, is a handle returned by the <a href="/windows/desktop/api/Wininet/nf-wininet-internetconnecta"><strong>InternetConnect</strong></a> function after it establishes an FTP session.</p>
<pre lang="C++"><code>bool WINAPI DisplayDir( HWND hX, 
                        int lstDirectory, 
                        HINTERNET hConnect, 
                        DWORD dwFlag )
{
     WIN32_FIND_DATA pDirInfo;
     HINTERNET hDir;
     TCHAR DirList[MAX_PATH];

     // Set the cursor to an hourglass.
     SetCursor(LoadCursor(NULL,IDC_WAIT));

     // Reset the list box.
     SendDlgItemMessage(hX, lstDirectory,LB_RESETCONTENT,0,0);

     // Find the first file.
     hDir = FtpFindFirstFile (hConnect, TEXT (&quot;*.*&quot;), 
                              &amp;pDirInfo, dwFlag, 0);
     if (!hDir)                                     
     {
          // Check if the error was because there were no files.
          if (GetLastError()  == ERROR_NO_MORE_FILES) 
          {
               // Alert user.
               MessageBox(hX, TEXT(&quot;There are no files here!!!&quot;), 
                          TEXT(&quot;Display Dir&quot;), MB_OK);

               // Close the HINTERNET handle.
               InternetCloseHandle(hDir);

               // Set the cursor back to an arrow.
               SetCursor(LoadCursor(NULL,IDC_ARROW));

               // Return.
               return TRUE;
          }
          else 
          {
               // Call error handler.
               ErrorOut (hX, GetLastError (), TEXT(&quot;FindFirst error: &quot;));

               // Close the HINTERNET handle.
               InternetCloseHandle(hDir);

               // Set the cursor back to an arrow.
               SetCursor(LoadCursor(NULL,IDC_ARROW));

               // Return.
               return FALSE;
          }
     }
     else
     {
          // Write the file name to a string.
          StringCchPrintf(DirList, MAX_PATH, pDirInfo.cFileName);

          // Check the type of file.
          if (pDirInfo.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY)
          {
               // Add &lt;DIR&gt; to indicate that this is 
               // a directory to the user.
               StringCchCat(DirList, MAX_PATH, TEXT(&quot; &lt;DIR&gt; &quot;));
               // Add error handling code here.
          }
       
          // Add the file name (or directory) to the list box.
          SendDlgItemMessage(hX, lstDirectory, LB_ADDSTRING,
                             0, (LPARAM)DirList);
     }
     do
     {
          // Find the next file.
          if (!InternetFindNextFile (hDir, &amp;pDirInfo))
          {
               // Check if there are no more files left. 
               if ( GetLastError() == ERROR_NO_MORE_FILES ) 
               {
                    // Close the HINTERNET handle.
                    InternetCloseHandle(hDir);

                    // Set the cursor back to an arrow.
                    SetCursor(LoadCursor(NULL,IDC_ARROW));

                    // Return.
                    return TRUE;
               }
               else
               {   
                    // Handle the error.
                    ErrorOut (hX, GetLastError(), 
                              TEXT(&quot;InternetFindNextFile&quot;));

                    // Close the HINTERNET handle.
                    InternetCloseHandle(hDir);

                    // Set the cursor back to an arrow.
                    SetCursor(LoadCursor(NULL,IDC_ARROW));

                    // Return.
                    return FALSE;
               }
           }
           else
           {
               // Write the file name to a string.
               StringCchPrintf(DirList, MAX_PATH, pDirInfo.cFileName);

               // Check the type of file.
               if(pDirInfo.dwFileAttributes==FILE_ATTRIBUTE_DIRECTORY)
               {
                    // Add &lt;DIR&gt; to indicate that this is a 
                    // directory to the user.
                    StringCchCat(DirList, MAX_PATH, TEXT(&quot; &lt;DIR&gt; &quot;));
                    // Add error handling code here.
               }
     
               // Add the file name (or directory) to the list box.
               SendDlgItemMessage(hX, lstDirectory, LB_ADDSTRING,
                                  0, (LPARAM)DirList);
           }
     }
     while ( TRUE);
     
}
</code></pre>
<h3>Manipulating Options</h3>
<p><a href="/windows/desktop/api/Wininet/nf-wininet-internetsetoptiona"><strong>InternetSetOption</strong></a> and <a href="/windows/desktop/api/Wininet/nf-wininet-internetqueryoptiona"><strong>InternetQueryOption</strong></a> are used to manipulate the WinINet options.</p>
<p><a href="/windows/desktop/api/Wininet/nf-wininet-internetsetoptiona"><strong>InternetSetOption</strong></a> accepts a variable that indicates the option to set, a buffer to hold the option setting, and a pointer that contains the address of the variable that contains the length of the buffer.</p>
<p><a href="/windows/desktop/api/Wininet/nf-wininet-internetqueryoptiona"><strong>InternetQueryOption</strong></a> accepts a variable that indicates the option to retrieve, a buffer to hold the option setting, and a pointer that contains the address of the variable that contains the length of the buffer.</p>
<h3>Setting Up Asynchronous Operations</h3>
<p>By default, the WinINet functions operate synchronously. An application can request asynchronous operation by setting the <a href="api-flags.html">INTERNET_FLAG_ASYNC</a> flag in the call to the <a href="/windows/desktop/api/Wininet/nf-wininet-internetopena"><strong>InternetOpen</strong></a> function. All future calls made against handles derived from the handle returned from <a href="/windows/desktop/api/Wininet/nf-wininet-internetopena"><strong>InternetOpen</strong></a> are made asynchronously.</p>
<p>The rationale for asynchronous versus synchronous operation is to allow a single-threaded application to maximize its utilization of the CPU without having to wait for network I/O to complete. Therefore, depending on the request, the operation might complete synchronously or asynchronously. The application should check the return code. If a function returns <strong>FALSE</strong> or <strong>NULL</strong>, and <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror"><strong>GetLastError</strong></a> returns ERROR_IO_PENDING, the request has been made asynchronously, and the application is called back with INTERNET_STATUS_REQUEST_COMPLETE when the function has completed.</p>
<p>To begin asynchronous operation, the application must set the <a href="api-flags.html">INTERNET_FLAG_ASYNC</a> flag in its call to <a href="/windows/desktop/api/Wininet/nf-wininet-internetopena"><strong>InternetOpen</strong></a>. The application must then register a valid callback function, using <a href="/windows/desktop/api/Wininet/nf-wininet-internetsetstatuscallback"><strong>InternetSetStatusCallback</strong></a>.</p>
<p>After a callback function is registered for a handle, all operations on that handle can generate status indications, provided that the context value that was supplied when the handle was created was not zero. Providing a zero context value forces an operation to complete synchronously, even though <a href="api-flags.html">INTERNET_FLAG_ASYNC</a> was specified in <a href="/windows/desktop/api/Wininet/nf-wininet-internetopena"><strong>InternetOpen</strong></a>.</p>
<p>Status indications give the application feedback about the progress of network operations, such as resolving a host name, connecting to a server, and receiving data. Three special-purpose status indications can be made for a handle:</p>
<ul>
<li>INTERNET_STATUS_HANDLE_CLOSING is the last status indication that is made for a handle.</li>
<li>INTERNET_STATUS_HANDLE_CREATED indicates when the handle is initially created.</li>
<li>INTERNET_STATUS_REQUEST_COMPLETE indicates an asynchronous operation has completed.</li>
</ul>
<p>The application must check the <a href="/windows/desktop/api/Wininet/ns-wininet-internet_async_result"><strong>INTERNET_ASYNC_RESULT</strong></a> structure to determine whether the operation succeeded or failed after receiving an INTERNET_STATUS_REQUEST_COMPLETE indication.</p>
<p>The following sample shows an example of a callback function and a call to <a href="/windows/desktop/api/Wininet/nf-wininet-internetsetstatuscallback"><strong>InternetSetStatusCallback</strong></a> to register the function as the callback function.</p>
<pre lang="C++"><code>void CALLBACK InternetCallback(
    HINTERNET hInternet,
    DWORD_PTR dwcontext,
    DWORD dwInternetStatus,
    LPVOID lpvStatusInformation,
    DWORD dwStatusInformationLength
    )
{
    _tprintf(TEXT(&quot;%0xd %0xp %0xd %0xp %0xd\n&quot;),
             hInternet,
             dwcontext,
             dwInternetStatus,
             lpvStatusInformation,
             dwStatusInformationLength);
};

INTERNET_STATUS_CALLBACK dwISC =
    InternetSetStatusCallback(hInternet, InternetCallback); 
</code></pre>
<h3>Closing HINTERNET Handles</h3>
<p>All <a href="appendix-a-hinternet-handles.html"><strong>HINTERNET</strong></a> handles can be closed by using the <a href="/windows/desktop/api/Wininet/nf-wininet-internetclosehandle"><strong>InternetCloseHandle</strong></a> function. Client applications must close all <strong>HINTERNET</strong> handles derived from the <strong>HINTERNET</strong> handle they are trying to close before calling <a href="/windows/desktop/api/Wininet/nf-wininet-internetclosehandle"><strong>InternetCloseHandle</strong></a> on the handle.</p>
<p>The following example illustrates the handle hierarchy.</p>
<pre lang="C++"><code>HINTERNET hRootHandle, hOpenUrlHandle;

hRootHandle = InternetOpen( TEXT(&quot;Example&quot;), 
                            INTERNET_OPEN_TYPE_DIRECT, 
                            NULL, 
                            NULL, 0);

hOpenUrlHandle = InternetOpenUrl(hRootHandle, 
    TEXT(&quot;https://www.server.com/default.htm&quot;), NULL, 0, 
    INTERNET_FLAG_RAW_DATA,0);

// Close the handle created by InternetOpenUrl so that the
// InternetOpen handle can be closed.
InternetCloseHandle(hOpenUrlHandle); 

// Close the handle created by InternetOpen.
InternetCloseHandle(hRootHandle);
</code></pre>
<h3>Locking and Unlocking Resources</h3>
<p>The <a href="/windows/desktop/api/Wininet/nf-wininet-internetlockrequestfile"><strong>InternetLockRequestFile</strong></a> function allows an application to ensure that the cached resource associated with the <a href="appendix-a-hinternet-handles.html"><strong>HINTERNET</strong></a> handle passed to it does not disappear from the cache. If another download tries to commit a resource that has the same URL as the locked file, the cache avoids removing the file by doing a safe delete. After the application calls the <a href="/windows/desktop/api/Wininet/nf-wininet-internetunlockrequestfile"><strong>InternetUnlockRequestFile</strong></a> function, the cache is given permission to delete the file.</p>
<p>If the <a href="api-flags.html">INTERNET_FLAG_NO_CACHE_WRITE</a> or <a href="api-flags.html">INTERNET_FLAG_DONT_CACHE</a> flag has been set, <a href="/windows/desktop/api/Wininet/nf-wininet-internetlockrequestfile"><strong>InternetLockRequestFile</strong></a> creates a temporary file with the extension TMP, unless the handle is connected to an https resource. If the function accesses an https resource and INTERNET_FLAG_NO_CACHE_WRITE (or INTERNET_FLAG_DONT_CACHE) has been set, <a href="/windows/desktop/api/Wininet/nf-wininet-internetlockrequestfile"><strong>InternetLockRequestFile</strong></a> fails.</p>
<blockquote>
<p>[!Note]<br />
WinINet does not support server implementations. In addition, it should not be used from a service. For server implementations or services use <a href="/windows/desktop/WinHttp/winhttp-start-page">Microsoft Windows HTTP Services (WinHTTP)</a>.</p>
</blockquote>
<p>Â </p>
<p>Â </p>
<p>Â </p>
</body>
