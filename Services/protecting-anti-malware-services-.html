<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Protecting anti-malware services</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<h2>description: Learn about protecting anti-malware (AM) user mode services and how you can opt to include this feature in your anti-malware service.
ms.assetid: 88875a0d-9027-43f2-8411-34f9ff428fe5
title: Protecting anti-malware services
ms.topic: article
ms.date: 08/02/2018</h2>
<h1>Protecting anti-malware services</h1>
<p>WindowsÂ 8.1 introduced a new concept of protected services to protect anti-malware services, which are a frequent target of attack by malware.</p>
<p>Learn about protecting anti-malware (AM) user mode services and how you can opt to include this feature in your anti-malware service.</p>
<p>This information applies to the following operating systems and their successors:</p>
<ul>
<li>WindowsÂ 8.1</li>
<li>Windows ServerÂ 2012Â R2</li>
</ul>
<p>References and resources discussed here are listed at the end of this topic.</p>
<h2>Introduction</h2>
<p>Most anti-malware solutions include a user-mode service that performs specialized operations to detect and remove malware from the system. This user-mode service is also frequently responsible for downloading the latest virus definitions and signatures. This user-mode service becomes a frequent target of malware because itâ€™s the single point of failure to disable protection on a system. To defend against attacks on the user-mode service, anti-malware vendors have to add a lot of functionality and heuristics to their software. However, such techniques are not completely foolproof and tend to be error prone because they have to identify functionality that Windows performs on their service and selectively enable that functionality.</p>
<p>In WindowsÂ 8.1, a new concept of protected service has been introduced to allow anti-malware user-mode services to be launched as a protected service. After the service is launched as protected, Windows uses code integrity to only allow trusted code to load into the protected service. Windows also protects these processes from code injection and other attacks from admin processes.</p>
<p>This document describes how an anti-malware vendor with an Early Launch Anti-Malware (ELAM) driver can opt-in to this feature and launch their anti-malware service as a protected service.</p>
<h2>System-protected process</h2>
<p>Starting with WindowsÂ 8.1, a new security model has been put in place in the kernel to better defend against malicious attacks on system-critical components. This new security model extends the protected process infrastructure previous versions of Windows used for specific scenarios, such as playing DRM content, into a general-purpose model that can be used by 3rd party anti-malware vendors. The protected process infrastructure only allows trusted, signed code to load and has built-in defense against code injection attacks.</p>
<blockquote>
<p>[!NOTE]
The following scripting DLLs are forbidden by CodeIntegrity inside a protected process (whether loaded directly or indirectly) such as via WinVerifyTrust or WinVerifyTrustEx for checking script signatures via AuthentiCode: <code>scrobj.dll</code>, <code>scrrun.dll</code>, <code>jscript.dll</code>, <code>jscript9.dll</code>, and <code>vbscript.dll</code>.</p>
</blockquote>
<p>See <a href="https://download.microsoft.com/download/a/f/7/af7777e5-7dcd-4800-8a0a-b18336565f5b/process_vista.doc">Protected Processes in Windows Vista</a> for more information on protected processes.</p>
<p>The new security model uses a slightly different variant of the protection process infrastructure called system protected process, which is more suitable for this feature as this keeps the DRM content separate. Each system protected process has an associated level or attribute, which indicates the signature policy of the signed code allowed to load within the process. After the anti-malware services have opted into the protected service mode, only Windows signed code or code signed with the anti-malware vendorâ€™s certificates are allowed to load in that process. Similarly, other protected process levels have different code policies enforced by Windows.</p>
<h2>Requirements</h2>
<p>For an anti-malware user-mode service to run as a protected service, the anti-malware vendor must have an ELAM driver installed on the Windows machine. In addition to the existing ELAM driver certification requirements, the driver must have an embedded resource section containing the information of the certificates used to sign the user mode service binaries.</p>
<blockquote>
<p>[!IMPORTANT]
In Windows 8.1, the certification chain either has to be a known root as determined by driver verification, or the root certificate must be included.</p>
</blockquote>
<p>During the boot process, this resource section will be extracted from the ELAM driver to validate the certificate information and register the anti-malware service. The anti-malware service can also be registered during the anti-malware software installation process by calling a special API, as described later in this document.</p>
<p>After the resource section is successfully extracted from the ELAM driver and the user-mode service is registered, the service is allowed to launch as protected service. After the service is launched as protected, other non-protected processes on the system won't be able to inject threads, and they wont' be allowed to write into the virtual memory of the protected process.</p>
<p>In addition, any non-Windows DLLs that get loaded into the protected process must be signed with an appropriate certificate.</p>
<p>See <a href="/windows/desktop/w8cookbook/secured-boot">Early launch antimalware</a> for more information on ELAM drivers.</p>
<h3>Anti-malware service signing requirements</h3>
<p>The user-mode service that needs to be launched as protected must be signed with valid certificates. The service EXE must be page hash signed, and any non-Windows DLLs that get loaded into the service must be also signed with the same certificates. The hash of these certificates must be added into the resource file, which will be linked into the ELAM driver.</p>
<blockquote>
<p>[!NOTE]<br />
SHA256 file/page hashes must be used, though certificates may continue to be SHA1.</p>
</blockquote>
<h3>Primary signature (recommended)</h3>
<p>We recommend that anti-malware vendors use their existing Authenticode certificate to sign their anti-malware service binaries, and that the hash of this Authenticode certificate be included in the resource section to indicate the certificate that's used to sign the service binaries. If you update this certificate, a newer version of the ELAM driver must be released with the updated certificate hashes.</p>
<h3>Secondary signature (optional)</h3>
<p>Anti-malware vendors have the option to set up a private CA and use certificates from this CA to code sign the anti-malware service binaries as a secondary signature. The main advantage of using the private CA is that it enables vendors to create certificates with a specialized EKU property, which can be used to differentiate between multiple products from the same vendor. It also reduces the need to update your ELAM driver due to certificate expiry, as the private CA certs typically have longer expiry dates.</p>
<p>Note that if the service binaries are signed with the private CA certs, the binaries must also be dual signed with the existing Authenticode certificates. If the binaries are not signed by a well-known trusted CA (for example VeriSign), the user of the machine has no confidence in the binaries because they cannot trust the private CA. Dual signing the binaries with the existing Authenticode certificate also allows the binaries to run on down-level operating systems.</p>
<p>For more info about how to set up and install the Certificate Authority, see <a href="/previous-versions/windows/desktop/ms755466(v=vs.85)">Setting Up a Certificate Authority</a> and <a href="/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/jj125375(v=ws.11)">Install the Certification Authority</a>.</p>
<blockquote>
<p>[!NOTE]<br />
For compatibility with WindowsÂ Vista or WindowsÂ XP (or WindowsÂ 7 without the SHA2 patch), you can use the &quot;/as&quot; switch when signing your binaries with <a href="/windows/desktop/SecCrypto/signtool">SignTool.exe</a> with the SHA256 file/page hashes. This will add the signature as a secondary signature to the file. SHA1 sign the file first, since WindowsÂ XP, WindowsÂ Vista, and WindowsÂ 7 will only see the first signature.</p>
</blockquote>
<h3>DLL signing requirements</h3>
<p>As mentioned earlier, any non-Windows DLLs that get loaded into the protected service must be signed with the same certificate that was used to sign the anti-malware service.</p>
<h3>Catalog signing</h3>
<p>Anti-malware vendors can include packages developed by other companies without updating the binary signatures. This can be achieved by including the binaries in a catalog which is signed with their Authenticode certificate, accomplished by following these steps:</p>
<ol>
<li>Generate a catalog using <a href="/windows/desktop/SecCrypto/makecat">MakeCat</a></li>
<li>Add all of the binaries without an appropriate signature to the catalog</li>
<li>Sign the catalog with the Authenticode certificate, as you would any other binary</li>
<li>Use the <a href="/windows/win32/api/Mscat/nf-mscat-cryptcatadminaddcatalog">add catalog</a> function to include the catalog with the application.</li>
</ol>
<p>When code integrity comes across the packages without an appropriate signature, it will search for a catalog with an approved signature. It will find this catalog as long as these steps are followed and it is installed with the application.</p>
<h2>Resource file info</h2>
<p>A resource file must be created and linked into the ELAM driver. The hash of the certificate, along with other certificate information, must be added in the resource file.</p>
<p>The resource section must be in the following layout for the system to successfully extract the resources from the binary image and validate the embedded certificate information.</p>
<pre lang="syntax"><code>MicrosoftElamCertificateInfo  MSElamCertInfoID
{
      3, // count of entries
      Lâ€CertHash1\0â€,
      Algorithm,
      Lâ€EKU1\0â€,
      Lâ€CertHash2\0â€,
      Algorithm,
      Lâ€\0â€, //No EKU for cert hash 2
      Lâ€CertHash3\0â€,
      Algorithm,
      Lâ€EKU3a;EKU3b;EKU3c\0â€,  //multiple EKU entries supported (max: 3)
}
</code></pre>
<p>For more info about user-defined resource file, see <a href="/windows/desktop/menurc/user-defined-resource">User-Defined Resource</a>.</p>
<h3>CertHash</h3>
<p>The hash of the certificate that's used to sign the anti-malware service. The CertUtil.exe tool, which ships in the Windows SDK, can be used to obtain the hash.</p>
<pre lang="syntax"><code>certutil.exe â€“v &lt;path to the signed file&gt;
</code></pre>
<p>For example:</p>
<p><img src="images/cert-hash-example.png" alt="anti-malware protected service certificate hash (certhash)" /></p>
<h3>Algorithm</h3>
<p>The algorithm value represents the algorithm of the certificate. These algorithm values are supported:</p>
<!-- raw HTML omitted -->
<p>Remember to include the value of the algorithm (as shown above) and not the actual name of the algorithm. For example, if the cert is based on the SHA256 algorithm, include 0x800c in the resource section.</p>
<h3>EKU</h3>
<p>The EKU object represents a single extended key usage (EKU) property of a certificate. This is optional and â€œ\0â€ should be specified if no EKUs are associated with the cert. In a case where there are multiple products and services from a single anti-malware vendor running on the same system, the anti-malware vendor can use the EKU property of the private CA certificate to differentiate one service from another. For example, if there are two services running on the system from the same anti-malware vendor and signed by the same CA, the service that needs to be launched as protected can be signed with a cert issued by CA that contains a special EKU. This EKU must be added to the resource section. The EKU is then registered by the system and paired with the certificate hash for validating and launching the service as protected.</p>
<p>Note that the certificate chain must include the Code Signing EKU (1.3.6.1.5.5.7.3.3), but this EKU must not be included in the resource section of the ELAM driver.</p>
<blockquote>
<p>[!NOTE]
If EKU information is included in certificate information for the ELAM driver, then the same EKU must be used when signing your binaries.</p>
</blockquote>
<blockquote>
<p>[!NOTE]
Windows code integrity's string representation of an OID in a EKU has a maximum length of 64 characters, including the zero termination character.
Â 
[!NOTE]
If you specify multiple EKUs, then they are evaluated with <code>AND</code> logic. The end-entity certificate must satisfy all EKUs specified in the ELAM resource section for the given entry.</p>
</blockquote>
<h3>Count</h3>
<p>If the anti-malware service binary is signed with the Authenticode certificate as well as the private CA certificate, only the private CA certificate information must be added in the resource section.</p>
<h2>Launching anti-malware services as protected</h2>
<h3>Registering the service</h3>
<p>The anti-malware service must be registered with the system before it can be started as protected. During the installation of the anti-malware software, the installer can install the ELAM driver and reboot the system to automatically register the service. The system will register the service at boot time by extracting the certificate information from the aforementioned resource file that is linked into the ELAM driver.</p>
<p>During the installation phase, it is highly recommended that the system is restarted in order for the ELAM driver to get loaded and validate the state of the system. However, for cases where a reboot must be avoided, Windows also exposes a mechanism for the anti-malware installer to register the service as protected using an API.</p>
<h3>Registering the service without rebooting the system</h3>
<p>During the installation, an anti-malware software installer can call the <a href="/windows/win32/api/sysinfoapi/nf-sysinfoapi-installelamcertificateinfo"><strong>InstallELAMCertificateInfo</strong></a> API and provide a handle to the ELAM driver file. The system opens the ELAM driver, calls internal routines to make sure the ELAM driver is signed properly, and extracts the certificate information from the resource section associated with the ELAM driver. For function syntax see <a href="/windows/win32/api/sysinfoapi/nf-sysinfoapi-installelamcertificateinfo"><strong>InstallELAMCertificateInfo</strong></a>.</p>
<p>Code example:</p>
<pre lang="C++"><code>HANDLE FileHandle = NULL;

FileHandle = CreateFile(&lt;Insert Elam driver file name&gt;,
                        FILE_READ_DATA,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

if (InstallElamCertificateInfo(FileHandle) == FALSE)
{
    Result = GetLastError();
    goto exitFunc;
}
</code></pre>
<h3>Starting the service as protected</h3>
<p>The installer can follow these steps to create, configure, and start the service as protected:</p>
<ol>
<li>
<p>Call the <a href="/windows/win32/api/Winsvc/nf-winsvc-createservicea"><strong>CreateService</strong></a> API to create a service object and add it to the service control manager (SCM) database.</p>
</li>
<li>
<p>Call the <a href="/windows/win32/api/winsvc/nf-winsvc-setserviceobjectsecurity"><strong>SetServiceObjectSecurity</strong></a> API to set the security descriptor of the service object created in step 1.</p>
</li>
<li>
<p>Call the <a href="/windows/win32/api/Winsvc/nf-winsvc-changeserviceconfig2a"><strong>ChangeServiceConfig2</strong></a> API to mark the service as protected, specifying the new <strong>SERVICE_CONFIG_LAUNCH_PROTECTED</strong> enumeration value, which has been added in Winsvc.h (as of WindowsÂ 8.1).</p>
<p>Code example:</p>
<pre lang="C++"><code>SERVICE_LAUNCH_PROTECTED_INFO Info;
SC_HANDLE hService;

Info.dwLaunchProtected = SERVICE_LAUNCH_PROTECTED_ANTIMALWARE_LIGHT;

hService = CreateService (/* ... */);

if (ChangeServiceConfig2(hService,
                         SERVICE_CONFIG_LAUNCH_PROTECTED,
                         &amp;Info) == FALSE)
{
    Result = GetLastError();
}
</code></pre>
</li>
<li>
<p>Call the <a href="/windows/win32/api/Winsvc/nf-winsvc-startservicea"><strong>StartService</strong></a> API to start the service. When starting the service as protected, SCM checks with Code Integrity (CI) subsystem to validate the certificate information. After the certificate information is validated by CI, SCM launches the service as protected.</p>
<ol>
<li>Note that this step fails if you havenâ€™t registered the service by calling the <a href="/windows/win32/api/sysinfoapi/nf-sysinfoapi-installelamcertificateinfo"><strong>InstallELAMCertificateInfo</strong></a> API.</li>
<li>If the service has been configured to start automatically during the system startup phase, you can avoid this step and simply reboot the system. During a reboot, the system automatically registers the service (if the ELAM driver starts successfully) and starts the service in protected mode.</li>
<li>If the service fails to start, then see the info at <a href="/windows-hardware/drivers/install/enabling-code-integrity-event-logging-and-system-auditing">Code integrity event-logging and system auditing</a>, and following topics. There, you'll find more detailed error messages that explain why the Code integrity system has prevented the service from starting. Those logs can also help you to identify DLLs that the service tried to load but was unable to.</li>
</ol>
</li>
</ol>
<h3>Launching a child process as protected</h3>
<p>The new security model also allows the anti-malware protected services to launch child processes as protected. These child processes will run at the same protection level as the parent service and their binaries must be signed with the same certificate that has been registered via ELAM resource section.</p>
<p>In order to allow anti-malware protected service to launch child process as protected, a new extended attribute key, <strong>PROC_THREAD_ATTRIBUTE_PROTECTION_LEVEL</strong>, has been exposed and must be used with the <a href="/windows/win32/api/processthreadsapi/nf-processthreadsapi-updateprocthreadattribute"><strong>UpdateProcThreadAttribute</strong></a> API. A pointer to the attribute value of <strong>PROTECTION_LEVEL_SAME</strong> must be passed into the <strong>UpdateProcThreadAttribute</strong> API.</p>
<p>Notes:</p>
<ul>
<li>In order to use this new attribute, the service must also specify <strong>CREATE_PROTECTED_PROCESS</strong> in the process creation flags parameter of the <a href="/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa"><strong>CreateProcess</strong></a> call.</li>
<li>You need to have your service binaries signed using the /ac switch to include the cross-certificate to chain it up to a known CA. Self-signed cert without proper chaining to a known root CA will not work.</li>
</ul>
<p>Code example:</p>
<pre lang="C++"><code>DWORD ProtectionLevel = PROTECTION_LEVEL_SAME;
SIZE_T AttributeListSize;

STARTUPINFOEXW StartupInfoEx = { 0 };

StartupInfoEx.StartupInfo.cb = sizeof(StartupInfoEx);

if (InitializeProcThreadAttributeList(NULL,
                                      1,
                                      0,
                                      &amp;AttributeListSize) == FALSE)
{
    Result = GetLastError();
    goto exitFunc;
}

StartupInfoEx.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST) HeapAlloc(
    GetProcessHeap(),
    0,
    AttributeListSize
    );

if (InitializeProcThreadAttributeList(StartupInfoEx.lpAttributeList,
                                      1,
                                      0,
                                      &amp;AttributeListSize) == FALSE)
{
    Result = GetLastError();
    goto exitFunc;
}

if (UpdateProcThreadAttribute(StartupInfoEx.lpAttributeList,
                              0,
                              PROC_THREAD_ATTRIBUTE_PROTECTION_LEVEL,
                              &amp;ProtectionLevel,
                              sizeof(ProtectionLevel),
                              NULL,
                              NULL) == FALSE)
{
    Result = GetLastError();
    goto exitFunc;
}

PROCESS_INFORMATION ProcessInformation = { 0 };

if (CreateProcessW(ApplicationName,
                   CommandLine,
                   ProcessAttributes,
                   ThreadAttributes,
                   InheritHandles,
                   EXTENDED_STARTUPINFO_PRESENT | CREATE_PROTECTED_PROCESS,
                   Environment,
                   CurrentDirectory,
                   (LPSTARTUPINFOW)&amp;StartupInfoEx,
                   &amp;ProcessInformation) == FALSE)
{
    Result = GetLastError();
    goto exitFunc;
}
</code></pre>
<h2>Updates and servicing</h2>
<p>After the anti-malware service is launched as protected, other non-protected processes (and even admins) aren't able to stop the service. In the case of updates to the service binaries, the anti-malware service needs to receive a callback from the installer to stop itself so that it can be serviced. After the service is stopped, the anti-malware installer can perform upgrades and then follow the steps described above in the <a href="https://www.bing.com/search?q=Registering+the+service">Registering the service</a> and <a href="#starting-the-service-as-protected">Starting the service as protected</a> sections to register the certificate and start the service as protected.</p>
<p>Note that the service should ensure that only trusted callers can stop the service. Allowing untrusted callers to do so defeats the purpose of protecting the service.</p>
<h3>Unregistering the service</h3>
<p>When you uninstall a protected service, the service must mark itself as unprotected by calling the <a href="/windows/win32/api/Winsvc/nf-winsvc-changeserviceconfig2a"><strong>ChangeServiceConfig2</strong></a> API. Note that because the system doesn't allow any non-protected process to alter the configuration of a protected service, the call to <a href="/windows/win32/api/Winsvc/nf-winsvc-changeserviceconfig2a"><strong>ChangeServiceConfig2</strong></a> must be made by the protected service itself. After the service has been reconfigured to run as unprotected, the uninstaller can simply take appropriate steps to remove the anti-malware software from the system.</p>
<h2>Debugging an anti-malware protected service</h2>
<p>As part of the protected process security model, other non-protected processes aren't able to inject threads or write into the virtual memory of the protected process. However a kernel debugger (KD) is allowed for debugging any anti-malware protected processes. The KD can also be used to check if the anti-malware service is running as protected or not:</p>
<pre lang="syntax"><code>dt â€“r1 nt!_EPROCESS &lt;Process Address&gt;
+0x67a Protection       : _PS_PROTECTION
      +0x000 Level            : 0x31 '1'
      +0x000 Type             : 0y0001
      +0x000 Signer           : 0y0011
</code></pre>
<p>If the value of the <em>Type</em> member is 0y0001, the service is running as protected.</p>
<p>In addition, only the following SC commands are allowed on anti-malware protected service:</p>
<ul>
<li><code>sc config start=Auto</code></li>
<li><code>sc qc</code></li>
<li><code>sc start</code></li>
<li><code>sc interrogate</code></li>
<li><code>sc sdshow</code></li>
</ul>
<p>If the debugger is attached, use the following flag in the registry to break in the debugger when unsigned (or inappropriately signed) binaries are loaded into the anti-malware protected service.</p>
<pre lang="syntax"><code>Key:   HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\CI
Value: DebugFlags      REG_DWORD
</code></pre>
<p>Set the value to <strong>00000400</strong> to break in the debugger when the signature validation fails.</p>
<blockquote>
<p>[!NOTE]<br />
Protected Process limitations:</p>
<ol>
<li>Processes that have UI or a GUI cannot be protected because of the way the kernel locks a process in memory and does not allow writes to it.</li>
<li>Prior to WindowsÂ 10, version 1703 (the Creators update), protected processes cannot use the TLS or SSL communication protocols due to limitations of certificate sharing between the Local Security Authority (LSA) and a protected process.</li>
</ol>
</blockquote>
<h2>Resources</h2>
<p>For more info, see:</p>
<ul>
<li><a href="/windows/desktop/w8cookbook/secured-boot">Early launch antimalware</a></li>
<li><a href="/previous-versions/windows/hardware/download/dn550976(v=vs.85)">Protected processes in Windows Vista</a></li>
<li><a href="/previous-versions/windows/desktop/ms755466(v=vs.85)">Setting Up a certificate authority</a></li>
<li><a href="/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/jj125375(v=ws.11)">Install the certification authority</a></li>
<li><a href="/windows/desktop/menurc/user-defined-resource">User-defined resource</a></li>
<li><a href="/windows-hardware/drivers/install/catalog-files">Catalog files and digital signatures</a></li>
<li><a href="/windows-hardware/drivers/install/enabling-code-integrity-event-logging-and-system-auditing">Code integrity event-logging and system auditing</a></li>
</ul>
<p>These Windows API functions are referenced in this article:</p>
<ul>
<li><a href="/windows/win32/api/Winsvc/nf-winsvc-changeserviceconfig2a">ChangeServiceConfig2</a></li>
<li><a href="/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a></li>
<li><a href="/windows/win32/api/Winsvc/nf-winsvc-createservicea">CreateService</a></li>
<li><a href="/windows/win32/api/processthreadsapi/nf-processthreadsapi-initializeprocthreadattributelist">InitializeProcThreadAttributeList</a></li>
<li><a href="/windows/win32/api/sysinfoapi/nf-sysinfoapi-installelamcertificateinfo">InstallELAMCertificateInfo</a></li>
<li><a href="/windows/win32/api/winsvc/nf-winsvc-setserviceobjectsecurity">SetServiceObjectSecurity</a></li>
<li><a href="/windows/win32/api/Winsvc/nf-winsvc-startservicea">StartService</a></li>
<li><a href="/windows/win32/api/processthreadsapi/nf-processthreadsapi-updateprocthreadattribute">UpdateProcThreadAttribute</a></li>
</ul>
</body>
