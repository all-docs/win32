<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>The Header</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<h2>title: The Header
description: The following header represents one of the header styles that can be generated by the current version of MIDL. For convenience, the full list of header fields is provided here.
ms.assetid: 2078d2d9-1757-4449-9cc1-a21804654722
ms.topic: article
ms.date: 05/31/2018</h2>
<h1>The Header</h1>
<p>The following header represents one of the header styles that can be generated by the current version of MIDL. For convenience, the full list of header fields is provided here.</p>
<p>(<a href="/windows/desktop/Midl/-oi"><strong>â€“Oif</strong></a> header)</p>
<pre lang="syntax"><code>handle_type&lt;1&gt; 
Oi_flags&lt;1&gt;
[rpc_flags&lt;4&gt;]
proc_num&lt;2&gt;  
stack_size&lt;2&gt;
[explicit_handle_description&lt;&gt;]
constant_client_buffer_size&lt;2&gt;
constant_server_buffer_size&lt;2&gt;
INTERPRETER_OPT_FLAGS&lt;1&gt;
number_of_params&lt;1&gt;
</code></pre>
<p>Extensions starting with WindowsÂ 2000: <!-- raw HTML omitted --> for 64-bit)</p>
<pre lang="syntax"><code>extension_version&lt;1&gt;
INTERPRETER_OPT_FLAGS2&lt;1&gt;
ClientCorrHint&lt;2&gt;
ServerCorrHint&lt;2&gt;
NotifyIndex&lt;2&gt;
[ FloatDoubleMask&lt;2&gt; ]
</code></pre>
<p>The extension_version<!-- raw HTML omitted --> provides the size of the extension section, in bytes. Doing so makes it possible for the current NDR engine to step over the extension section correctly even if the section were to come from a later compiler version with more fields than the current engine understands.</p>
<p>The INTERPRETER_OPT_FLAGS2 are defined as follow:</p>
<pre lang="syntax"><code>typedef struct
  {
  unsigned char   HasNewCorrDesc      : 1;    // 0x01
  unsigned char   ClientCorrCheck     : 1;    // 0x02
  unsigned char   ServerCorrCheck     : 1;    // 0x04
  unsigned char   HasNotify           : 1;    // 0x08
  unsigned char   HasNotify2          : 1;    // 0x10
  unsigned char   Unused              : 3;
  } INTERPRETER_OPT_FLAGS2, *PINTERPRETER_OPT_FLAGS2;
</code></pre>
<p>The <strong>HasNewCorrDesc</strong> member indicates whether new correlation descriptors are used in the format strings generated by the compiler. The new correlation descriptor is related to the denial-of-attack functionality. The <strong>ClientCorrCheck</strong> and <strong>ServerCorrCheck</strong> members are set when the routine needs the correlation check on the indicated side.</p>
<p>The <strong>HasNotify</strong> and <strong>HasNotify2</strong> flags indicate that the routine uses the notify feature as defined by the <strong>[notify]</strong> and <strong>[notify_flag]</strong> attributes, respectively.</p>
<p>The <strong>ClientCorrHint</strong> member is a cache size hint on the client side and <strong>ServerCorrHint</strong> is a hint on the server side. When the size comes out as zero, a default size should be used.</p>
<p>The <strong>NotifyIndex</strong> element is an index to a notify routine, if one is used.</p>
<p>The <strong>FloatDoubleMask</strong> element addresses the issue of a floating point argument for 64-bit Windows. This field is generated only for 64-bit stubs. The mask is needed for the assembly routines that download/upload registers from/to the virtual stack to handle floating-point arguments and registers properly. The mask consist of 2 bits per argument, or rather per floating-point register. The coding is as follows: The least significant bits correspond to the first FP register, the next 2 bits correspond to the second register, and so on.</p>
<blockquote>
<p>[!Note]<br />
For object routines, the first argument ends up in the second register due to this pointer being first. For each register the meaning of bits is as shown in the following table.</p>
</blockquote>
<p>Â </p>
<table>
<thead>
<tr>
<th>Bits</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>A float value should be loaded to the register.</td>
</tr>
<tr>
<td>10</td>
<td>A double value should be loaded to the register.</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>00 and 11 are invalid values for the bits.</p>
<p>Currently there are eight FP registers in an Intel Architecture 64-bit processor, hence the mask can have only 16b lowest bits set. The mask size has been set to a total of 16 bits based on the C-compiler mask remaining unchanged.</p>
<h2>Header Streamlining for Performance</h2>
<p>To simplify code and improve performance, the compiler attempts to generate a fixed size header whenever possible. In particular, the following header is used for async DCOM:</p>
<pre lang="syntax"><code>typedef struct _NDR_DCOM_OI2_PROC_HEADER
  {
  unsigned char               HandleType;        // The Oi header
  INTERPRETER_FLAGS           OldOiFlags;        //
  unsigned short              RpcFlagsLow;       //
  unsigned short              RpcFlagsHi;        //
  unsigned short              ProcNum;           //
  unsigned short              StackSize;         //
  // expl handle descr is never generated        //
  unsigned short              ClientBufferSize;  // The Oi2 header
  unsigned short              ServerBufferSize;  //
  INTERPRETER_OPT_FLAGS       Oi2Flags;          //
  unsigned char               NumberParams;      //
  } NDR_DCOM_OI2_PROC_HEADER, *PNDR_DCOM_OI2_PROC_HEADER;
</code></pre>
<p>Â </p>
<p>Â </p>
</body>
