<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Type Serialization</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<h2>title: Type Serialization
description: The MIDL compiler generates up to three functions for each type to which the \ encode\ or \ decode\ attribute is applied.
ms.assetid: 948f1dd7-c8b0-4fa0-88d8-9d122de52ba1
ms.topic: article
ms.date: 05/31/2018</h2>
<h1>Type Serialization</h1>
<p>The MIDL compiler generates up to three functions for each type to which the [ <a href="/windows/desktop/Midl/encode">encode</a>] or [ <a href="/windows/desktop/Midl/decode">decode</a>] attribute is applied. For example, for a user-defined type named <em>MyType</em>, the compiler generates code for the MyType_Encode, MyType_Decode, and MyType_AlignSize functions. For these functions, the compiler writes prototypes to Stub.h and source code to Stub_c.c. Generally, you can encode a <em>MyType</em> object with MyType_Encode and decode an object from the buffer using MyType_Decode. MyType_AlignSize is used if you need to know the size of the marshaling buffer before allocating it.</p>
<p>The following encoding function is generated by the MIDL compiler. This function serializes the data for the object pointed to by pObject, and the buffer is obtained according to the method specified in the handle. After writing the serialized data to the buffer, you control the buffer. Note that the handle inherits the status from the previous calls, and the buffers must be aligned at 8.</p>
<p>For an implicit handle:</p>
<pre lang="syntax"><code>void MyType_Encode (MyType __RPC_FAR * pObject);
</code></pre>
<p>For an explicit handle:</p>
<pre lang="syntax"><code>void MyType_Encode (handle_t Handle, MyType __RPC_FAR * pObject);
</code></pre>
<p>The following function deserializes the data from the application's storage into the object pointed to by pObject. You supply a marshaled buffer according to the method specified in the handle. Note that the handle can inherit the status from the previous calls and the buffers must be aligned at 8.</p>
<p>For an implicit handle:</p>
<pre lang="syntax"><code>void MyType_Decode (MyType __RPC_FAR * pObject);
</code></pre>
<p>For an explicit handle:</p>
<pre lang="syntax"><code>void MyType_Decode (handle_t Handle, MyType __RPC_FAR * pObject);
</code></pre>
<p>The following function returns a size, in bytes, that includes the type instance plus any padding bytes needed to align the data. This enables serializing a set of instances of the same or different types into a buffer while ensuring that the data for each object is appropriately aligned. MyType_AlignSize assumes that the instance pointed to by pObject will be marshaled into a buffer beginning at the offset aligned at 8.</p>
<p>For an implicit handle:</p>
<pre lang="syntax"><code>size_t MyType_AlignSize (MyType __RPC_FAR * pObject);
</code></pre>
<p>For an explicit handle:</p>
<pre lang="syntax"><code>size_t MyType_AlignSize (handle_t Handle, MyType __RPC_FAR * pObject);
</code></pre>
<p>Note that both remote procedures with implicit binding handles and serialized types with implicit serialization handles use the same global handle variable. Therefore, it is advisable not to mix type serialization and remote procedures in an interface with implicit handles. For details, see <a href="implicit-versus-explicit-handles.html">Implicit Versus Explicit Handles</a>.</p>
<p>Â </p>
<p>Â </p>
</body>
