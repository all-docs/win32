<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Stub-Allocated Buffers</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<h2>title: Stub-Allocated Buffers
description: Rather than forcing a distinct call for each node of the tree or graph, you can direct the stubs to compute the size of the data and to allocate and free memory by making a single call to midl_user_allocate or midl_user_free.
ms.assetid: 9911649d-00e8-47d8-b512-7d9b185d1e09
ms.topic: article
ms.date: 05/31/2018</h2>
<h1>Stub-Allocated Buffers</h1>
<p>Rather than forcing a distinct call for each node of the tree or graph, you can direct the stubs to compute the size of the data and to allocate and free memory by making a single call to <a href="/windows/desktop/Midl/midl-user-allocate-1">midl_user_allocate</a> or <a href="/windows/desktop/Midl/midl-user-free-1">midl_user_free</a>. The ACF attribute <strong>[allocate(all_nodes)]</strong> directs the stubs to allocate or free all nodes in a single call to the user suppliedâ€“memory management functions.</p>
<p>For example, an RPC application might use the following binary tree data structure:</p>
<pre lang="syntax"><code>/* IDL file fragment */
typedef struct _TREE_TYPE 
{
    short sNumber;
    struct _TREE_TYPE * pLeft;
    struct _TREE_TYPE * pRight;
} TREE_TYPE;

typedef TREE_TYPE * P_TREE_TYPE;
</code></pre>
<p>The ACF attribute <strong>[allocate(all_nodes)]</strong> applied to this data type appears in the <strong>typedef</strong> declaration in the ACF as:</p>
<pre lang="syntax"><code>/* ACF file fragment */
typedef [allocate(all_nodes)] P_TREE_TYPE;
</code></pre>
<p>The <strong>[allocate]</strong> attribute can only be applied to pointer types. The <strong>[allocate]</strong> ACF attribute is a Microsoft extension to DCE IDL and, as such, is not available if you compile with the MIDL <strong>/osf</strong> switch. When <strong>[allocate(all_nodes)]</strong> is applied to a pointer type, the stubs generated by the MIDL compiler traverse the specified data structure to determine the allocation size. The stubs then make a single call to allocate the entire amount of memory needed by the graph or tree. A client application can free memory much more efficiently by making a single call to <strong>midl_user_free</strong>. However, server-stub performance is generally increased when using node-by-node memory allocation because the server stubs can often use private memory that requires no allocations.</p>
<p>For additional information, see <a href="node-by-node-allocation-and-deallocation.html">Node-by-Node Allocation and Deallocation</a>.</p>
<p>Â </p>
<p>Â </p>
</body>
