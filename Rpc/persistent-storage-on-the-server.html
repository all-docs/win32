<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Persistent Storage on the Server</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<h2>title: Persistent Storage on the Server
description: You can optimize your application so the server stub does not free memory on the server at the conclusion of a remote procedure call.
ms.assetid: 340334e2-94ac-4be2-a16d-38bc4c64e7db
ms.topic: article
ms.date: 05/31/2018</h2>
<h1>Persistent Storage on the Server</h1>
<p>You can optimize your application so the server stub does not free memory on the server at the conclusion of a remote procedure call. For example, when a context handle will be manipulated by several remote procedures, you can use the ACF attribute <strong>[allocate(dont_free)]</strong> to retain the allocated memory on the server.</p>
<p>The <strong>[allocate(dont_free)]</strong> attribute is added to the ACF <strong>typedef</strong> declaration in the ACF. For example:</p>
<pre lang="syntax"><code>/* ACF file fragment */
typedef [allocate(all_nodes, dont_free)] P_TREE_TYPE;
</code></pre>
<p>When the <strong>[allocate(dont_free)]</strong> attribute is specified, the tree data structure is allocated, but not freed, by the server stub. When you make the pointers to such persistent data areas available to other routinesâ€”for example, by copying the pointers to global variablesâ€”the retained data is accessible to other server functions. The <strong>[allocate(dont_free)]</strong> attribute is particularly useful for maintaining persistent pointer structures as part of the server state information associated with a context-handle type.</p>
<p>Â </p>
<p>Â </p>
</body>
