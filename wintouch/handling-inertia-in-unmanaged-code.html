<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Handling Inertia in Unmanaged Code</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<p>title: Handling Inertia in Unmanaged Code
description: This section explains how to use the IInertiaProcessor interface for handling inertia in unmanaged code.
ms.assetid: 3261b461-add2-4e92-9a51-b2d46630fb4f
keywords:</p>
<ul>
<li>Windows Touch,inertia</li>
<li>Windows Touch,manipulation processor</li>
<li>inertia,unmanaged code</li>
<li>inertia,IInertiaProcessor interface</li>
<li>inertia,manipulation processor</li>
<li>manipulation processor,inertia</li>
<li>IInertiaProcessor interface,unmanaged code
ms.topic: article
ms.date: 05/31/2018</li>
</ul>
<hr />
<h1>Handling Inertia in Unmanaged Code</h1>
<p>This section explains how to use the <a href="/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor"><strong>IInertiaProcessor</strong></a> interface for handling inertia in unmanaged code.</p>
<h2>Overview</h2>
<p>To use inertia in unmanaged code, you must implement event sinks both for the manipulation processor and the inertia processor. Start by adding manipulation support to your application as described in the section <a href="adding-manipulation-support-in-unmanaged-code.html">Adding Manipulation Support to Unmanaged Code</a>. Note that manipulation support requires that you use touch messages rather than gesture messages to feed event data to the manipulation processor. After you have manipulation working, you must also implement a second event sink for the events that the <a href="/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor"><strong>IInertiaProcessor</strong></a> interface will be generating or will need to modify your existing event sink to accommodate both the events generated by the <strong>IInertiaProcessor</strong> and the <a href="/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor"><strong>IManipulationProcessor</strong></a> interfaces. For the purposes of this example, it is easier to start from the event sink created for the section Adding Manipulation Support to Unmanaged Code and add a second constructor that works with the inertia processor instead of the manipulation processor. This way, the event sink implementation can function for either the manipulation processor or the inertia processor. In addition to adding a second constructor, the event sink will have a variable indicating whether it will perform the operations based on inertia input rather than manipulation input.</p>
<h3>Add Inertia Support to a Manipulation Processor Event Sink</h3>
<p>The following code shows the new event sink constructor, new member variables for an <a href="/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor"><strong>IInertiaProcessor</strong></a> interface, and a flag indicating whether the sink is extrapolating for inertia.</p>
<pre lang="C++"><code>    CManipulationEventSink(IManipulationProcessor *pManip, IInertiaProcessor *pInert, HWND hWnd);
    CManipulationEventSink(IInertiaProcessor *pInert, HWND hWnd);
</code></pre>
<pre lang="C++"><code>    IInertiaProcessor*      m_pInert;
    BOOL fExtrapolating; 
</code></pre>
<p>After your class header has the new constructors and a flag indicating whether you're extrapolating, you can implement your event sink to have separate handling blocks for the <a href="/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor"><strong>IManipulationProcessor</strong></a> events and <a href="/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor"><strong>IInertiaProcessor</strong></a> events. The constructor that accepts an <strong>IManipulationProcessor</strong> and an <strong>IInertiaProcessor</strong> should set the <strong>fExtrapolating</strong> flag to false, which indicates that this is a <strong>IManipulationProcessor</strong> event handler. The following code shows how the constructor for an event sink that uses the <strong>IManipulationProcessor</strong> could be implemented.</p>
<pre lang="C++"><code>CManipulationEventSink::CManipulationEventSink(IManipulationProcessor *pManip, IInertiaProcessor *pInert, HWND hWnd)
{
    m_hWnd = hWnd;

    //Set initial ref count to 1.
    m_cRefCount = 1;

    fExtrapolating=FALSE;

    m_pManip = pManip;
    
    m_pInert = pInert;
    
    m_pManip-&gt;put_PivotRadius(-1);

    m_cStartedEventCount = 0;
    m_cDeltaEventCount = 0;
    m_cCompletedEventCount = 0;

    HRESULT hr = S_OK;

    //Get the container with the connection points.
    IConnectionPointContainer* spConnectionContainer;
    
    hr = pManip-&gt;QueryInterface(
      IID_IConnectionPointContainer, 
          (LPVOID*) &amp;spConnectionContainer
        );
    //hr = manip-&gt;QueryInterface(&amp;spConnectionContainer);
    if (spConnectionContainer == NULL){
        // something went wrong, try to gracefully quit
        
    }

    //Get a connection point.
    hr = spConnectionContainer-&gt;FindConnectionPoint(__uuidof(_IManipulationEvents), &amp;m_pConnPoint);
    if (m_pConnPoint == NULL){
        // something went wrong, try to gracefully quit
    }

    DWORD dwCookie;

    //Advise.
    hr = m_pConnPoint-&gt;Advise(this, &amp;dwCookie);
}
</code></pre>
<p>The following code shows how the constructor for an event sink that uses the <a href="/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor"><strong>IInertiaProcessor</strong></a> could be implemented. This constructor sets the <strong>fExtrapolating</strong> flag to true, indicating that this instance of the event sink class will be performing extrapolation and will perform any movement operations that were performed previously by the manipulation processor events.</p>
<pre lang="C++"><code>CManipulationEventSink::CManipulationEventSink(IInertiaProcessor *pInert, HWND hWnd)
{
    m_hWnd = hWnd;

    m_pInert = pInert;
    //Set initial ref count to 1.
    m_cRefCount = 1;

    fExtrapolating=TRUE;

    m_cStartedEventCount = 0;
    m_cDeltaEventCount = 0;
    m_cCompletedEventCount = 0;

    HRESULT hr = S_OK;

    //Get the container with the connection points.
    IConnectionPointContainer* spConnectionContainer;
    
    hr = pInert-&gt;QueryInterface(
      IID_IConnectionPointContainer, 
          (LPVOID*) &amp;spConnectionContainer
        );
    //hr = manip-&gt;QueryInterface(&amp;spConnectionContainer);
    if (spConnectionContainer == NULL){
        // something went wrong, try to gracefully quit        
    }

    //Get a connection point.
    hr = spConnectionContainer-&gt;FindConnectionPoint(__uuidof(_IManipulationEvents), &amp;m_pConnPoint);
    if (m_pConnPoint == NULL){
        // something went wrong, try to gracefully quit
    }
    DWORD dwCookie;

    //Advise.
    hr = m_pConnPoint-&gt;Advise(this, &amp;dwCookie);
}   
</code></pre>
<blockquote>
<p>[!Note]<br />
The event sink class implementation from the manipulation processor event sink is reused as an event sink for the inertia processor.</p>
</blockquote>
<p>Â </p>
<p>Now when you construct this class, <strong>CManipulationEventSink</strong>, it can either be constructed as an event sink for a manipulation processor or as an event sink for an inertia processor. When it's constructed as an inertia processor event sink, it will have the <strong>fExtrapolating</strong> flag set to true, indicating that manipulation events should be extrapolated.</p>
<blockquote>
<p>[!Note]<br />
<a href="/windows/win32/api/manipulations/nf-manipulations-_imanipulationevents-manipulationstarted"><strong>ManipulationStarted</strong></a> will be raised by both the <a href="/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor"><strong>IManipulationProcessor</strong></a> and <a href="/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor"><strong>IInertiaProcessor</strong></a> interfaces.</p>
</blockquote>
<p>Â </p>
<p>When manipulation starts, the <a href="/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor"><strong>IInertiaProcessor</strong></a> interface properties are set. The following code shows how the started event is handled.</p>
<pre lang="C++"><code>HRESULT STDMETHODCALLTYPE CManipulationEventSink::ManipulationStarted( 
    /* [in] */ FLOAT x,
    /* [in] */ FLOAT y)
{
    m_cStartedEventCount ++;       

    // set origins in manipulation processor
    m_pInert-&gt;put_InitialOriginX(x);
    m_pInert-&gt;put_InitialOriginY(y);
    
    RECT screenRect;

    HWND desktop = GetDesktopWindow();
    GetClientRect(desktop, &amp;screenRect);

    // physics settings
    // deceleration is units per square millisecond
    m_pInert-&gt;put_DesiredDeceleration(.1f);

    // set the boundaries        
    screenRect.left-= 1024;
    m_pInert-&gt;put_BoundaryLeft  ( static_cast&lt;float&gt;(screenRect.left   * 100));
    m_pInert-&gt;put_BoundaryTop   ( static_cast&lt;float&gt;(screenRect.top    * 100));
    m_pInert-&gt;put_BoundaryRight ( static_cast&lt;float&gt;(screenRect.right  * 100));
    m_pInert-&gt;put_BoundaryBottom( static_cast&lt;float&gt;(screenRect.bottom * 100));
    
    
    // Elastic boundaries - I set these to 90% of the screen 
    // so... 5% at left, 95% right, 5% top,  95% bottom
    // Values are whole numbers because units are in centipixels
    m_pInert-&gt;put_ElasticMarginLeft  (static_cast&lt;float&gt;(screenRect.left   * 5));
    m_pInert-&gt;put_ElasticMarginTop   (static_cast&lt;float&gt;(screenRect.top    * 5));
    m_pInert-&gt;put_ElasticMarginRight (static_cast&lt;float&gt;(screenRect.right  * 95));
    m_pInert-&gt;put_ElasticMarginBottom(static_cast&lt;float&gt;(screenRect.bottom * 95));
    
    
    return S_OK;
}
</code></pre>
<p>In this example, manipulation deltas are used to move the window around. The following code shows how the delta event is handled.</p>
<pre lang="C++"><code>HRESULT STDMETHODCALLTYPE CManipulationEventSink::ManipulationDelta( 
    /* [in] */ FLOAT x,
    /* [in] */ FLOAT y,
    /* [in] */ FLOAT translationDeltaX,
    /* [in] */ FLOAT translationDeltaY,
    /* [in] */ FLOAT scaleDelta,
    /* [in] */ FLOAT expansionDelta,
    /* [in] */ FLOAT rotationDelta,
    /* [in] */ FLOAT cumulativeTranslationX,
    /* [in] */ FLOAT cumulativeTranslationY,
    /* [in] */ FLOAT cumulativeScale,
    /* [in] */ FLOAT cumulativeExpansion,
    /* [in] */ FLOAT cumulativeRotation)
{
    m_cDeltaEventCount ++;
        
    RECT rect;
            
    GetWindowRect(m_hWnd, &amp;rect);
        
    int oldWidth =  rect.right-rect.left;
    int oldHeight = rect.bottom-rect.top;            

    // scale and translate the window size / position    
    MoveWindow(m_hWnd,                                              // the window to move
        static_cast&lt;int&gt;(rect.left + (translationDeltaX / 100.0f)), // the x position
        static_cast&lt;int&gt;(rect.top + (translationDeltaY/100.0f)),    // the y position
        static_cast&lt;int&gt;(oldWidth * scaleDelta),                    // width
        static_cast&lt;int&gt;(oldHeight * scaleDelta),                   // height
        TRUE);                                                      // redraw
                     
    return S_OK;
}
</code></pre>
<p>In this example, manipulation completed events either start or stop a timer that will call <a href="/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process"><strong>Process</strong></a> on the <a href="/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor"><strong>IInertiaProcessor</strong></a> interface. The following code shows how the completed manipulation event is handled.</p>
<pre lang="C++"><code>HRESULT STDMETHODCALLTYPE CManipulationEventSink::ManipulationCompleted( 
    /* [in] */ FLOAT x,
    /* [in] */ FLOAT y,
    /* [in] */ FLOAT cumulativeTranslationX,
    /* [in] */ FLOAT cumulativeTranslationY,
    /* [in] */ FLOAT cumulativeScale,
    /* [in] */ FLOAT cumulativeExpansion,
    /* [in] */ FLOAT cumulativeRotation)
{
    m_cCompletedEventCount ++;

    m_fX = x;
    m_fY = y;

    // place your code handler here to do any operations based on the manipulation   
    
    if (fExtrapolating){
        //Inertia Complete, stop the timer used for processing      
        KillTimer(m_hWnd,0);        
    }else{ 
        // setup velocities for inertia processor
        float vX = 0.0f;
        float vY = 0.0f;
        float vA = 0.0f;
        m_pManip-&gt;GetVelocityX(&amp;vX);
        m_pManip-&gt;GetVelocityY(&amp;vY);
        m_pManip-&gt;GetAngularVelocity(&amp;vA);

        // complete any previous processing
        m_pInert-&gt;Complete();
        
        // Reset sets the  initial timestamp
        m_pInert-&gt;Reset();
                
        // 
        m_pInert-&gt;put_InitialVelocityX(vX);
        m_pInert-&gt;put_InitialVelocityY(vY);        
        
        m_pInert-&gt;put_InitialOriginX(x);
        m_pInert-&gt;put_InitialOriginY(y);
        
           
        // Start a timer
        SetTimer(m_hWnd,0, 50, 0);        
    }

    return S_OK;
}
</code></pre>
<p>The following code shows how you could interpret <strong>WM_TIMER</strong> messages in <strong>WndProc</strong> to perform calls to <a href="/windows/desktop/api/manipulations/nf-manipulations-iinertiaprocessor-process"><strong>Process</strong></a> on the <a href="/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor"><strong>IInertiaProcessor</strong></a> interface.</p>
<pre lang="C++"><code>case WM_TIMER:       
  if (g_pIInertProc){
    BOOL b;       
    g_pIInertProc-&gt;Process(&amp;b);        
  }
  break;
</code></pre>
<h3>CoInitialize the Inertia Processor and Manipulation Processor and Initialize the Event Sinks</h3>
<p>After you have your event sink modified to support both the <a href="/windows/desktop/api/manipulations/nn-manipulations-imanipulationprocessor"><strong>IManipulationProcessor</strong></a> and the <a href="/windows/desktop/api/manipulations/nn-manipulations-iinertiaprocessor"><strong>IInertiaProcessor</strong></a>, you are ready to initialize the event sinks and set them up to run from your application. The following code shows how the interface pointers are allocated.</p>
<pre lang="C++"><code>//Include windows.h for touch events
#include &quot;windows.h&quot;  

// Manipulation implementation file
#include &lt;manipulations_i.c&gt;
    
// Smart Pointer to a global reference of a manipulation processor, event sink
IManipulationProcessor* g_pIManipProc;
IInertiaProcessor*      g_pIInertProc;
</code></pre>
<p>The following code example shows how to instantiate your interfaces.</p>
<pre lang="C++"><code>   HRESULT hr = CoInitialize(0);
        
   hr = CoCreateInstance(CLSID_ManipulationProcessor,
       NULL,
       CLSCTX_INPROC_SERVER,
       IID_IUnknown,
       (VOID**)(&amp;g_pIManipProc)
   );
   
   hr = CoCreateInstance(CLSID_InertiaProcessor,
       NULL,
       CLSCTX_INPROC_SERVER,
       IID_IUnknown,
       (VOID**)(&amp;g_pIInertProc)
   );
</code></pre>
<p>The following code example shows how to construct your event sinks given the interface pointers and register the window for touch input.</p>
<pre lang="C++"><code>   g_pManipulationEventSink = new CManipulationEventSink(g_pIManipProc, g_pIInertProc, hWnd);
   g_pManipulationEventSink = new CManipulationEventSink(g_pIInertProc, hWnd);


   RegisterTouchWindow(hWnd, 0);  
</code></pre>
<h2>Related topics</h2>
<!-- raw HTML omitted -->
<p><a href="getting-started-with-inertia.html">Inertia</a></p>
<!-- raw HTML omitted -->
<p>Â </p>
<p>Â </p>
</body>
