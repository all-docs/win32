<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Direct3D 9 to Direct3D 10 Considerations (Direct3D 10)</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<h2>description: The following page provides a basic outline of key differences between Direct3D 9 and Direct3D 10. The outline below provides some insight to assist developers with Direct3D 9 experience to explore and relate to Direct3D 10.
ms.assetid: 283b54e0-94cb-47a8-8cfc-5798e0538b9f
title: Direct3D 9 to Direct3D 10 Considerations (Direct3D 10)
ms.topic: article
ms.date: 05/31/2018</h2>
<h1>Direct3D 9 to Direct3D 10 Considerations (Direct3D 10)</h1>
<p>The following page provides a basic outline of key differences between Direct3D 9 and Direct3D 10. The outline below provides some insight to assist developers with Direct3D 9 experience to explore and relate to Direct3D 10.</p>
<p>Although the info in this topic compares Direct3D 9 with Direct3D 10, because Direct3D 11 builds on the improvements made in Direct3D 10 and 10.1, you also need this info to migrate from Direct3D 9 to Direct3D 11. For info about moving beyond Direct3D 10 to Direct3D 11, see <a href="../direct3d11/d3d11-programming-guide-migrating.html">Migrating to Direct3D 11</a>.</p>
<ul>
<li><a href="#overview-of-the-major-structural-changes-in-direct3d-10">Overview of the Major Structural Changes in Direct3D 10</a>
<ul>
<li><a href="#removal-of-fixed-function">Removal of Fixed Function</a></li>
<li><a href="#device-object-creation-time-validation">Device Object Creation Time Validation</a></li>
</ul>
</li>
<li><a href="/windows">Engine Abstractions / Separation</a>
<ul>
<li><a href="#direct-removal-of-direct3d-9-dependencies">Direct Removal of Direct3D 9 Dependencies</a></li>
</ul>
</li>
<li><a href="#tricks-for-quickly-resolving-application-build-issues">Tricks for Quickly Resolving Application Build Issues</a>
<ul>
<li><a href="#overriding-direct3d-9-types">Overriding Direct3D 9 Types</a></li>
<li><a href="#resolving-link-issues">Resolving Link Issues</a></li>
<li><a href="#simulating-device-caps">Simulating Device CAPs</a></li>
</ul>
</li>
<li><a href="#driving-the-direct3d-10-api">Driving the Direct3D 10 API</a>
<ul>
<li><a href="#resource-creation">Resource Creation</a></li>
<li><a href="#views">Views</a></li>
<li><a href="#static-versus-dynamic-resource-access">Static versus Dynamic Resource Access</a></li>
<li><a href="#direct3d-10-effects">Direct3D 10 Effects</a></li>
<li><a href="#hlsl-without-effects">HLSL without Effects</a></li>
<li><a href="#shader-compilation">Shader Compilation</a></li>
<li><a href="#creation-of-shader-resources">Creation of Shader Resources</a></li>
<li><a href="#shader-reflection-layer-interface">Shader Reflection Layer Interface</a></li>
<li><a href="/windows">Input Assembler Layouts - Vertex Shader / Input Stream Linkage</a></li>
<li><a href="#impact-of-shader-dead-code-removal">Impact of Shader Dead Code Removal</a></li>
<li><a href="#vertex-shader-input-structure-example">Vertex Shader Input Structure Example</a></li>
<li><a href="#state-object-creation">State Object Creation</a></li>
</ul>
</li>
<li><a href="#porting-textures">Porting Textures</a>
<ul>
<li><a href="#file-formats-supported">File Formats Supported</a></li>
<li><a href="#mapping-texture-formats">Mapping Texture Formats</a></li>
</ul>
</li>
<li><a href="#porting-shaders">Porting Shaders</a>
<ul>
<li><a href="#direct3d-10-shaders-are-authored-in-hlsl">Direct3D 10 Shaders are Authored in HLSL</a></li>
<li><a href="#shader-signatures-and-linkage">Shader Signatures and Linkage</a></li>
<li><a href="#hlsl-shader-stage-linkages">HLSL Shader Stage linkages</a></li>
<li><a href="#constant-buffers">Constant Buffers</a></li>
<li><a href="#user-clip-planes-in-hlsl-on-feature-level-9-and-higher">User clip planes in HLSL on feature level 9 and higher</a></li>
</ul>
</li>
<li><a href="#additional-direct3d-10-differences-to-watch-for">Additional Direct3D 10 Differences to Watch For</a>
<ul>
<li><a href="#integers-as-input">Integers as Input</a></li>
<li><a href="#mouse-cursors">Mouse Cursors</a></li>
<li><a href="#mapping-texels-to-pixels-in-direct3d-10">Mapping Texels to Pixels in Direct3D 10</a></li>
<li><a href="#reference-counting-behavior-changes">Reference Counting Behavior Changes</a></li>
<li><a href="#test-cooperative-level">Test Cooperative Level</a></li>
<li><a href="#stretchrect">StretchRect</a></li>
</ul>
</li>
<li><a href="#additional-direct3d-101-differences">Additional Direct3D 10.1 Differences</a></li>
<li><a href="#related-topics">Related topics</a></li>
</ul>
<h2>Overview of the Major Structural Changes in Direct3D 10</h2>
<ul>
<li><a href="#removal-of-fixed-function">Removal of Fixed Function</a></li>
<li><a href="#device-object-creation-time-validation">Device Object Creation Time Validation</a></li>
</ul>
<p>The process of rendering using the Direct3D 10 device is structurally similar to Direct3D 9.</p>
<ul>
<li>Set a vertex stream source</li>
<li>Set input layout in Direct3D 10 (set vertex stream declaration in Direct3D 9)</li>
<li>Declare primitive topology</li>
<li>Set textures</li>
<li>Set state objects</li>
<li>Set shaders</li>
<li>Draw</li>
</ul>
<p>The <a href="/windows/desktop/api/D3D10/nf-d3d10-id3d10device-draw"><strong>Draw</strong></a> call ties the operations together; the ordering of calls prior to the Draw call is arbitrary. The major differences in the Direct3D 10 API design are as follows:</p>
<ul>
<li>Removal of Fixed Function</li>
<li>Removal of CAPS bits - Direct3D 10's base feature set is guaranteed</li>
<li>Stricter management of: resource access, device state, shader constants, shader linkage (inputs and outputs to shaders) between stages</li>
<li>API entry point name changes reflect the use of virtual GPU memory (Map() instead of Lock()).</li>
<li>A debug layer can be added to the device at creation time</li>
<li>The primitive topology is now an explicit state (separated from the <a href="/windows/desktop/api/D3D10/nf-d3d10-id3d10device-draw"><strong>Draw</strong></a> call)</li>
<li>Explicit shader constants are now stored in constant buffers</li>
<li>Shader authoring is done entirely in HLSL. The HLSL compiler now resides in the primary Direct3D 10 DLL.</li>
<li>New programmable stage - the geometry shader</li>
<li>Removal of BeginScene()/EndScene()</li>
<li>Common 2D, focus and adapter-management functionality implemented in a new component: DXGI</li>
</ul>
<h3>Removal of Fixed Function</h3>
<p>It is sometimes surprising that even in a Direct3D 9 engine that fully exploits the programmable pipeline, there remains a number of areas that depend on the fixed-function (FF) pipeline. The most common areas are usually related to screen-space aligned rendering for UI. It is for this reason that you are likely to need to build a FF emulation shader or set of shaders which provide the necessary replacement behaviors.</p>
<p>This documentation contains a white paper containing replacement shader sources for the most common FF behaviors (see <a href="https://msdn.microsoft.com/library/Ee416406(v=VS.85).aspx">Fixed Function EMU Sample</a>). Some fixed-function pixel behavior including alpha test has been moved into shaders.</p>
<h3>Device Object Creation Time Validation</h3>
<p>The Direct3D 10 pipeline has been redesigned from the ground up in hardware and software with a primary intention to reduce CPU overhead (at Draw time). To reduce costs, all types of device data have been assigned an object with explicit creation methods provided by the device itself. This enables strict data validation at object creation time instead of during the Draw call as it often does with Direct3D 9.</p>
<h2>Engine Abstractions / Separation</h2>
<p>Applications, including Games, that wish to support both Direct3D 9 and Direct3D 10 need to have the rendering layers abstracted from the rest of the code base. There are many ways to achieve this but key to all of them is the design of the abstraction layer for the lower-level Direct3D device. All systems should communicate to the hardware through the common layer which is designed to provide GPU resource and low-level type management.</p>
<h3>Direct Removal of Direct3D 9 Dependencies</h3>
<p>When porting large, previously tested code bases, it is important to minimize the amount of code changes to those which are absolutely necessary to preserve previously tested behaviors in the code. Best practices include clearly documenting where items change using comments. It's often useful to have a commenting standard for this work which enables quick navigation through the code base.</p>
<p>The following is an example list of standard single line / start block comments which could be used for this work.</p>
<table>
<thead>
<tr>
<th>Item</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->// Direct3D 10 REMOVED<!-- raw HTML omitted --></td>
<td>Use this where lines / blocks of code are removed<!-- raw HTML omitted --></td>
</tr>
<tr>
<td><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->// Direct3D 10 NEEDS UPDATE<!-- raw HTML omitted --></td>
<td>It helps to added additional notes to the NEED UPDATE comment that suggests what work / new API should be used for later visits to the code for behavior conversion. Heavy use of assert(<strong>false</strong>) should also be used where \\ Direct3D 10 NEEDS UPDATE occurs to ensure you do not unknowingly run errant code<!-- raw HTML omitted --></td>
</tr>
<tr>
<td><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->// Direct3D 10 CHANGED<!-- raw HTML omitted --></td>
<td>Areas where major changes have occurred should be kept for future reference but commented out<!-- raw HTML omitted --></td>
</tr>
<tr>
<td><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted -->// Direct3D 10 END<!-- raw HTML omitted --></td>
<td>End code block qualifier<!-- raw HTML omitted --></td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>For multiple lines of source you should use the C style /* */ comments too but add the relevant start / end comments around these areas.</p>
<h2>Tricks for Quickly Resolving Application Build Issues</h2>
<ul>
<li><a href="#overriding-direct3d-9-types">Overriding Direct3D 9 Types</a></li>
<li><a href="#resolving-link-issues">Resolving Link Issues</a></li>
<li><a href="#simulating-device-caps">Simulating Device CAPs</a></li>
</ul>
<h3>Overriding Direct3D 9 Types</h3>
<p>It may be useful to insert a high level header file containing type definitions / overrides for Direct3D 9 base types which are no longer supported by the Direct3D 10 headers. This will help you minimize the amount of changes in the code and interfaces where there is a direct mapping from a Direct3D 9 type to the newly defined Direct3D 10 type. This approach is also useful for keeping code behaviors together in one source file. In this case, it is a good idea to define version neutral / generally named types which describe common constructs used for rendering yet span both Direct3D 9 and Direct3D 10 APIs. For example:</p>
<pre><code>#if defined(D3D9)
typedef IDirect3DIndexBuffer9   IDirect3DIndexBuffer;
typedef IDirect3DVertexBuffer9  IDirect3DVertexBuffer;
#else //D3D10
typedef ID3D10Buffer            IDirect3DIndexBuffer;
typedef ID3D10Buffer            IDirect3DVertexBuffer
#endif
</code></pre>
<p>Other Direct3D 10 specific examples of this include:</p>
<pre><code>typedef ID3D10TextureCube   IDirect3DCubeTexture;
typedef ID3D10Texture3D     IDirect3DVolumeTexture;
typedef D3D10_VIEWPORT      D3DVIEWPORT;
typedef ID3D10VertexShader  IDirect3DVertexShader;
typedef ID3D10PixelShader   IDirect3DPixelShader;
</code></pre>
<h3>Resolving Link Issues</h3>
<p>It is advisable to develop Direct3D 10 and Windows Vista applications using the latest version of Microsoft Visual Studio. However, it is possible to build a Windows Vista application which depends on Direct3D 10 using the earlier 2003 version of Visual Studio. Direct3D 10 is a Windows Vista platform component which has dependencies (as with the Server 2003 SP1 platform SDK) on the following lib: BufferOverflowU.lib is needed to solve any buffer_security check linker issues.</p>
<h3>Simulating Device CAPs</h3>
<p>Many applications contain areas of code which depend on device CAPS data being available. Work around this by overriding device enumeration and forcing device CAPS to sensible values. Plan to re-visit areas where there are dependencies on CAPS later for full removal of CAPS where possible.</p>
<h2>Driving the Direct3D 10 API</h2>
<p>This section focuses on the behavior changes caused by the Direct3D 10 API.</p>
<ul>
<li><a href="#resource-creation">Resource Creation</a></li>
<li><a href="#views">Views</a></li>
<li><a href="#static-versus-dynamic-resource-access">Static versus Dynamic Resource Access</a></li>
<li><a href="#direct3d-10-effects">Direct3D 10 Effects</a></li>
<li><a href="#hlsl-without-effects">HLSL without Effects</a></li>
<li><a href="#shader-compilation">Shader Compilation</a></li>
<li><a href="#creation-of-shader-resources">Creation of Shader Resources</a></li>
<li><a href="#shader-reflection-layer-interface">Shader Reflection Layer Interface</a></li>
<li><a href="/windows">Input Assembler Layouts - Vertex Shader / Input Stream Linkage</a></li>
<li><a href="#impact-of-shader-dead-code-removal">Impact of Shader Dead Code Removal</a></li>
<li><a href="#vertex-shader-input-structure-example">Vertex Shader Input Structure Example</a></li>
<li><a href="#state-object-creation">State Object Creation</a></li>
</ul>
<h3>Resource Creation</h3>
<p>The Direct3D 10 API has designed resources as generic buffer types which have specific bind flags according to the planned usage. This design point was chosen to facilitate near ubiquitous access of resources in the Pipeline for scenarios such as rendering to a vertex buffer then instantly drawing the results without interrupting the CPU. The following example demonstrates allocation of vertex buffers and index buffer where you can see that the resource description only differs by the GPU resource bind flags.</p>
<p>The Direct3D 10 API has provided texture helper methods for explicitly creating texture type resources but as you can imagine, these are really helper functions.</p>
<ul>
<li>CreateTexture2D()</li>
<li>CreateTextureCube()</li>
<li>CreateTexture3D()</li>
</ul>
<p>When targeting Direct3D 10, you are likely to want to allocate more items during resource creation time than you are used to with Direct3D 9. This will become most apparent with the creation of Render Target buffers and Textures where you need to also create a view for accessing the buffer and setting the resource on the device.</p>
<p><a href="https://msdn.microsoft.com/library/Ee416436(v=VS.85).aspx">Tutorial 1: Direct3D 10 Basics</a></p>
<blockquote>
<p>[!Note]<br />
Direct3D 10 and later versions of Direct3D extend the DDS file format to support new DXGI formats, texture arrays, and cube-map arrays. For more information about the DDS file format extension, see the <a href="../direct3ddds/dx-graphics-dds-pguide.html">Programming Guide for DDS</a>.</p>
</blockquote>
<p>Â </p>
<h3>Views</h3>
<p>A view is a specifically typed, interface to data stored in a pixel buffer. A resource can have several views allocated on it at once and this feature is highlighted in the Single Pass Render to Cubemap sample contained in this SDK.</p>
<p><a href="d3d10-graphics-programming-guide-resources-access-views.html">Programmers Guide page on Resource Access</a></p>
<p><a href="https://msdn.microsoft.com/library/Ee416398(v=VS.85).aspx">CubeMap Sample</a></p>
<h3>Static versus Dynamic Resource Access</h3>
<p>For best performance, applications should partition their data use in terms of the static vs dynamic nature of the data. Direct3D 10 has been designed to take advantage of this approach and as such, the access rules for resources have been significantly tightened up over Direct3D 9. For static resources you should ideally populate the resource with its data during creation time. If your engine has been designed around the Create, Lock, Fill, Unlock design point of Direct3D 9, you may defer population from Create time by using a staging resource and the UpdateSubResource method on the resource interface.</p>
<h3>Direct3D 10 Effects</h3>
<p>Use of the Direct3D 10 Effects system is outside the scope of this article. The system has been written to take full advantage of the architectural benefits that Direct3D 10 provides. See the <a href="d3d10-graphics-programming-guide-effects.html">Effects (Direct3D 10)</a> section for more detail on its use.</p>
<h3>HLSL without Effects</h3>
<p>The Direct3D 10 Shader pipeline may be driven without the use of the Direct3D 10 Effects system. Note that in this instance, all constant buffer, shader, sampler and texture binding must be managed by the application itself. See the sample link and following sections of this document for more detail:</p>
<p><a href="https://msdn.microsoft.com/library/Ee416414(v=VS.85).aspx">HLSL without Effects sample</a></p>
<h3>Shader Compilation</h3>
<p>The Direct3D 10 HLSL compiler brings enhancements to the HLSL language definition and therefore has the ability to operate in 2 modes. For complete support of Direct3D 9 style intrinsic functions and semantics, compilation should be invoked using the COMPATIBILITY MODE flag which can be specified on a per compile basis.</p>
<p>The shader model 4.0 specific HLSL language semantics and intrinsic functions for Direct3D 10 can be found at <a href="../direct3dhlsl/dx-graphics-hlsl.html">HLSL</a>. Major changes in syntax from Direct3D 9 HLSL to take the most notice of are in the area of texture access. The new syntax is the only form supported by the compiler outside of compatibility mode.</p>
<blockquote>
<p>[!Note]<br />
The Direct3D 10 compiler-type APIs (<a href="/windows/desktop/api/D3D10Shader/nf-d3d10shader-d3d10compileshader"><strong>D3D10CompileShader</strong></a> and <a href="/windows/desktop/api/D3D10Effect/nf-d3d10effect-d3d10compileeffectfrommemory"><strong>D3D10CompileEffectFromMemory</strong></a>) are supplied by the Direct3D 10, 10.1, and 11 runtimes that run in WindowsÂ Vista and later. The Direct3D 10 compiler-type APIs have the same functionality as the HLSL compiler that is shipped in the DirectX SDK (December 2006). This HLSL compiler does not support the Direct3D 10.1 profiles (vs_4_1, ps_4_1, gs_4_1, fx_4_1), and is missing a number of optimizations and improvements. You can get an HLSL compiler that supports the Direct3D 10.1 profiles from the latest legacy <a href="/previous-versions/windows/apps/hh452744(v=win.10)">DirectX SDK release</a>. For info about the legacy DirectX SDK, see <a href="../directx-sdk--august-2009-.html">Where is the DirectX SDK?</a>. You can get the latest HLSL Fxc.exe command-line compiler and <a href="../direct3dhlsl/dx-graphics-d3dcompiler-reference.html">D3DCompiler</a> APIs from the Windows SDK.</p>
</blockquote>
<p>Â </p>
<h3>Creation of Shader Resources</h3>
<p>The creation of compiled shader instances outside of the Direct3D 10 Effects system is done in a very similar manner to Direct3D 9 however, in Direct3D 10, it is important to keep the Shader Input signature around for later use. The signature is returned by default as part of the shader blob but may be extracted to reduce the memory requirements if needed. For more details, see <a href="../direct3dhlsl/dx-graphics-hlsl-using-shaders-10.html">Using Shaders in Direct3D 10</a>.</p>
<h3>Shader Reflection Layer Interface</h3>
<p>The shader reflection layer is the interface by which information about the shader requirements may be obtained. This is particularly useful when creating Input Assembly linkages (see below) where you may need to traverse the shader input requirements to ensure you are supplying the correct input structure to the shader. You can create an instance of the reflection layer interface at the same time as creating an instance of a compiled shader.</p>
<p>The shader reflection layer replaces D3DX9 methods that provide similar functionality. For example <a href="../direct3d9/id3dxeffect--isparameterused.html"><strong>IsParameterUsed</strong></a> is replaced by the <a href="/windows/desktop/api/D3D10Shader/nf-d3d10shader-id3d10shaderreflectionvariable-getdesc"><strong>GetDesc</strong></a> method.</p>
<h3>Input Assembler Layouts - Vertex Shader / Input Stream Linkage</h3>
<p>The Input Assembler (IA) replaces the Direct3D 9 style Vertex Stream Declaration and it's description structure is very similar in form. The main difference that the IA brings is that the IA layout object created must directly map to a specific format of shader input signature. The mapping object created to link the input stream to shader may be used across any number of shaders where the shader input signature matches that of the shader used to create the Input Layout.</p>
<p>To best drive the pipeline with static data, you should consider the permutations of input stream format to possible shader input signatures and create the IA layout object instances as early as is possible and reuse them where possible.</p>
<h3>Impact of Shader Dead Code Removal</h3>
<p>The following section details a significant difference between Direct3D 9 and Direct3D 10 that is likely to require careful handling in your engine code. Shaders which contain conditional expressions often have certain code paths removed as part of the compilation process. In Direct3D 9, two kinds of inputs may be removed (marked for removal) when unused: signature inputs (like the example below) and constant inputs. If the end of the constant buffer contains unused entries, the size declaration in the shader will reflect the size of the constant buffer without the unused entries at the end. Both of these kinds of inputs remain in signatures or constant buffers Direct3D 10 with a special exception in the case of unused constant inputs at the end of a constant buffer. This may have an impact on the engine when handling large shaders and creating input layouts. Elements which are removed by dead code optimizations in the compiler must still be declared in the input structure. The following example demonstrates this:</p>
<h3>Vertex Shader Input Structure Example</h3>
<pre><code>struct VS_INPUT
{
float4 pos: SV_Position;
float2 uv1 : Texcoord1;
float2 uv2 : Texcoord2; *
};
</code></pre>
<p>* Direct3D 9 dead code removal would remove the declaration in the shader due to conditional dead code removal</p>
<pre><code>float4x4  g_WorldViewProjMtx;
static const bool g_bLightMapped = false; // define a compile time constant

VS_INPUT main(VS_INPUT i) 
{
    VS_INPUT o;
    o.pos = mul( i.pos, g_WorldViewProjMtx);
    o.uv1 = i.uv1;
    if ( g_bLightMapped )
    {
        o.uv2 = i.uv2;
    }
    return o;
}
</code></pre>
<p>Or, you could make it even more obvious that the constant is a compile time constant with the following declaration:</p>
<pre><code>#define LIGHT_MAPPED false
</code></pre>
<p>In the above example, under Direct3D 9, the uv2 element would be removed due to dead code optimizations in the compiler. Under Direct3D 10, the dead code will still be removed but the shader input assembler layout requires the definition of the input data to exist. The shader reflection layer provides the means to handle this situation in a generic manner whereby you can traverse the shader input requirements and ensure that you provide a full description of the Input Stream to shader signature mapping.</p>
<p>Here's an example function to detect the existence of a semantic name/index in a function signature:</p>
<pre><code>// Returns true if the SemanticName / SemanticIndex is used in the input signature.
// pReflector is a previously acquired shader reflection interface.
bool IsSignatureElementExpected(ID3D10ShaderReflection *pReflector, const LPCSTR SemanticName, UINT SemanticIndex)
{
    D3D10_SHADER_DESC               shaderDesc;
    D3D10_SIGNATURE_PARAMETER_DESC  paramDesc;

    Assert(pReflector);
    Assert(SemanticName);

    pReflector-&gt;GetDesc(&amp;shaderDesc);

    for (UINT k=0; k&lt;shaderDesc.InputParameters; k++)
    {
        pReflector-&gt;GetInputParameterDesc( k, &amp;paramDesc);
        if (wcscmp( SemanticName, paramDesc.SemanticName)==0 &amp;&amp; paramDesc.SemanticIndex == SemanticIndex) 
            return true;
    }

    return false;
}
</code></pre>
<h3>State Object Creation</h3>
<p>When porting engine code, it may help to initially use a default set of state objects and disable all Direct3D 9 device render state / texture state setting. This will cause rendering artifacts but is the quickest way to get things up and running. You can later construct a state object management system which can use a compound key to enable maximum reuse of the number of state objects being used.</p>
<h2>Porting Textures</h2>
<h3>File Formats Supported</h3>
<p>The <strong>D3DXxxCreateXXX</strong> and <strong>D3DXxxSaveXXX</strong> functions that create or save a texture from or to a graphics file (for example, <a href="d3dx10createtexturefromfile.html"><strong>D3DX10CreateTextureFromFile</strong></a>) support a different set of file formats in Direct3D 10 than they did in Direct3D 9:</p>
<table>
<thead>
<tr>
<th>File Format</th>
<th>Direct3D 9</th>
<th>Direct3D 10</th>
</tr>
</thead>
<tbody>
<tr>
<td>.bmp</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>.jpg</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>.tga</td>
<td>yes</td>
<td></td>
</tr>
<tr>
<td>.png</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>.dds</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>.ppm</td>
<td>yes</td>
<td></td>
</tr>
<tr>
<td>.dib</td>
<td>yes</td>
<td></td>
</tr>
<tr>
<td>.hdr</td>
<td>yes</td>
<td></td>
</tr>
<tr>
<td>.pfm</td>
<td>yes</td>
<td></td>
</tr>
<tr>
<td>.tiff</td>
<td></td>
<td>yes</td>
</tr>
<tr>
<td>.gif</td>
<td></td>
<td>yes</td>
</tr>
<tr>
<td>.tif</td>
<td></td>
<td>yes</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>For details, compare the Direct3D 9 <a href="../direct3d9/d3dximage-fileformat.html"><strong>D3DXIMAGE_FILEFORMAT</strong></a> enumerations with the <a href="d3dx10-image-file-format.html"><strong>D3DX10_IMAGE_FILE_FORMAT</strong></a> enumerations for Direct3D 10.</p>
<blockquote>
<p>[!Note]<br />
The D3DX (D3DX 9, D3DX 10, and D3DX 11) utility library is deprecated for WindowsÂ 8. For texture file processing, we recommend that you use <a href="https://github.com/Microsoft/DirectXTex">DirectXTex</a>.</p>
</blockquote>
<p>Â </p>
<h3>Mapping Texture Formats</h3>
<p>The following table shows the mapping of texture formats from Direct3D 9 to Direct3D 10. Any content in formats not available in DXGI will need to be converted by utility routines.</p>
<table>
<thead>
<tr>
<th>Direct3D 9 Format</th>
<th>Direct3D 10 Format</th>
</tr>
</thead>
<tbody>
<tr>
<td>D3DFMT_UNKNOWN</td>
<td>DXGI_FORMAT_UNKNOWN</td>
</tr>
<tr>
<td>D3DFMT_R8G8B8</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_A8R8G8B8</td>
<td>DXGI_FORMAT_B8G8R8A8_UNORM &amp; DXGI_FORMAT_B8G8R8A8_UNORM_SRGBÂ¹</td>
</tr>
<tr>
<td>D3DFMT_X8R8G8B8</td>
<td>DXGI_FORMAT_B8G8R8X8_UNORM &amp; DXGI_FORMAT_B8G8R8X8_UNORM_SRGBÂ¹</td>
</tr>
<tr>
<td>D3DFMT_R5G6B5</td>
<td>DXGI_FORMAT_B5G6R5_UNORMÂ²</td>
</tr>
<tr>
<td>D3DFMT_X1R5G5B5</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_A1R5G5B5</td>
<td>DXGI_FORMAT_B5G5R5A1_UNORMÂ²</td>
</tr>
<tr>
<td>D3DFMT_A4R4G4B4</td>
<td>DXGI_FORMAT_B4G4R4A4_UNORMÂ³</td>
</tr>
<tr>
<td>D3DFMT_R3G3B2</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_A8</td>
<td>DXGI_FORMAT_A8_UNORM</td>
</tr>
<tr>
<td>D3DFMT_A8R3G3B2</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_X4R4G4B4</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_A2B10G10R10</td>
<td>DXGI_FORMAT_R10G10B10A2</td>
</tr>
<tr>
<td>D3DFMT_A8B8G8R8</td>
<td>DXGI_FORMAT_R8G8B8A8_UNORM &amp; DXGI_FORMAT_R8G8B8A8_UNORM_SRGB</td>
</tr>
<tr>
<td>D3DFMT_X8B8G8R8</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_G16R16</td>
<td>DXGI_FORMAT_R16G16_UNORM</td>
</tr>
<tr>
<td>D3DFMT_A2R10G10B10</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_A16B16G16R16</td>
<td>DXGI_FORMAT_R16G16B16A16_UNORM</td>
</tr>
<tr>
<td>D3DFMT_A8P8</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_P8</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_L8</td>
<td>DXGI_FORMAT_R8_UNORM Note: Use .r swizzle in shader to duplicate red to other components to get D3D9 behavior.</td>
</tr>
<tr>
<td>D3DFMT_A8L8</td>
<td>DXGI_FORMAT_R8G8_UNORM Note: Use swizzle .rrrg in shader to duplicate red and move green to the alpha components to get D3D9 behavior.</td>
</tr>
<tr>
<td>D3DFMT_A4L4</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_V8U8</td>
<td>DXGI_FORMAT_R8G8_SNORM</td>
</tr>
<tr>
<td>D3DFMT_L6V5U5</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_X8L8V8U8</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_Q8W8V8U8</td>
<td>DXGI_FORMAT_R8G8B8A8_SNORM</td>
</tr>
<tr>
<td>D3DFMT_V16U16</td>
<td>DXGI_FORMAT_R16G16_SNORM</td>
</tr>
<tr>
<td>D3DFMT_W11V11U10</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_A2W10V10U10</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_UYVY</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_R8G8_B8G8</td>
<td>DXGI_FORMAT_G8R8_G8B8_UNORM (in DX9 the data was scaled up by 255.0f, but this can be handled in shader code).</td>
</tr>
<tr>
<td>D3DFMT_YUY2</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_G8R8_G8B8</td>
<td>DXGI_FORMAT_R8G8_B8G8_UNORM (in DX9 the data was scaled up by 255.0f, but this can be handled in shader code).</td>
</tr>
<tr>
<td>D3DFMT_DXT1</td>
<td>DXGI_FORMAT_BC1_UNORM &amp; DXGI_FORMAT_BC1_UNORM_SRGB</td>
</tr>
<tr>
<td>D3DFMT_DXT2</td>
<td>DXGI_FORMAT_BC1_UNORM &amp; DXGI_FORMAT_BC1_UNORM_SRGB Note: DXT1 and DXT2 are the same from an API/hardware perspective... only difference was 'premultiplied alpha', which can be tracked by an application and doesn't need a separate format.</td>
</tr>
<tr>
<td>D3DFMT_DXT3</td>
<td>DXGI_FORMAT_BC2_UNORM &amp; DXGI_FORMAT_BC2_UNORM_SRGB</td>
</tr>
<tr>
<td>D3DFMT_DXT4</td>
<td>DXGI_FORMAT_BC2_UNORM &amp; DXGI_FORMAT_BC2_UNORM_SRGB Note: DXT3 and DXT4 are the same from an API/hardware perspective... only difference was 'premultiplied alpha', which can be tracked by an application and doesn't need a separate format.</td>
</tr>
<tr>
<td>D3DFMT_DXT5</td>
<td>DXGI_FORMAT_BC3_UNORM &amp; DXGI_FORMAT_BC3_UNORM_SRGB</td>
</tr>
<tr>
<td>D3DFMT_D16 &amp; D3DFMT_D16_LOCKABLE</td>
<td>DXGI_FORMAT_D16_UNORM</td>
</tr>
<tr>
<td>D3DFMT_D32</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_D15S1</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_D24S8</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_D24X8</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_D24X4S4</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_D16</td>
<td>DXGI_FORMAT_D16_UNORM</td>
</tr>
<tr>
<td>D3DFMT_D32F_LOCKABLE</td>
<td>DXGI_FORMAT_D32_FLOAT</td>
</tr>
<tr>
<td>D3DFMT_D24FS8</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_S1D15</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_S8D24</td>
<td>DXGI_FORMAT_D24_UNORM_S8_UINT</td>
</tr>
<tr>
<td>D3DFMT_X8D24</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_X4S4D24</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_L16</td>
<td>DXGI_FORMAT_R16_UNORM Note: Use .r swizzle in shader to duplicate red to other components to get D3D9 behavior.</td>
</tr>
<tr>
<td>D3DFMT_INDEX16</td>
<td>DXGI_FORMAT_R16_UINT</td>
</tr>
<tr>
<td>D3DFMT_INDEX32</td>
<td>DXGI_FORMAT_R32_UINT</td>
</tr>
<tr>
<td>D3DFMT_Q16W16V16U16</td>
<td>DXGI_FORMAT_R16G16B16A16_SNORM</td>
</tr>
<tr>
<td>D3DFMT_MULTI2_ARGB8</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DFMT_R16F</td>
<td>DXGI_FORMAT_R16_FLOAT</td>
</tr>
<tr>
<td>D3DFMT_G16R16F</td>
<td>DXGI_FORMAT_R16G16_FLOAT</td>
</tr>
<tr>
<td>D3DFMT_A16B16G16R16F</td>
<td>DXGI_FORMAT_R16G16B16A16_FLOAT</td>
</tr>
<tr>
<td>D3DFMT_R32F</td>
<td>DXGI_FORMAT_R32_FLOAT</td>
</tr>
<tr>
<td>D3DFMT_G32R32F</td>
<td>DXGI_FORMAT_R32G32_FLOAT</td>
</tr>
<tr>
<td>D3DFMT_A32B32G32R32F</td>
<td>DXGI_FORMAT_R32G32B32A32_FLOAT</td>
</tr>
<tr>
<td>D3DFMT_CxV8U8</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DDECLTYPE_FLOAT1</td>
<td>DXGI_FORMAT_R32_FLOAT</td>
</tr>
<tr>
<td>D3DDECLTYPE_FLOAT2</td>
<td>DXGI_FORMAT_R32G32_FLOAT</td>
</tr>
<tr>
<td>D3DDECLTYPE_FLOAT3</td>
<td>DXGI_FORMAT_R32G32B32_FLOAT</td>
</tr>
<tr>
<td>D3DDECLTYPE_FLOAT4</td>
<td>DXGI_FORMAT_R32G32B32A32_FLOAT</td>
</tr>
<tr>
<td>D3DDECLTYPED3DCOLOR</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DDECLTYPE_UBYTE4</td>
<td>DXGI_FORMAT_R8G8B8A8_UINT Note: Shader gets UINT values, but if Direct3D 9 style integral floats are needed (0.0f, 1.0f... 255.f), UINT can just be converted to float32 in shader.</td>
</tr>
<tr>
<td>D3DDECLTYPE_SHORT2</td>
<td>DXGI_FORMAT_R16G16_SINT Note: Shader gets SINT values, but if Direct3D 9 style integral floats are needed, SINT can just be converted to float32 in shader.</td>
</tr>
<tr>
<td>D3DDECLTYPE_SHORT4</td>
<td>DXGI_FORMAT_R16G16B16A16_SINT Note: Shader gets SINT values, but if Direct3D 9 style integral floats are needed, SINT can just be converted to float32 in shader.</td>
</tr>
<tr>
<td>D3DDECLTYPE_UBYTE4N</td>
<td>DXGI_FORMAT_R8G8B8A8_UNORM</td>
</tr>
<tr>
<td>D3DDECLTYPE_SHORT2N</td>
<td>DXGI_FORMAT_R16G16_SNORM</td>
</tr>
<tr>
<td>D3DDECLTYPE_SHORT4N</td>
<td>DXGI_FORMAT_R16G16B16A16_SNORM</td>
</tr>
<tr>
<td>D3DDECLTYPE_USHORT2N</td>
<td>DXGI_FORMAT_R16G16_UNORM</td>
</tr>
<tr>
<td>D3DDECLTYPE_USHORT4N</td>
<td>DXGI_FORMAT_R16G16B16A16_UNORM</td>
</tr>
<tr>
<td>D3DDECLTYPE_UDEC3</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DDECLTYPE_DEC3N</td>
<td>Not available</td>
</tr>
<tr>
<td>D3DDECLTYPE_FLOAT16_2</td>
<td>DXGI_FORMAT_R16G16_FLOAT</td>
</tr>
<tr>
<td>D3DDECLTYPE_FLOAT16_4</td>
<td>DXGI_FORMAT_R16G16B16A16_FLOAT</td>
</tr>
<tr>
<td>FourCC 'ATI1'</td>
<td>DXGI_FORMAT_BC4_UNORM</td>
</tr>
<tr>
<td>FourCC 'ATI2'</td>
<td>DXGI_FORMAT_BC5_UNORM</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>Â¹DXGI 1.1, which is included in the Direct3D 11 runtime, includes BGRA formats. However, support for these formats is optional for Direct3D 10 and 10.1 devices with drivers that are implemented to the Windows Display Driver Model (WDDM) for WindowsÂ Vista (WDDM 1.0). Consider using DXGI_FORMAT_R8G8B8A8_UNORM instead. Alternatively, you can create your device with <a href="/windows/desktop/api/D3D10/ne-d3d10-d3d10_create_device_flag"><strong>D3D10_CREATE_DEVICE_BGRA_SUPPORT</strong></a> to ensure that you only support computers with the Direct3D 11.0 runtime and a WDDM 1.1 driver or higher installed.</p>
<p>Â²DXGI 1.0 defined 5:6:5 and 5:5:5:1 formats, but they were not supported by the Direct3D 10.x or Direct3D 11.0 runtime. These formats are optionally supported with DXGI 1.2 in the DirectX 11.1 runtime, which is required for feature level 11.1 video adapters and WDDM 1.2 (display driver model starting with WindowsÂ 8) drivers and already supported on 10level9 feature levels.</p>
<p>Â³DXGI 1.2 introduced the 4:4:4:4 format. This format is optionally supported in the DirectX 11.1 runtime, which is required for feature level 11.1 video adapters and WDDM 1.2 drivers and already supported on 10level9 feature levels.</p>
<p>For uncompressed formats, DXGI has limited the support for arbitrary pixel format patterns; all uncompressed formats must be of type RGBA. This might require swizzling of existing assets pixel formats, which we recommend that you compute as an offline pre-process pass where possible.</p>
<h2>Porting Shaders</h2>
<h3>Direct3D 10 Shaders are Authored in HLSL</h3>
<p>Direct3D 10 limits the use of assembly language to that of debugging purposes only, therefore any hand written assembly shaders used in Direct3D 9 will need to be converted to HLSL.</p>
<h3>Shader Signatures and Linkage</h3>
<p>We discussed the requirements for Input Assembly linkage to Vertex shader input signatures earlier in this document (see above). Note that the Direct3D 10 runtime has also tightened the requirements for stage to stage linkage between shaders. This change will affect shader sources where the binding between stages may not have been fully described under Direct3D 9. For example:</p>
<pre><code>VS_OUTPUT                       PS_INPUT
float4   pos : SV_POSITION;     float4 pos : SV_POSITION;
float4   uv1 : TEXCOORD1;       float4 uv1 : TEXCOORD1;
float4x3 tangentSp : TEXCOORD2; float4 tangent : TEXCOORD2; *
float4   Color : TEXCOORD6;     float4 color : TEXCOORD6;
</code></pre>
<p>* Broken VS - PS Linkage - even though the pixel shader may not be interested in the full matrix, the linkage must specify the full float4x3.</p>
<p>Note, the linkage semantics between stages must match exactly however, the target stages inputs may be a prefix of the values being output. In the example above, the pixel shader could have position and texcoord1 as the only inputs, but it could not have the position and texcoord2 as the only inputs due to the ordering constraints.</p>
<h3>HLSL Shader Stage linkages</h3>
<p>Linkage between shaders may occur at any of the following points in the pipeline:</p>
<ul>
<li>Input Assembler to Vertex Shader</li>
<li>Vertex Shader to Pixel Shader</li>
<li>Vertex Shader to Geometry Shader</li>
<li>Vertex Shader to Stream Output</li>
<li>Geometry Shader to Pixel Shader</li>
<li>Geometry Shader to Stream Out</li>
</ul>
<h3>Constant Buffers</h3>
<p>For ease of porting content from Direct3D 9 an initial approach to constant management outside of the Effects system might involve the creation of a single constant buffer containing all the required constants. It is important for performance to order constants into buffers by the expected frequency of update. This organization will reduce the amount of redundant constant sets to a minimum.</p>
<h3>User clip planes in HLSL on feature level 9 and higher</h3>
<p>Starting with WindowsÂ 8, you can use the <strong>clipplanes</strong> function attribute in an HLSL <a href="../direct3dhlsl/dx-graphics-hlsl-function-syntax.html">function declaration</a> rather than <a href="../direct3dhlsl/dx-graphics-hlsl-semantics.html">SV_ClipDistance</a> to make your shader work on <a href="../direct3d11/overviews-direct3d-11-devices-downlevel-intro.html">feature level</a> 9_x as well as feature level 10 and higher. For more info, see <a href="../direct3dhlsl/user-clip-planes-on-10level9.html">User clip planes on feature level 9 hardware</a>.</p>
<h2>Additional Direct3D 10 Differences to Watch For</h2>
<h3>Integers as Input</h3>
<p>In Direct3D 9, there was no real hardware support for integer data types, however Direct3D 10 hardware supports explicit integer types. If you have floating-point data in your vertex buffer, then you must have a float input. Otherwise an integer type will be the bit pattern representation of the floating-point value. An integer type is not allowed for a pixel shader input unless the value is marked for no interpolation (see <a href="../direct3dhlsl/dx-graphics-hlsl-struct.html">Interpolation Modifiers</a>).</p>
<h3>Mouse Cursors</h3>
<p>On previous versions of Windows, the standard GDI mouse cursor routines did not operate correctly on all full-screen exclusive devices. The <a href="/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setcursorproperties"><strong>SetCursorProperties</strong></a>, <a href="/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-showcursor"><strong>ShowCursor</strong></a>, and <a href="/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setcursorposition"><strong>SetCursorPosition</strong></a> APIs were added to handle these cases. Since Windows Vista's version of GDI fully understands <a href="../direct3ddxgi/d3d10-graphics-programming-guide-dxgi.html">DXGI</a> surfaces, there is no need for this specialized mouse cursor API so there is no Direct3D 10 equivalent. Direct3D 10 applications should instead use the standard <a href="../menurc/cursors.html">GDI mouse cursor routines</a> for mouse cursors.</p>
<h3>Mapping Texels to Pixels in Direct3D 10</h3>
<p>In Direct3D 9, texel centers and pixel centers were a half unit apart (see <a href="../direct3d9/directly-mapping-texels-to-pixels.html">Directly Mapping Texels to Pixels (Direct3D 9)</a>). In Direct3D 10, texel centers are already at half-units, so there is no need to shift vertex coordinates at all.</p>
<p>Rendering full-screen quads is more straight-forward with Direct3D 10. Full-screen quads should be defined in clipspace (-1,1) and simply passed through the vertex shader with no changes. This way, there is no need to reload your vertex buffer every time the screen resolution changes, and there's no extra work in the pixel shader to manipulate the texture coordinates.</p>
<h3>Reference Counting Behavior Changes</h3>
<p>Unlike previous Direct3D versions, the various Set functions will not hold a reference to the devices objects. This means that the application must ensure that it holds a reference on the object for as long as it would like that object to be bound to the pipeline. When the ref count of the object drops to zero, then the object will be unbound from the pipeline as it is destroyed. This style of reference holding is also known as weak-reference holding, so therefore each bind location on the Device object holds a weak-reference to the interface/ object. Unless explicitly mentioned otherwise, this behavior should be assumed for all Set methods. Whenever destruction of an object causes a bind point to be set to <strong>NULL</strong> out, the Debug Layer will issue a warning. Note, calls to device Get methods such as <a href="/windows/desktop/api/D3D10/nf-d3d10-id3d10device-omgetrendertargets"><strong>OMGetRenderTargets</strong></a> will increase the reference count of objects being returned.</p>
<h3>Test Cooperative Level</h3>
<p>The functionality of the Direct3D 9 API <a href="/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-testcooperativelevel"><strong>TestCooperativeLevel</strong></a> is analogous to setting the <a href="../direct3ddxgi/dxgi-present.html">DXGI_PRESENT_TEST</a> when calling <a href="/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present"><strong>Present</strong></a>.</p>
<h3>StretchRect</h3>
<p>A function similar to the Direct3D 9 <a href="/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-stretchrect"><strong>IDirect3DDevice9::StretchRect</strong></a> method is not available in Direct3D 10 and 10.1. To copy resource surfaces, use <a href="/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion"><strong>ID3D10Device::CopySubresourceRegion</strong></a>. For resizing operations, render to a texture by using texture filtering. For converting MSAA surfaces to non-MSAA surfaces, use <a href="/windows/desktop/api/d3d10/nf-d3d10-id3d10device-resolvesubresource"><strong>ID3D10Device::ResolveSubresource</strong></a>.</p>
<h2>Additional Direct3D 10.1 Differences</h2>
<p>WindowsÂ Vista with Service PackÂ 1 (SP1) included a minor update to Direct3D 10 and Direct3D 10.1, which exposed the following additional hardware features:</p>
<ul>
<li>MSAA per-sample shaders</li>
<li>MSAA depth read-back</li>
<li>Independent blend modes per render target</li>
<li>Cube map arrays</li>
<li>Render to block-compressed (BC) formats</li>
</ul>
<p>The Direct3D 10.1 update added support for the following new interfaces, which are derived from existing interfaces:</p>
<ul>
<li><a href="/windows/desktop/api/D3D10_1/nn-d3d10_1-id3d10device1"><strong>ID3D10Device1</strong></a></li>
<li><a href="/windows/desktop/api/D3D10_1/nn-d3d10_1-id3d10blendstate1"><strong>ID3D10BlendState1</strong></a></li>
<li><a href="/windows/desktop/api/d3d10_1/nn-d3d10_1-id3d10shaderresourceview1"><strong>ID3D10ShaderResourceView1</strong></a></li>
</ul>
<p>The Direct3D 10.1 update also included the following additional structures:</p>
<ul>
<li><a href="/windows/desktop/api/d3d10_1/ns-d3d10_1-d3d10_render_target_blend_desc1"><strong>D3D10_RENDER_TARGET_BLEND_DESC1</strong></a></li>
<li><a href="/windows/desktop/api/D3D10_1/ns-d3d10_1-d3d10_blend_desc1"><strong>D3D10_BLEND_DESC1</strong></a></li>
<li><a href="/windows/desktop/api/d3d10_1/ns-d3d10_1-d3d10_shader_resource_view_desc1"><strong>D3D10_SHADER_RESOURCE_VIEW_DESC1</strong></a></li>
</ul>
<p>The Direct3D 10.1 API includes a new concept named feature level. This concept means that you can use the Direct3D 10.1 API to drive Direct3D 10.0 (<a href="/windows/desktop/api/D3D10_1/ne-d3d10_1-d3d10_feature_level1"><strong>D3D10_FEATURE_LEVEL_10_0</strong></a>) or Direct3D 10.1 (<a href="/windows/desktop/api/D3D10_1/ne-d3d10_1-d3d10_feature_level1"><strong>D3D10_FEATURE_LEVEL_10_1</strong></a>) hardware. Because the Direct3D 10.1 API is derived from the Direct3D 10 interfaces, applications can create a Direct3D 10.1 device, then use it as a Direct3D 10.0 device except where new 10.1-specific features are needed (provided that the <strong>D3D10_FEATURE_LEVEL_10_1</strong> feature-level is present and supports these features).</p>
<blockquote>
<p>[!Note]<br />
Direct3D 10.1 devices can use the existing 10.0 HLSL shader profiles (vs_4_0, ps_4_0, gs_4_0) and the new 10.1 profiles (vs_4_1, ps_4_1, gs_4_1) with additional HLSL instructions and capabilities.</p>
</blockquote>
<p>Â </p>
<p>WindowsÂ 7 contained a minor update to the Direct3D 10.1 API that is included in the Direct3D 11 runtime. This update adds support for the following feature levels:</p>
<ul>
<li><a href="/windows/desktop/api/D3D10_1/ne-d3d10_1-d3d10_feature_level1"><strong>D3D10_FEATURE_LEVEL_9_1</strong></a></li>
<li><a href="/windows/desktop/api/D3D10_1/ne-d3d10_1-d3d10_feature_level1"><strong>D3D10_FEATURE_LEVEL_9_2</strong></a></li>
<li><a href="/windows/desktop/api/D3D10_1/ne-d3d10_1-d3d10_feature_level1"><strong>D3D10_FEATURE_LEVEL_9_3</strong></a></li>
</ul>
<p>WindowsÂ 7 also added support to Direct3D 10.1 for <a href="../direct3darticles/directx-warp.html">Windows Advanced Rasterization Platform (WARP)</a>. You can specify a WARP driver by using <a href="/windows/desktop/api/D3D10misc/ne-d3d10misc-d3d10_driver_type"><strong>D3D10_DRIVER_TYPE_WARP</strong></a>.</p>
<p>For more information about Direct3D 10.1, see <a href="d3d10-graphics-programming-guide-10-1.html">Direct3D 10.1 Features</a> and the <a href="/windows/desktop/api/D3D10_1/ne-d3d10_1-d3d10_feature_level1"><strong>D3D10_FEATURE_LEVEL1</strong></a> enumeration.</p>
<h2>Related topics</h2>
<!-- raw HTML omitted -->
<p><a href="d3d10-graphics-programming-guide.html">Programming Guide for Direct3D 10</a></p>
<!-- raw HTML omitted -->
<p>Â </p>
<p>Â </p>
</body>
