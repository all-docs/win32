<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>COM+ Resource Dispenser Thread Types</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<h2>description: COM+ Resource Dispenser Thread Types
ms.assetid: 3ab67adb-311f-404c-a3ca-d274af53f91c
title: COM+ Resource Dispenser Thread Types
ms.topic: article
ms.date: 05/31/2018</h2>
<h1>COM+ Resource Dispenser Thread Types</h1>
<p>Calls into a COM+ resource dispenser may originate in one of the following thread types:</p>
<ul>
<li>Apartment thread (STA)</li>
<li>Free thread (MTA)</li>
<li>Non-COM thread (application or the <a href="com--dispenser-manager.html">dispenser manager</a> garbage-collector thread)</li>
</ul>
<p>If a resource dispenser is not a COM object, it must be able to handle calls arriving from any thread at any time. If a resource dispenser is a COM object, the COM object should be registered with a threading model of <strong>Both</strong>. This allows STA or MTA threads to create and use the resource dispenser without a thread switch.</p>
<p>If a resource dispenser creates and uses another COM object (for example, an out-of-process resource manager), the resource dispenser might need to maintain multiple proxies to this other COM object and ensure that calls to the object are made using the appropriate proxy for the calling thread. When the resource dispenser creates this object, it marshals and saves the reference. Before calling the object again, it must unmarshal to create a proxy for the calling thread.</p>
<p>It might be more efficient to cache these per-thread proxies by keeping a map from the thread ID to a proxy pointer. This map expands as new threads are used in the process.</p>
<h2>Related topics</h2>
<!-- raw HTML omitted -->
<p><a href="com--resource-dispenser-concepts.html">COM+ Resource Dispenser Concepts</a></p>
<!-- raw HTML omitted -->
<p>Â </p>
<p>Â </p>
</body>
