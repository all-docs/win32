<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Handling Errors in Queued Components</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<h2>description: Occasionally, a situation occurs in which a message cannot be successfully delivered to its intended destination, usually due to a problem with the system or configuration.
ms.assetid: 8015682c-d84d-44e2-995d-dca68053c4fa
title: Handling Errors in Queued Components
ms.topic: article
ms.date: 05/31/2018</h2>
<h1>Handling Errors in Queued Components</h1>
<p>Occasionally, a situation occurs in which a message cannot be successfully delivered to its intended destination, usually due to a problem with the system or configuration. For example, the message might be directed to a queue that does not exist or the destination queue might not be in a state to receive. The message mover is a tool that moves all failed <a href="/previous-versions/windows/desktop/legacy/ms711472(v=vs.85)">Message Queuing</a> messages from one queue to another so that they can be retried. The message mover utility is an Automation object that can be invoked with a VBScript.</p>
<h2>Components Services Administrative Tool</h2>
<p>Does not apply.</p>
<h2>Visual Basic</h2>
<p>The following sample code shows how to create a MessageMover object, set the required properties, and initiate the transfer. To use it from Visual Basic, add a reference to the COM+ Services Type Library.</p>
<blockquote>
<p>[!Note]<br />
To use the MessageMover object, you must have Message Queuing installed on your computer and the application specified by AppName must have queuing enabled. For information about installing Message Queuing, see Help and Support on the <strong>Start</strong> menu.</p>
</blockquote>
<p>Â </p>
<pre lang="VB"><code>Function MyMessageMover( _
  strSource As String, _
  strDest As String _
) As Boolean  ' Return False if any errors occur.

    MyMessageMover = False  ' Initialize the function.
    On Error GoTo My_Error_Handler  ' Initialize error handling.

    Dim lngMovedMessages As Long
    Dim objMessageMover As COMSVCSLib.MessageMover
    Set objMessageMover = CreateObject(&quot;QC.MessageMover&quot;)
    objMessageMover.SourcePath = strSource
    objMessageMover.DestPath = strDest
    lngMovedMessages = objMessageMover.MoveMessages

    MsgBox lngMovedMessages &amp; &quot; messages moved from &quot; &amp; _
      strSource &amp; &quot; to &quot; &amp; strDest

    MyMessageMover = True  ' Successful end to procedure
    Set objMessageMover = Nothing
    Exit Function

My_Error_Handler:  ' Replace with specific error handling.
    MsgBox &quot;Error # &quot; &amp; Err.Number &amp; &quot; (Hex: &quot; &amp; Hex(Err.Number) _
      &amp; &quot;)&quot; &amp; vbNewLine &amp; Err.Description
    Set objMessageMover = Nothing
    lngMovedMessages = -1
End Function

</code></pre>
<p>The following Visual Basic code shows how to call the MyMessageMover function.</p>
<pre lang="VB"><code>Sub Main()
  ' Replace AppName with the name of a COM+ application.
  If Not MyMessageMover(&quot;.\private$\AppName_deadqueue&quot;, &quot;.\AppName&quot;) Then
      MsgBox &quot;MyMessageMover failed.&quot;
  End If
End Sub

</code></pre>
<p>The source path of the message is the final resting queue. It is the dead queue, which is a private Message Queuing queue and is called AppName_deadqueue. Messages are moved here if the transaction repeatedly aborts when attempted on the fifth retry queue. With the message mover tool, you can move the message back to the first queue, which is called AppName. For more information on retry queues, see <a href="server-side-errors.html">Server-Side Errors</a>.</p>
<p>If queue attributes permit, the message mover moves messages transitionally so that messages are not lost or duplicated in the event of failure during the move. The tool preserves all the message properties that can be preserved when moving messages from one queue to another.</p>
<p>If the messages are generated by COM+ Queued Components calls, the message mover utility preserves the original caller's security identifier as it moves messages between queues. If both the destination and source queues are transactional, the whole operation is done transitionally. If either the source or destination queues are not transactional, the operation does not run under a transaction. An unexpected failure (such as a crash) and restart of a non-transactional move could duplicate the message being moved at the time of the failure.</p>
<h2>C/C++</h2>
<p>The following sample code shows how to create a MessageMover object, set the required properties, and initiate the transfer. The ErrorDescription method is described at <a href="interpreting-error-codes.html">Interpreting Error Codes</a>.</p>
<blockquote>
<p>[!Note]<br />
To use the MessageMover object, you must have Message Queuing installed on your computer and the application specified by AppName must have queuing enabled. For information about installing Message Queuing, see Help and Support on the <strong>Start</strong> menu.</p>
</blockquote>
<p>Â </p>
<pre lang="C++"><code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#import &quot;C:\WINDOWS\system32\ComSvcs.dll&quot;
#include &quot;ComSvcs.h&quot;
#include &quot;StrSafe.h&quot;  

BOOL MyMessageMover (OLECHAR* szSource, OLECHAR* szDest) {
    IUnknown * pUnknown = NULL;
    IMessageMover * pMover = NULL;
    HRESULT hr = S_OK;
    BSTR bstrSource = NULL;
    BSTR bstrDest = NULL;
    unsigned int uMaxLen = 255;  // Maximum length of szMyApp

try {
    // Test the input strings to make sure they're OK to use.
    hr = StringCchLengthW(szSource, uMaxLen, NULL);
    if (FAILED (hr)) throw(hr);
    hr = StringCchLengthW(szDest, uMaxLen, NULL);
    if (FAILED (hr)) throw(hr);
    
    // Convert the input strings to BSTRs.
    bstrSource = SysAllocString(szSource);
    bstrDest = SysAllocString(szDest);

    // Create a MessageMover object and get its IUnknown.
    hr = CoCreateInstance(CLSID_MessageMover, NULL, 
      CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)&amp;pUnknown);
    if (FAILED (hr)) throw(hr);    

    // Get the IMessageMover interface.
    hr = pUnknown-&gt;QueryInterface(IID_IMessageMover, (void**)&amp;pMover); 
    if (FAILED (hr)) throw(hr);

    // Put the source and destination files.
    hr = pMover-&gt;put_SourcePath(bstrSource);
    if (FAILED (hr)) throw(hr);
    hr = pMover-&gt;put_DestPath(bstrDest);
    if (FAILED (hr)) throw(hr);

    // Move the messages.
    LONG lCount = -1;
    hr = pMover-&gt;MoveMessages(&amp;lCount);
    if (FAILED (hr)) throw(hr);
    printf(&quot;%ld messages moved from %S to %S.\n&quot;, 
      lCount, bstrSource, bstrDest);

    // Clean up.
    SysFreeString(bstrDest);
    SysFreeString(bstrSource);
    pUnknown-&gt;Release();
    pUnknown = NULL;
    pMover-&gt;Release();
    pMover = NULL;
    return (TRUE);
}  // try

catch(HRESULT hr) {  // Replace with specific error handling.
    printf(&quot;Error # %#x: &quot;, hr);
    ErrorDescription(hr);
    SysFreeString(bstrDest);
    SysFreeString(bstrSource);
    if (NULL != pUnknown) pUnknown-&gt;Release();
    pUnknown = NULL;
    if (NULL != pMover) pMover-&gt;Release();
    pMover = NULL;
    return (FALSE);
}catch(...) {
    printf(&quot;An unexpected exception occurred.\n&quot;);
    throw;
}        
}  // MyMessageMover

</code></pre>
<p>The following C++ code shows how to call the MyMessageMover function.</p>
<pre lang="C++"><code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

#define _WIN32_DCOM  // To use CoInitializeEx()

void main() 
{
    HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (FAILED (hr)) {
        printf(&quot;CoInitializeEx failed: Error # %#x\n&quot;, hr);
        exit(0);  // Replace with specific error handling.
    }
    if (! MyMessageMover(L&quot;.\\private$\\AppName_deadqueue&quot;, 
      L&quot;.\\AppName&quot;))
        printf(&quot;MyMessageMover failed.\n&quot;);
    CoUninitialize();
}
</code></pre>
<p>The source path of the message is the final resting queue. It is the dead queue, which is a private Message Queuing queue and is called AppName_deadqueue. Messages are moved here if the transaction repeatedly aborts when attempted on the fifth retry queue. With the message mover tool, you can move the message back to the first queue, which is called AppName. For more information on retry queues, see <a href="server-side-errors.html">Server-Side Errors</a>.</p>
<p>If queue attributes permit, the message mover moves messages transitionally so that messages are not lost or duplicated in the event of failure during the move. The tool preserves all the message properties that can be preserved when moving messages from one queue to another.</p>
<p>If the messages are generated by COM+ Queued Components calls, the message mover utility preserves the original caller's security identifier as it moves messages between queues. If both the destination and source queues are transactional, the whole operation is done transitionally. If either the source or destination queues are not transactional, the operation does not run under a transaction. An unexpected failure (such as a crash) and restart of a non-transactional move could duplicate the message being moved at the time of the failure.</p>
<h2>Remarks</h2>
<p>COM+ handles server-side (player) aborts by moving the message that is failing onto a different &quot;final resting&quot; queue, to get it out of the way. The listener and player cannot continually loop on a message that aborts. In many cases, the aborted transaction can be fixed by taking action at the server.</p>
<h2>Related topics</h2>
<!-- raw HTML omitted -->
<p><a href="queued-components-errors.html">Queued Components Errors</a></p>
<!-- raw HTML omitted -->
<p>Â </p>
<p>Â </p>
</body>
