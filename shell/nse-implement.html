<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Implementing the Basic Folder Object Interfaces</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<p>description: The procedure for implementing a namespace extension is similar to that for any other in-process Component Object Model (COM) object.
title: Implementing the Basic Folder Object Interfaces
ms.topic: article
ms.date: 05/31/2018
ms.assetid: a45b8011-5355-429b-8935-4a7bdb5d2316
api_name:
api_type:
api_location:
topic_type:</p>
<ul>
<li>kbArticle</li>
</ul>
<hr />
<h1>Implementing the Basic Folder Object Interfaces</h1>
<p>The procedure for implementing a namespace extension is similar to that for any other in-process Component Object Model (COM) object. All extensions must support three primary interfaces that provide Windows Explorer with the basic information needed to display the extension's folders in the tree view. However, to make full use of the capabilities of Windows Explorer, your extension must also expose one or more optional interfaces that support more sophisticated features, such as shortcut menus or drag-and-drop, and provide a folder view.</p>
<p>This document discusses how to implement the primary and optional interfaces that Windows Explorer calls for information about the contents of your extension. For a discussion of how to implement a folder view and how to customize Windows Explorer, see <a href="../lwef/nse-folderview.html">Implementing a Folder View</a>.</p>
<ul>
<li><a href="#basic-implementation-and-registration">Basic Implementation and Registration</a>
<ul>
<li><a href="#registering-an-extension">Registering an Extension</a></li>
</ul>
</li>
<li><a href="#handling-pidls">Handling PIDLs</a>
<ul>
<li><a href="#creating-an-shitemid-structure">Creating an SHITEMID Structure</a></li>
<li><a href="#constructing-a-pidl">Constructing a PIDL</a></li>
<li><a href="#interpreting-pidls">Interpreting PIDLs</a></li>
</ul>
</li>
<li><a href="#implementing-the-primary-interfaces">Implementing the Primary Interfaces</a>
<ul>
<li><a href="#ipersistfolder-interface">IPersistFolder Interface</a></li>
<li><a href="#ishellfolder-interface">IShellFolder Interface</a></li>
<li><a href="#ienumidlist-interface">IEnumIDList Interface</a></li>
</ul>
</li>
<li><a href="#implementing-the-optional-interfaces">Implementing the Optional Interfaces</a>
<ul>
<li><a href="#iextracticon">IExtractIcon</a></li>
<li><a href="#icontextmenu">IContextMenu</a></li>
<li><a href="#iqueryinfo">IQueryInfo</a></li>
<li><a href="#idataobject-and-idroptarget">IDataObject and IDropTarget</a></li>
</ul>
</li>
<li><a href="#working-with-the-default-shell-folder-view-implementation">Working With the Default Shell Folder View Implementation</a></li>
</ul>
<h2>Basic Implementation and Registration</h2>
<p>As an in-process COM server, your DLL must expose several standard functions and interfaces:</p>
<ul>
<li><a href="/windows/win32/api/combaseapi/nf-combaseapi-dllcanunloadnow"><strong>DllCanUnloadNow</strong></a></li>
<li><a href="/windows/win32/api/combaseapi/nf-combaseapi-dllgetclassobject"><strong>DllGetClassObject</strong></a></li>
<li><a href="/windows/win32/api/unknwn/nn-unknwn-iclassfactory"><strong>IClassFactory</strong></a></li>
<li><a href="/windows/win32/api/unknwn/nn-unknwn-iunknown"><strong>IUnknown</strong></a></li>
</ul>
<p>These functions and interfaces are implemented in the same way as they are for most other COM objects. For details, see the <a href="../com/the-component-object-model.html">COM documentation</a>.</p>
<h3>Registering an Extension</h3>
<p>As with all COM objects, you must create a class identifier (CLSID) GUID for your extension. Register the object by creating a subkey of <strong>HKEY_CLASSES_ROOT</strong>\<strong>CLSID</strong> named for the CLSID of your extension. The DLL should be registered as an in-process server and should specify the apartment threading model. You can customize the behavior of an extension's root folder by adding a variety of subkeys and values to the extension's CLSID key.</p>
<p>Several of these values apply only to extensions with virtual junction points. These values do not apply to extensions whose junction points are file system folders. For further discussion, see <a href="nse-junction.html">Specifying a Namespace Extension's Location</a>. To modify the behavior of an extension with a virtual junction point, add one or more of the following values to the extension's CLSID key:</p>
<ul>
<li>WantsFORPARSING. The parsing name for an extension with a virtual junction point will normally have the form ::{<em>GUID</em>}. Extensions of this type normally contain virtual items. However, some extensions, such as My Documents, actually correspond to file system folders, even though they have virtual junction points. If your extension represents file system objects in this way, you can set the WantsFORPARSING value. Windows Explorer will then request your root folder's parsing name by calling the folder object's <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getdisplaynameof"><strong>IShellFolder::GetDisplayNameOf</strong></a> method with <em>uFlags</em> set to <strong>SHGDN_FORPARSING</strong> and <em>pidl</em> set to a single empty pointer to an item identifier list (PIDL). An empty PIDL contains only a terminator. Your method should then return the root folder's ::{<em>GUID</em>} parsing name.</li>
<li>HideFolderVerbs. The verbs registered under <strong>HKEY_CLASSES_ROOT</strong>\<strong>Folder</strong> normally are associated with all extensions. They appear on the extension's shortcut menu and can be invoked by <a href="/windows/desktop/api/Shellapi/nf-shellapi-shellexecutea"><strong>ShellExecute</strong></a>. To prevent any of these verbs from being associated with your extension, set the HideFolderVerbs value.</li>
<li>HideAsDelete. If a user attempts to delete your extension, Windows Explorer will instead hide the extension.</li>
<li>HideAsDeletePerUser. This value has the same effect as HideAsDelete but on a per-user basis. The extension is hidden only for those users who have attempted to delete it. The extension is visible to all other users.</li>
<li>QueryForOverlay. Set this value to indicate that the root folder's icon can have an icon overlay. The folder object must support the <a href="/windows/win32/api/shlobj_core/nn-shlobj_core-ishelliconoverlay"><strong>IShellIconOverlay</strong></a> interface. Before Windows Explorer displays the root folder's icon, it will request an overlay icon by calling one of the two <strong>IShellIconOverlay</strong> methods with <em>pidlItem</em> set to an empty PIDL.</li>
</ul>
<p>The remaining values and subkeys apply to all extensions:</p>
<ul>
<li>To specify the display name of the extension's junction point folder, set the default value of the extension's CLSID subkey to an appropriate string.</li>
<li>When the cursor hovers over a folder, an infotip is typically displayed that describes the contents of the folder. To provide an infotip for your extension's root folder, create an InfoTip <strong>REG_SZ</strong> value for the extension's CLSID key, and set it to an appropriate string.</li>
<li>To specify a custom icon for your extension's root folder, create a subkey of the extension's CLSID subkey named <strong>DefaultIcon</strong>. Set the default value of <strong>DefaultIcon</strong> to a <strong>REG_SZ</strong> value containing the name of the file that contains the icon, followed by a comma, followed by a minus sign, followed by the index of the icon in that file.</li>
<li>By default, the shortcut menu of your extension's root folder will contain the items defined under <strong>HKEY_CLASSES_ROOT\Folder</strong>. The <strong>Delete</strong>, <strong>Rename</strong>, and <strong>Properties</strong> items are added if you have set the appropriate SFGAO_XXX flags. You can add other items to the root folder's shortcut menu, or override existing items, much as you would for a <a href="fa-file-types.html">file type</a>. Create a <strong>Shell</strong> subkey under the extension's CLSID key, and define commands as discussed in <a href="context.html">Extending Shortcut Menus</a>.</li>
<li>If you need a more flexible way to handle the root folder's shortcut menu, you can implement a <a href="context-menu-handlers.html">shortcut menu handler</a>. To register the shortcut menu handler, create a <strong>ShellEx</strong> key under the extension's CLSID key. Register the handler's CLSID as you would for a conventional <a href="handlers.html">Creating Shell Extension Handlers</a>.</li>
<li>To add a page to the root folder's Properties property sheet, give the folder the <strong>SFGAO_HASPROPSHEET</strong> attribute and implement a <a href="propsheet-handlers.html">property sheet handler</a>. To register the property sheet handler, create a <strong>ShellEx</strong> key under the extension's CLSID key. Register the handler's CLSID as you would for a conventional <a href="handlers.html">Creating Shell Extension Handlers</a>.</li>
<li>To specify the attributes of the root folder, add a <strong>ShellFolder</strong> subkey to the extension's CLSID subkey. Create an Attributes value, and set it to the appropriate combination of <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getattributesof"><strong>SFGAO_XXX</strong></a> flags.</li>
</ul>
<p>The following table lists some commonly used attributes for root folders.</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>SFGAO_FOLDER</td>
<td>0x20000000</td>
<td>The extension's root folder contains one or more items.</td>
</tr>
<tr>
<td>SFGAO_HASSUBFOLDER</td>
<td>0x80000000</td>
<td>The extension's root folder contains one or more subfolders. Windows Explorer will place a plus sign ( + ) next to the folder icon.</td>
</tr>
<tr>
<td>SFGAO_CANDELETE</td>
<td>0x00000020</td>
<td>The extension's root folder can be deleted by the user. The folder's shortcut menu will have a <strong>Delete</strong> item. This flag should be set for junction points that are placed under one of the <a href="nse-junction.html">virtual folders</a>.</td>
</tr>
<tr>
<td>SFGAO_CANRENAME</td>
<td>0x00000010</td>
<td>The extension's root folder can be renamed by the user. The folder's shortcut menu will have a <strong>Rename</strong> item.</td>
</tr>
<tr>
<td>SFGAO_HASPROPSHEET</td>
<td>0x00000040</td>
<td>The extension's root folder has a <strong>Properties</strong> property sheet. The folder's shortcut menu will have a <strong>Properties</strong> item. To provide the property sheet, you must implement a <a href="propsheet-handlers.html">property sheet handler</a>. Register the handler under the extension's CLSID key, as discussed previously.</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>The following example shows the CLSID registry entry for an extension with a display name of MyExtension. The extension has a custom icon that is contained in the extension's DLL with an index of 1. The <strong>SFGAO_FOLDER</strong>, <strong>SFGAO_HASSUBFOLDER</strong>, and <strong>SFGAO_CANDELETE</strong> attributes are set.</p>
<pre><code>HKEY_CLASSES_ROOT
Â Â Â CLSID
Â Â Â Â Â Â {Extension CLSID}
Â Â Â Â Â Â Â Â Â (Default) = MyExtension
Â Â Â Â Â Â Â Â Â InfoTip = Some appropriate text
Â Â Â Â Â Â DefaultIcon
Â Â Â Â Â Â Â Â Â (Default) = c:\MyDir\MyExtension.dll,-1
Â Â Â Â Â Â InProcServer32
Â Â Â Â Â Â Â Â Â (Default) = c:\MyDir\MyExtension.dll
Â Â Â Â Â Â Â Â Â ThreadingModel = Apartment
Â Â Â Â Â Â ShellFolder
Â Â Â Â Â Â Â Â Â Attributes = 0xA00000020
</code></pre>
<h2>Handling PIDLs</h2>
<p>Every item in the Shell namespace must have a unique PIDL. Windows Explorer assigns a PIDL to your root folder and passes the value to your extension during initialization. Your extension is then responsible for assigning a properly constructed PIDL to each of its objects and providing those PIDLs to Windows Explorer on request. When the Shell uses a PIDL to identify one of your extension's objects, your extension must be able to interpret the PIDL and identify the particular object. Your extension must also assign a <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-setnameof"><strong>display name</strong></a> and a <em>parsing name</em> to each object. Because PIDLs are used by virtually every folder interface, extensions commonly implement a single <em>PIDL manager</em> to handle all these tasks.</p>
<p>The term PIDL is short for an <a href="/windows/desktop/api/Shtypes/ns-shtypes-itemidlist"><strong>ITEMIDLIST</strong></a> structure or a pointer to such a structure, depending on context. As declared, an <strong>ITEMIDLIST</strong> structure has a single member, an <a href="/windows/desktop/api/Shtypes/ns-shtypes-shitemid"><strong>SHITEMID</strong></a> structure. An object's <strong>ITEMIDLIST</strong> structure is actually a packed array of two or more <strong>SHITEMID</strong> structures. The order of these structures defines a path through the namespace, in much the same way that c:\MyDirectory\MyFile defines a path through the file system. Typically, an object's PIDL will consist of a series of <strong>SHITEMID</strong> structures that correspond to the folders that define the namespace path, followed by the object's <strong>SHITEMID</strong> structure, followed by a terminator.</p>
<p>The terminator is an <a href="/windows/desktop/api/Shtypes/ns-shtypes-shitemid"><strong>SHITEMID</strong></a> structure, with the <em>cb</em> member set to <strong>NULL</strong>. The terminator is necessary because the number of <strong>SHITEMID</strong> structures in an object's PIDL depends on the location of the object in the Shell namespace, and the starting point of the path. In addition, the size of the various <strong>SHITEMID</strong> structures can vary. When you receive a PIDL, you have no simple way of determining its size or even the total number of <strong>SHITEMID</strong> structures. Instead, you must &quot;walk&quot; the packed array, structure by structure, until you reach the terminator.</p>
<p>To create a PIDL, your application needs to:</p>
<ol>
<li>Create an <a href="/windows/desktop/api/Shtypes/ns-shtypes-shitemid"><strong>SHITEMID</strong></a> structure for each of its objects.</li>
<li>Assemble the relevant <a href="/windows/desktop/api/Shtypes/ns-shtypes-shitemid"><strong>SHITEMID</strong></a> structures into a PIDL.</li>
</ol>
<h3>Creating an SHITEMID Structure</h3>
<p>An object's <a href="/windows/desktop/api/Shtypes/ns-shtypes-shitemid"><strong>SHITEMID</strong></a> structure uniquely identifies the object within its folder. In fact, a type of PIDL used by many of the <a href="/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder"><strong>IShellFolder</strong></a> methods consists of just the object's <strong>SHITEMID</strong> structure, followed by a terminator. The definition of an <strong>SHITEMID</strong> structure is:</p>
<pre lang="C++"><code>typedef struct _SHITEMID { 
    USHORT cb; 
    BYTE   abID[1]; 
} SHITEMID, * LPSHITEMID;
</code></pre>
<p>The <em>abID</em> member is the object's identifier. Because the length of <em>abID</em> is not defined and can vary, the <em>cb</em> member is set to the size of the <a href="/windows/desktop/api/Shtypes/ns-shtypes-shitemid"><strong>SHITEMID</strong></a> structure, in bytes.</p>
<p>Because neither the length nor the content of <em>abID</em> is standardized, you can use any scheme you want to assign <em>abID</em> values to your objects. The only requirement is that you cannot have two objects in the same folder with identical values. However, for performance reasons, your <a href="/windows/desktop/api/Shtypes/ns-shtypes-shitemid"><strong>SHITEMID</strong></a> structure should be <strong>DWORD</strong>-aligned. In other words, you should construct your <em>abID</em> values such that <em>cb</em> is an integral multiple of 4.</p>
<p>Typically, <em>abID</em> points to an extension-defined structure. In addition to the object's ID, this structure is often used to hold a variety of related information, such as the object's type or attributes. Your extension's folder objects can then quickly extract the information from the PIDL instead of having to query for it.</p>
<blockquote>
<p>[!Note]<br />
One of the most important aspects of designing a data structure for a PIDL is to make the structure persistable and transportable. In the context of PIDLs, the meaning of these terms is:</p>
<ul>
<li>Persistable. The system frequently places PIDLs in various types of long-term storage, such as shortcut files. It can then recover these PIDLs from storage later, possibly after the system has been rebooted. A PIDL that has been recovered from storage must still be valid and meaningful to your extension. This requirement means, for instance, that you should not use pointers or handles in your PIDL structure. PIDLs containing this type of data will normally be meaningless when the system later recovers them from storage.</li>
<li>Transportable. A PIDL must remain meaningful when transported from one computer to another. For example, a PIDL can be written to a shortcut file, copied to a floppy disk, and transported to another computer. That PIDL should still be meaningful to your extension running on the second computer. For instance, to ensure that your PIDLs are transportable, use either ANSI or Unicode characters explicitly. Avoid data types such as <strong>TCHAR</strong> or <strong>LPTSTR</strong>. If you use those data types, a PIDL created on a computer running a Unicode version of your extension will not be readable by an ANSI version of that extension running on a different computer.</li>
</ul>
</blockquote>
<p>Â </p>
<p>The following declaration shows a simple example of a data structure.</p>
<pre lang="C++"><code>typedef struct tagMYPIDLDATA {
  USHORT cb;
  DWORD dwType;
  WCHAR wszDisplayName[40];
} MYPIDLDATA, *LPMYPIDLDATA;
</code></pre>
<p>The <strong>cb</strong> member is set to the size of the <strong>MYPIDLDATA</strong> structure. This member makes <strong>MYPIDLDATA</strong> a valid <a href="/windows/desktop/api/Shtypes/ns-shtypes-shitemid"><strong>SHITEMID</strong></a> structure, in and of itself. The rest of the members are equivalent to the <strong>abID</strong> member of an <strong>SHITEMID</strong> structure and hold private data. The <strong>dwType</strong> member is an extension-defined value that indicates the type of object. For this example, <strong>dwType</strong> is set to <strong>TRUE</strong> for folders and <strong>FALSE</strong> otherwise. This member allows you, for instance, to quickly determine whether the object is a folder or not. The <strong>wszDisplayName</strong> member contains the object's display name. Since you would not assign the same display name to two different objects in the same folder, the display name also serves as the object ID. In this example, <strong>wszDisplayName</strong> is set to 40 characters to guarantee that the <strong>SHITEMID</strong> structure will be <strong>DWORD</strong>-aligned. To limit the size of your PIDLs, you can instead use a variable-length character array and adjust the value of cb accordingly. Pad the display string with enough '\0' characters to maintain the structure's <strong>DWORD</strong> alignment. Other members that might be useful to put in the structure include the object's size, attributes, or parsing name.</p>
<h3>Constructing a PIDL</h3>
<p>Once you have defined <a href="/windows/desktop/api/Shtypes/ns-shtypes-shitemid"><strong>SHITEMID</strong></a> structures for your objects, you can then use them to construct a PIDL. PIDLs can be constructed for a variety of purposes, but most tasks use one of two types of PIDL. The simplest, a single-level PIDL, identifies the object relative to its parent folder. This type of PIDL is used by many of the <a href="/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder"><strong>IShellFolder</strong></a> methods. A single-level PIDL contains the object's <strong>SHITEMID</strong> structure, followed by a terminator. A fully qualified PIDL defines a path through the namespace hierarchy from the desktop to the object. This type of PIDL starts at the desktop and contains one <strong>SHITEMID</strong> structure for each folder in the path, followed by the object and the terminator. A fully qualified PIDL uniquely identifies the object within the entire Shell namespace.</p>
<p>The simplest way to construct a PIDL is to work directly with the <a href="/windows/desktop/api/Shtypes/ns-shtypes-itemidlist"><strong>ITEMIDLIST</strong></a> structure itself. Create an <strong>ITEMIDLIST</strong> structure, but allocate enough memory to hold all the <a href="/windows/desktop/api/Shtypes/ns-shtypes-shitemid"><strong>SHITEMID</strong></a> structures. The address of this structure will point to the initial <strong>SHITEMID</strong> structure. Define values for the members of this initial structure, and then append as many additional <strong>SHITEMID</strong> structures as you need, in the appropriate order. The following procedure outlines how to create a single-level PIDL. It contains two <strong>SHITEMID</strong> structuresâ€”a <strong>MYPIDLDATA</strong> structure followed by a terminator:</p>
<ol>
<li>Use the <a href="/windows/win32/api/combaseapi/nf-combaseapi-cotaskmemalloc"><strong>CoTaskMemAlloc</strong></a> function to allocate memory for the PIDL. Allocate enough memory for your private data plus a <strong>USHORT</strong> (two bytes) for the terminator. Cast the result to LPMYPIDLDATA.</li>
<li>Set the cb member of the first <strong>MYPIDLDATA</strong> structure to the size of that structure. For this example, you would set <strong>cb</strong> to sizeof(MYPIDLDATA). If you want to use a variable-length structure, you will have to calculate the value of <strong>cb</strong>.</li>
<li>Assign appropriate values to the private data members.</li>
<li>Calculate the address of the next <a href="/windows/desktop/api/Shtypes/ns-shtypes-shitemid"><strong>SHITEMID</strong></a> structure. Cast the address of the current MYPIDLDATA structure to LPBYTE, and add that value to the value of <strong>cb</strong> determined in step 3.</li>
<li>In this case, the next <a href="/windows/desktop/api/Shtypes/ns-shtypes-shitemid"><strong>SHITEMID</strong></a> structure is the terminator. Set the structure's <strong>cb</strong> member to zero.</li>
</ol>
<p>For longer PIDLs, allocate sufficient memory and repeat steps 3-5 for each additional <a href="/windows/desktop/api/Shtypes/ns-shtypes-shitemid"><strong>SHITEMID</strong></a> structure.</p>
<p>The following sample function takes an object's type and display name and returns the object's single-level PIDL. The function assumes that the display name, including its terminating <strong>null</strong> character, does not exceed the number of characters declared for the <strong>MYPIDLDATA</strong> structure. If that assumption turns out to be erroneous, the <a href="/windows/win32/api/strsafe/nf-strsafe-stringcbcopya"><strong>StringCbCopyW</strong></a> function will truncate the display name. The <strong>g_pMalloc</strong> variable is an <a href="/windows/win32/api/objidlbase/nn-objidlbase-imalloc"><strong>IMalloc</strong></a> pointer created elsewhere and stored in a global variable.</p>
<pre lang="C++"><code>LPITEMIDLIST CreatePIDL(DWORD dwType, LPCWSTR pwszDisplayName)
{
    LPMYPIDLDATA   pidlOut;
    USHORT         uSize;

    pidlOut = NULL;

    //Calculate the size of the MYPIDLDATA structure.
    uSize = sizeof(MYPIDLDATA);

    // Allocate enough memory for the PIDL to hold a MYPIDLDATA structure 
    // plus the terminator
    pidlOut = (LPMYPIDLDATA)m_pMalloc-&gt;Alloc(uSize + sizeof(USHORT));

    if(pidlOut)
    {
       //Assign values to the members of the MYPIDLDATA structure
       //that is the PIDL's first SHITEMID structure
       pidlOut-&gt;cb = uSize;
       pidlOut-&gt;dwType = dwType;
       hr = StringCbCopyW(pidlOut-&gt;wszDisplayName, 
                          sizeof(pidlOut-&gt;wszDisplayName), pwszDisplayName);
       
       // TODO: Add error handling here to verify the HRESULT returned 
       // by StringCbCopyW.

       //Advance the pointer to the start of the next SHITEMID structure.
       pidlOut = (LPMYPIDLDATA)((LPBYTE)pidlOut + pidlOut-&gt;cb);

       //Create the terminating null character by setting cb to 0.
       pidlOut-&gt;cb = 0;
    }

    return pidlOut;
</code></pre>
<p>A fully qualified PIDL must have <a href="/windows/desktop/api/Shtypes/ns-shtypes-shitemid"><strong>SHITEMID</strong></a> structures for every object from the desktop to your object. Your extension receives a fully qualified PIDL for your root folder when the Shell calls <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipersistfolder-initialize"><strong>IPersistFolder::Initialize</strong></a>. To construct a fully qualified PIDL for an object, take the PIDL that the Shell has assigned to your root folder, and append the <strong>SHITEMID</strong> structures that are needed to take you from the root folder to the object.</p>
<h3>Interpreting PIDLs</h3>
<p>When the Shell or an application calls one of your extension's interfaces to request information about an object, it will usually identify the object by a PIDL. Some methods, such as <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof"><strong>IShellFolder::GetUIObjectOf</strong></a>, use PIDLs that are relative to the parent folder and are straightforward to interpret. However, your extension will probably also receive fully qualified PIDLs. Your PIDL manager must then determine which of your objects that PIDL is referring to.</p>
<p>What complicates the task of associating an object with a fully qualified PIDL is that one or more of the initial <a href="/windows/desktop/api/Shtypes/ns-shtypes-shitemid"><strong>SHITEMID</strong></a> structures in the PIDL might belong to objects that lie outside your extension in the Shell namespace. You have no way of interpreting the meaning of the <em>abID</em> member of those structures. What your extension must do is to &quot;walk&quot; the list of <strong>SHITEMID</strong> structures, until you reach the structure that corresponds to your root folder. From then on, you will know how to interpret the information in the <strong>SHITEMID</strong> structures.</p>
<p>To walk the PIDL, take the first <em>cb</em> value and add it to the address of the PIDL to advance the pointer to the start of the next <a href="/windows/desktop/api/Shtypes/ns-shtypes-shitemid"><strong>SHITEMID</strong></a> structure. It then will be pointing to that structure's <em>cb</em> member, which you can use to advance the pointer to the start of the next <strong>SHITEMID</strong> structure, and so on. Each time you advance the pointer, examine the <strong>SHITEMID</strong> structure to determine whether you have reached the root of your extension's namespace.</p>
<h2>Implementing the Primary Interfaces</h2>
<p>As with all COM objects, implementing an extension is largely a matter of implementing a collection of interfaces. This section discusses the three primary interfaces that must be implemented by all extensions. They are used for initialization and to provide Windows Explorer with basic information about the contents of the extension. These interfaces, plus a <a href="../lwef/nse-folderview.html">folder view</a>, are all that is required for a functional extension. However, to fully exploit the features of Windows Explorer, most extensions also implement one or more of the optional interfaces.</p>
<h3>IPersistFolder Interface</h3>
<p>The <a href="/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipersistfolder"><strong>IPersistFolder</strong></a> interface is called to initialize a new folder object. The <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipersistfolder-initialize"><strong>IPersistFolder::Initialize</strong></a> method assigns a fully qualified PIDL to the new object. Store this PIDL for later use. For instance, a folder object must use this PIDL to construct fully qualified PIDLs for the object's children. The folder object's creator can also call <a href="/windows/win32/api/objidl/nf-objidl-ipersist-getclassid"><strong>IPersist::GetClassID</strong></a> to request the object's CLSID.</p>
<p>Typically, a folder object is created and initialized by its parent folder's <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-bindtoobject"><strong>IShellFolder::BindToObject</strong></a> method. However, when a user browses into your extension, Windows Explorer creates and initializes the extension's root folder object. The PIDL that the root folder object receives through <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipersistfolder-initialize"><strong>IPersistFolder::Initialize</strong></a> contains the path from the desktop to the root folder that you will need to construct fully qualified PIDLs for your extension.</p>
<h3>IShellFolder Interface</h3>
<p>The Shell treats an extension as a hierarchically ordered collection of folder objects. The <a href="/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder"><strong>IShellFolder</strong></a> interface is the core of any extension implementation. It represents a folder object and provides Windows Explorer with much of the information needed to display the contents of the folder.</p>
<p><a href="/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder"><strong>IShellFolder</strong></a> is typically the only folder interface other than <a href="/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipersistfolder"><strong>IPersistFolder</strong></a> that is directly exposed by a folder object. While Windows Explorer uses a variety of required and optional interfaces to obtain information about the contents of the folder, it obtains pointers to those interfaces through <strong>IShellFolder</strong>.</p>
<p>Windows Explorer obtains the CLSID of your extension's root folder in a variety of ways. For details, see <a href="nse-junction.html">Specifying a Namespace Extension's Location</a> or <a href="nse-view.html">Displaying a Self-Contained View of a Namespace Extension</a>. Windows Explorer then uses that CLSID to create and initialize an instance of the root folder and query for an <a href="/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder"><strong>IShellFolder</strong></a> interface. Your extension creates a folder object to represent the root folder and returns the object's <strong>IShellFolder</strong> interface. Much of the remainder of the interaction between your extension and Windows Explorer then takes place through <strong>IShellFolder</strong>. Windows Explorer calls <strong>IShellFolder</strong> to:</p>
<ul>
<li>Request an object that can enumerate the contents of the root folder.</li>
<li>Obtain various types of information about the contents of the root folder.</li>
<li>Request an object that exposes one of the optional interfaces. Those interfaces can then be queried for additional information, such as icons or shortcut menus.</li>
<li>Request a folder object that represents a subfolder of the root folder.</li>
</ul>
<p>When a user opens a subfolder of the root folder, Windows Explorer calls <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-bindtoobject"><strong>IShellFolder::BindToObject</strong></a>. Your extension creates and initializes a new folder object to represent the subfolder and returns its <a href="/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder"><strong>IShellFolder</strong></a> interface. Windows Explorer then calls this interface for various types of information, and so on until the user decides to navigate elsewhere in the Shell namespace or close Windows Explorer.</p>
<p>The remainder of this section briefly discusses the more important <a href="/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder"><strong>IShellFolder</strong></a> methods and how to implement them.</p>
<h3>EnumObjects</h3>
<p>Before displaying the contents of a folder in the tree view, Windows Explorer must first determine what the folder contains by calling the <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-enumobjects"><strong>IShellFolder::EnumObjects</strong></a> method. This method creates a standard OLE enumeration object that exposes an <a href="/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ienumidlist"><strong>IEnumIDList</strong></a> interface and returns that interface pointer. The <strong>IEnumIDList</strong> interface allows Windows Explorer to obtain the PIDLs of all the objects contained by the folder. These PIDLs are then used to obtain information about the objects contained by the folder. For further details, see <a href="#ienumidlist-interface">IEnumIDList Interface</a>.</p>
<blockquote>
<p>[!Note]<br />
The <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ienumidlist-next"><strong>IEnumIDList::Next</strong></a> method should only return PIDLs that are relative to the parent folder. The PIDL should contain only the object's <a href="/windows/desktop/api/Shtypes/ns-shtypes-shitemid"><strong>SHITEMID</strong></a> structure, followed by a terminator.</p>
</blockquote>
<p>Â </p>
<h3>CreateViewObject</h3>
<p>Before the contents of a folder are displayed, Windows Explorer calls this method to request a pointer to an <a href="/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellview"><strong>IShellView</strong></a> interface. This interface is used by Windows Explorer to manage the folder view. Create a folder view object and return its <strong>IShellView</strong> interface.</p>
<p>The <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-createviewobject"><strong>IShellFolder::CreateViewObject</strong></a> method is also called to request one of the optional interfaces, such as <a href="/windows/win32/api/shobjidl_core/nn-shobjidl_core-icontextmenu"><strong>IContextMenu</strong></a>, for the folder itself. Your implementation of this method should create an object that exposes the requested interface and returns the interface pointer. If Windows Explorer needs an optional interface for one of the objects contained by the folder, it will call <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof"><strong>IShellFolder::GetUIObjectOf</strong></a>.</p>
<h3>GetUIObjectOf</h3>
<p>While basic information about the contents of a folder is available through the <a href="/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder"><strong>IShellFolder</strong></a> methods, your extension can also provide Windows Explorer with various kinds of additional information. For instance, you can specify icons for the contents of a folder or an object's shortcut menu. Windows Explorer calls the <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof"><strong>IShellFolder::GetUIObjectOf</strong></a> method to attempt to retrieve additional information about an object that is contained by a folder. Windows Explorer specifies which object it wants the information for, and the IID of the relevant interface. The folder object then creates an object that exposes the requested interface and returns the interface pointer.</p>
<p>If your extension allows users to transfer objects with drag-and-drop or the clipboard, Windows Explorer will call <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof"><strong>IShellFolder::GetUIObjectOf</strong></a> to request an <a href="/windows/win32/api/objidl/nn-objidl-idataobject"><strong>IDataObject</strong></a> or <a href="/windows/win32/api/oleidl/nn-oleidl-idroptarget"><strong>IDropTarget</strong></a> interface. For details, see <a href="dragdrop.html">Transferring Shell Objects with Drag-and-Drop and the Clipboard</a>.</p>
<p>Windows Explorer calls <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-createviewobject"><strong>IShellFolder::CreateViewObject</strong></a> when it wants the same sort of information about the folder itself.</p>
<h3>BindToObject</h3>
<p>Windows Explorer calls the <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-bindtoobject"><strong>IShellFolder::BindToObject</strong></a> method when a user attempts to open one of your extension's subfolders. If <em>riid</em> is set to IID_IShellFolder, you should create and initialize a folder object that represents the subfolder and return the object's <a href="/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder"><strong>IShellFolder</strong></a> interface.</p>
<blockquote>
<p>[!Note]<br />
At present, Windows Explorer calls this method only to request an <a href="/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder"><strong>IShellFolder</strong></a> interface. However, do not assume that this will always be the case. You should always check the value of <em>riid</em> before proceeding.</p>
</blockquote>
<p>Â </p>
<h3>GetDisplayNameOf</h3>
<p>Windows Explorer calls the <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getdisplaynameof"><strong>IShellFolder::GetDisplayNameOf</strong></a> method to convert the PIDL of one of the folder's objects into a name. That PIDL must be relative to the object's parent folder. In other words, it must contain a single non-<strong>NULL</strong> <a href="/windows/desktop/api/Shtypes/ns-shtypes-shitemid"><strong>SHITEMID</strong></a> structure. Because there is more than one possible way to name objects, Windows Explorer specifies the type of name by setting one or more <a href="/windows/win32/api/shobjidl_core/ne-shobjidl_core-_shgdnf"><strong>SHGDNF</strong></a> flags in the <em>uFlags</em> parameter. One of two values, <strong>SHGDN_NORMAL</strong> or <strong>SHGDN_INFOLDER</strong>, will be set to specify whether the name should be relative to the folder or relative to the desktop. One of the other three values, <strong>SHGDN_FOREDITING</strong>, <strong>SHGDN_FORADDRESSBAR</strong>, or <strong>SHGDN_FORPARSING</strong>, can be set to specify what the name will be used for.</p>
<p>You must return the name in the form of an <a href="/windows/desktop/api/Shtypes/ns-shtypes-strret"><strong>STRRET</strong></a> structure. If <strong>SHGDN_FOREDITING</strong>, <strong>SHGDN_FORADDRESSBAR</strong>, and <strong>SHGDN_FORPARSING</strong> are not set, return the object's display name. If the <strong>SHGDN_FORPARSING</strong> flag is set, Windows Explorer is requesting a parsing name. Parsing names are passed to <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-parsedisplayname"><strong>IShellFolder::ParseDisplayName</strong></a> to obtain an object's PIDL, even though it might be located one or more levels below the current folder in the namespace hierarchy. For example, the parsing name of a file system object is its path. You can pass the fully qualified path of any object in the file system to the desktop's <strong>IShellFolder::ParseDisplayName</strong> method, and it will return the object's fully qualified PIDL.</p>
<p>While parsing names are text strings, they do not necessarily have to include the display name. You should assign parsing names based on what will work most efficiently when <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-parsedisplayname"><strong>IShellFolder::ParseDisplayName</strong></a> is called. For instance, many of the Shell's virtual folders are not part of the file system and do not have a fully qualified path. Instead, each folder is assigned a GUID and the parsing name takes the form ::{GUID}. Regardless of what scheme you use, it should be able to reliably &quot;round trip.&quot; For instance, if a caller passes a parsing name to <strong>IShellFolder::ParseDisplayName</strong> to retrieve an object's PIDL, and then passes that PIDL to <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getdisplaynameof"><strong>IShellFolder::GetDisplayNameOf</strong></a> with the <strong>SHGDN_FORPARSING</strong> flag set, the caller should recover the original parsing name.</p>
<h3>GetAttributesOf</h3>
<p>Windows Explorer calls the <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getattributesof"><strong>IShellFolder::GetAttributesOf</strong></a> method to determine the attributes of one or more items contained by a folder object. The value of <em>cidl</em> gives the number of items in the query, and <em>aPidl</em> points to a list of their PIDLs.</p>
<p>Because testing for some attributes can be time consuming, Windows Explorer typically restricts the query to a subset of the available flags by setting their values in <em>rfgInOut</em>. Your method should test for only those attributes whose flags are set in <em>rfgInOut</em>. Leave the valid flags set and clear the remainder. If more than one item is included in the query, set only those flags that apply to all items.</p>
<blockquote>
<p>[!Note]<br />
The attributes must be properly set for an item to be correctly displayed. For instance, if an item is a folder that contains subfolders, you must set the <strong>SFGAO_HASSUBFOLDER</strong> flag. Otherwise, Windows Explorer will not display a + next to the item's icon in the tree view.</p>
</blockquote>
<p>Â </p>
<h3>ParseDisplayName</h3>
<p>The <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-parsedisplayname"><strong>IShellFolder::ParseDisplayName</strong></a> method is in some sense a mirror image of <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getdisplaynameof"><strong>IShellFolder::GetDisplayNameOf</strong></a>. The most common use of this method is to convert an object's parsing name into the associated PIDL. The parsing name can refer to any object that lies below the folder in the namespace hierarchy. The returned PIDL is relative to the folder object that exposes the method and is usually not fully qualified. In other words, although the PIDL can contain several <a href="/windows/desktop/api/Shtypes/ns-shtypes-shitemid"><strong>SHITEMID</strong></a> structures, the first will either be that of the object itself or the first subfolder in the path from the folder to the object. The caller will have to append this PIDL to the folder's fully qualified PIDL to obtain a fully qualified PIDL for the object.</p>
<p><a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-parsedisplayname"><strong>IShellFolder::ParseDisplayName</strong></a> can also be called to request an object's attributes. Because determining all the applicable attributes can be time consuming, the caller will set only those <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getattributesof"><strong>SFGAO_XXX</strong></a> flags that represent information that the caller is interested in. You should determine which of those attributes are true for the object, and clear the remaining flags.</p>
<h3>IEnumIDList Interface</h3>
<p>When Windows Explorer needs to enumerate the objects that are contained by a folder, it calls <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-enumobjects"><strong>IShellFolder::EnumObjects</strong></a>. The folder object must create an enumeration object that exposes the <a href="/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ienumidlist"><strong>IEnumIDList</strong></a> interface and return that interface pointer. Windows Explorer will then typically use <strong>IEnumIDList</strong> to enumerate the PIDLs of all the objects contained by the folder.</p>
<p><a href="/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ienumidlist"><strong>IEnumIDList</strong></a> is a standard OLE enumeration interface and is implemented in the usual way. Remember, however, that the PIDLs that you return must be relative to the folder and contain only the object's <a href="/windows/desktop/api/Shtypes/ns-shtypes-shitemid"><strong>SHITEMID</strong></a> structure and a terminator.</p>
<h2>Implementing the Optional Interfaces</h2>
<p>There are a number of optional Shell interfaces that your extension's folder objects can support. Many of them, such as <a href="/windows/win32/api/shlobj_core/nn-shlobj_core-iextracticona"><strong>IExtractIcon</strong></a>, allow you to customize various aspects of the way the user views your extension. Others, such as <a href="/windows/win32/api/objidl/nn-objidl-idataobject"><strong>IDataObject</strong></a>, allow your extension to support features such as drag-and-drop.</p>
<p>None of the optional interfaces are exposed directly by a folder object. Instead, Windows Explorer calls one of two <a href="/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder"><strong>IShellFolder</strong></a> methods to request an interface:</p>
<ul>
<li>Windows Explorer calls a folder object's <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof"><strong>IShellFolder::GetUIObjectOf</strong></a> to request an interface for one of the objects contained by the folder.</li>
<li>Windows Explorer calls a folder object's <a href="/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-createviewobject"><strong>IShellFolder::CreateViewObject</strong></a> to request an interface for the folder itself.</li>
</ul>
<p>To provide the information, the folder object creates an object that exposes the requested interface and returns the interface pointer. Windows Explorer then calls that interface to retrieve the needed information. This section discusses the most commonly used optional interfaces.</p>
<h3>IExtractIcon</h3>
<p>Windows Explorer requests an <a href="/windows/win32/api/shlobj_core/nn-shlobj_core-iextracticona"><strong>IExtractIcon</strong></a> interface before it displays the contents of a folder. The interface allows your extension to specify custom icons for the objects that are contained by the folder. Otherwise, the standard file and folder icons will be used. To provide a custom icon, create an icon extraction object that exposes <strong>IExtractIcon</strong> and return a pointer to that interface. For further discussion, see the <strong>IExtractIcon</strong> reference documentation or <a href="./how-to-create-icon-handlers.html">Creating Icon Handlers</a>.</p>
<h3>IContextMenu</h3>
<p>When a user right-clicks an object, Windows Explorer requests an <a href="/windows/win32/api/shobjidl_core/nn-shobjidl_core-icontextmenu"><strong>IContextMenu</strong></a> interface. To provide shortcut menus for your objects, create a menu handler object and return its <strong>IContextMenu</strong> interface.</p>
<p>The procedures for creating a menu handler object are very similar to those used to create a menu handler Shell extension. For details, see <a href="context-menu-handlers.html">Creating Context Menu Handlers</a> or the <a href="/windows/win32/api/shobjidl_core/nn-shobjidl_core-icontextmenu"><strong>IContextMenu</strong></a>, <a href="/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu2"><strong>IContextMenu2</strong></a>, or <a href="/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu3"><strong>IContextMenu3</strong></a> reference.</p>
<h3>IQueryInfo</h3>
<p>Windows Explorer calls the <a href="/windows/win32/api/shlobj_core/nn-shlobj_core-iqueryinfo"><strong>IQueryInfo</strong></a> interface to retrieve an infotip text string.</p>
<h3>IDataObject and IDropTarget</h3>
<p>When your objects are displayed by Windows Explorer, a folder object has no direct way to know when a user is attempting to cut, copy, or drag an object. Instead, Windows Explorer requests an <a href="/windows/win32/api/objidl/nn-objidl-idataobject"><strong>IDataObject</strong></a> interface. To allow the object to be transferred, create a data object and return a pointer to its <strong>IDataObject</strong> interface.</p>
<p>Similarly, a user might attempt to drop a data object on a Windows Explorer representation of one of your objects, such as an icon or address bar path. Windows Explorer then requests an <a href="/windows/win32/api/oleidl/nn-oleidl-idroptarget"><strong>IDropTarget</strong></a> interface. To allow the data object to be dropped, create an object that exposes an <strong>IDropTarget</strong> interface and return the interface pointer.</p>
<p>Handling data transfer is one of the trickier aspects of writing namespace extensions. For a detailed discussion, see <a href="dragdrop.html">Transferring Shell Objects with Drag-and-Drop and the Clipboard</a>.</p>
<h2>Working With the Default Shell Folder View Implementation</h2>
<p>Data sources that use the default Shell folder view object (DefView) must implement these interfaces:</p>
<ul>
<li><a href="/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellfolder"><strong>IShellFolder</strong></a></li>
<li><a href="/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellfolder2"><strong>IShellFolder2</strong></a></li>
<li><a href="/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipersistfolder"><strong>IPersistFolder</strong></a></li>
<li><a href="/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipersistfolder2"><strong>IPersistFolder2</strong></a></li>
</ul>
<p>Optionally, they can also implement <a href="/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipersistfolder3"><strong>IPersistFolder3</strong></a>.</p>
<p>Â </p>
<p>Â </p>
</body>
