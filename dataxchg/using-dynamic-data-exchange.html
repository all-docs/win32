<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Using Dynamic Data Exchange</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<p>title: Using Dynamic Data Exchange
description: This topic provides code samples concerning dynamic data exchange.
ms.assetid: 6d94403b-64b4-4763-868a-3b94431dab79
keywords:</p>
<ul>
<li>Dynamic Data Exchange (DDE),conversations</li>
<li>DDE (Dynamic Data Exchange),conversations</li>
<li>data exchange,Dynamic Data Exchange (DDE)</li>
<li>Dynamic Data Exchange (DDE),examples</li>
<li>DDE (Dynamic Data Exchange),examples</li>
<li>Dynamic Data Exchange (DDE),commands in server applications</li>
<li>DDE (Dynamic Data Exchange),commands in server applications</li>
<li>Dynamic Data Exchange (DDE),data links</li>
<li>DDE (Dynamic Data Exchange),data links</li>
<li>Dynamic Data Exchange (DDE),items</li>
<li>DDE (Dynamic Data Exchange),items
ms.topic: article
ms.date: 05/31/2018</li>
</ul>
<hr />
<h1>Using Dynamic Data Exchange</h1>
<p>This section has code samples on the following tasks:</p>
<ul>
<li><a href="#initiating-a-conversation">Initiating a Conversation</a></li>
<li><a href="#transferring-a-single-item">Transferring a Single Item</a>
<ul>
<li><a href="#retrieving-an-item-from-the-server">Retrieving an Item from the Server</a></li>
<li><a href="#submitting-an-item-to-the-server">Submitting an Item to the Server</a></li>
</ul>
</li>
<li><a href="#establishing-a-permanent-data-link">Establishing a Permanent Data Link</a>
<ul>
<li><a href="#initiating-a-data-link">Initiating a Data Link</a></li>
<li><a href="#initiating-a-data-link-with-the-paste-link-command">Initiating a Data Link with the Paste Link Command</a></li>
<li><a href="#notifying-the-client-that-data-has-changed">Notifying the Client that Data Has Changed</a></li>
<li><a href="#terminating-a-data-link">Terminating a Data Link</a></li>
</ul>
</li>
<li><a href="#carrying-out-commands-in-a-server-application">Carrying Out Commands in a Server Application</a></li>
<li><a href="#terminating-a-conversation">Terminating a Conversation</a></li>
</ul>
<h2>Initiating a Conversation</h2>
<p>To initiate a Dynamic Data Exchange (DDE) conversation, the client sends a <a href="wm-dde-initiate.html"><strong>WM_DDE_INITIATE</strong></a> message. Usually, the client broadcasts this message by calling <a href="/windows/desktop/api/winuser/nf-winuser-sendmessage"><strong>SendMessage</strong></a>, with â€“1 as the first parameter. If the application already has the window handle to the server application, it can send the message directly to that window. The client prepares atoms for the application name and topic name by calling <a href="/windows/desktop/api/Winbase/nf-winbase-globaladdatoma"><strong>GlobalAddAtom</strong></a>. The client can request conversations with any potential server application and for any potential topic by supplying <strong>NULL</strong> (wildcard) atoms for the application and topic.</p>
<p>The following example illustrates how the client initiates a conversation, where both the application and topic are specified.</p>
<pre><code>    static BOOL fInInitiate = FALSE; 
    char *szApplication; 
    char *szTopic; 
    atomApplication = *szApplication == 0 ? 
    NULL     : GlobalAddAtom((LPSTR) szApplication); 
    atomTopic = *szTopic == 0 ? 
    NULL     : GlobalAddAtom((LPSTR) szTopic); 
 
    fInInitiate = TRUE; 
    SendMessage((HWND) HWND_BROADCAST, // broadcasts message 
        WM_DDE_INITIATE,               // initiates conversation 
        (WPARAM) hwndClientDDE,        // handle to client DDE window 
        MAKELONG(atomApplication,      // application-name atom 
            atomTopic));               // topic-name atom 
    fInInitiate = FALSE; 
    if (atomApplication != NULL) 
        GlobalDeleteAtom(atomApplication); 
    if (atomTopic != NULL) 
        GlobalDeleteAtom(atomTopic);
</code></pre>
<blockquote>
<p>[!Note]<br />
If your application uses <strong>NULL</strong> atoms, you need not use the <a href="/windows/desktop/api/Winbase/nf-winbase-globaladdatoma"><strong>GlobalAddAtom</strong></a> and <a href="/windows/desktop/api/Winbase/nf-winbase-globaldeleteatom"><strong>GlobalDeleteAtom</strong></a> functions. In this example, the client application creates two global atoms containing the name of the server and the name of the topic, respectively.</p>
</blockquote>
<p>Â </p>
<p>The client application sends a <a href="wm-dde-initiate.html"><strong>WM_DDE_INITIATE</strong></a> message with these two atoms in the <em>lParam</em> parameter of the message. In the call to the <a href="/windows/desktop/api/winuser/nf-winuser-sendmessage"><strong>SendMessage</strong></a> function, the special window handle â€“1 directs the system to send this message to all other active applications. <strong>SendMessage</strong> does not return to the client application until all applications that receive the message have, in turn, returned control to the system. This means that all <a href="wm-dde-ack.html"><strong>WM_DDE_ACK</strong></a> messages sent in reply by the server applications are guaranteed to have been processed by the client by the time the <strong>SendMessage</strong> call has returned.</p>
<p>After <a href="/windows/desktop/api/winuser/nf-winuser-sendmessage"><strong>SendMessage</strong></a> returns, the client application deletes the global atoms.</p>
<p>Server applications respond according to the logic illustrated in the following diagram.</p>
<p><img src="images/csdde-01.png" alt="server application response logic" /></p>
<p>To acknowledge one or more topics, the server must create atoms for each conversation (requiring duplicate application-name atoms if there are multiple topics) and send a <a href="wm-dde-ack.html"><strong>WM_DDE_ACK</strong></a> message for each conversation, as illustrated in the following example.</p>
<pre><code>if ((atomApplication = GlobalAddAtom(&quot;Server&quot;)) != 0) 
{ 
    if ((atomTopic = GlobalAddAtom(szTopic)) != 0) 
    { 
        SendMessage(hwndClientDDE, 
            WM_DDE_ACK, 
            (WPARAM) hwndServerDDE, 
            MAKELONG(atomApplication, atomTopic)); 
        GlobalDeleteAtom(atomTopic); 
    } 
 
    GlobalDeleteAtom(atomApplication); 
} 
 
if ((atomApplication == 0) || (atomTopic == 0)) 
{ 
    // Handle errors. 
}
</code></pre>
<p>When a server responds with a <a href="wm-dde-ack.html"><strong>WM_DDE_ACK</strong></a> message, the client application should save a handle to the server window. The client receiving the handle as the <em>wParam</em> parameter of the <strong>WM_DDE_ACK</strong> message then sends all subsequent DDE messages to the server window this handle identifies.</p>
<p>If your client application uses a <strong>NULL</strong> atom for the application name or topic name, expect the application to receive acknowledgments from more than one server application. Multiple acknowledgements can also come from multiple instances of a DDE server, even if your client application does not <strong>NULL</strong> use atoms. A server should always use a unique window for each conversation. The window procedure in the client application can use a handle to the server window (provided as the <em>lParam</em> parameter of <a href="wm-dde-initiate.html"><strong>WM_DDE_INITIATE</strong></a>) to track multiple conversations. This allows a single client window to process several conversations without needing to terminate and reconnect with a new client window for each conversation.</p>
<h2>Transferring a Single Item</h2>
<p>Once a DDE conversation has been established, the client can either retrieve the value of a data item from the server by issuing the <a href="wm-dde-request.html"><strong>WM_DDE_REQUEST</strong></a> message, or submit a data-item value to the server by issuing <a href="wm-dde-poke.html"><strong>WM_DDE_POKE</strong></a>.</p>
<ul>
<li><a href="#retrieving-an-item-from-the-server">Retrieving an Item from the Server</a></li>
<li><a href="#submitting-an-item-to-the-server">Submitting an Item to the Server</a></li>
</ul>
<h3>Retrieving an Item from the Server</h3>
<p>To retrieve an item from the server, the client sends the server a <a href="wm-dde-request.html"><strong>WM_DDE_REQUEST</strong></a> message specifying the item and format to retrieve, as shown in the following example.</p>
<pre><code>if ((atomItem = GlobalAddAtom(szItemName)) != 0) 
{ 
    if (!PostMessage(hwndServerDDE, 
            WM_DDE_REQUEST, 
            (WPARAM) hwndClientDDE, 
            PackDDElParam(WM_DDE_REQUEST, CF_TEXT, atomItem))) 
    {
        GlobalDeleteAtom(atomItem); 
    }
} 
 
if (atomItem == 0) 
{ 
    // Handle errors. 
}
</code></pre>
<p>In this example, the client specifies the clipboard format <strong>CF_TEXT</strong> as the preferred format for the requested data item.</p>
<p>The receiver (server) of the <a href="wm-dde-request.html"><strong>WM_DDE_REQUEST</strong></a> message typically must delete the item atom, but if the <a href="/windows/desktop/api/winuser/nf-winuser-postmessagea"><strong>PostMessage</strong></a> call fails, the client must delete the atom.</p>
<p>If the server has access to the requested item and can render it in the requested format, the server copies the item value as a shared memory object and sends the client a <a href="wm-dde-data.html"><strong>WM_DDE_DATA</strong></a> message, as illustrated in the following example.</p>
<pre><code>// Allocate the size of the DDE data header, plus the data: a 
// string,&lt;CR&gt;&lt;LF&gt;&lt;NULL&gt;. The byte for the string's terminating 
// null character is counted by DDEDATA.Value[1].

size_t* pcch;
HRESULT hResult;
 
hResult = StringCchLength(szItemValue,STRSAFE_MAX_CCH, pcch);
if (FAILED(hResult))
{
// TODO: Write error handler.
 return;
}
if (!(hData = GlobalAlloc(GMEM_MOVEABLE,
  (LONG) sizeof(DDEDATA) + *pcch + 2)))  
{
    return; 
}
 
if (!(lpData = (DDEDATA FAR*) GlobalLock(hData)))  
{
    GlobalFree(hData); 
    return; 
} 
 
lpData-&gt;cfFormat = CF_TEXT;
hResult = StringCchCopy((LPSTR) lpData-&gt;Value, *pcch +1, (LPCSTR) szItemValue); // copies value to be sent
if (FAILED(hResult))
{
// TODO: Write error handler.
 return;
}
 
// Each line of CF_TEXT data is terminated by CR/LF. 
hResult = StringCchCat((LPSTR) lpData-&gt;Value, *pcch + 3, (LPCSTR) &quot;\r\n&quot;);
if (FAILED(hResult)
{
// TODO: Write error handler.
 return;
} 
GlobalUnlock(hData); 
if ((atomItem = GlobalAddAtom((LPSTR) szItemName)) != 0) 
{ 
    lParam = PackDDElParam(WM_DDE_ACK, (UINT) hData, atomItem); 
    if (!PostMessage(hwndClientDDE, 
            WM_DDE_DATA, 
            (WPARAM) hwndServerDDE, 
            lParam)) 
    { 
        GlobalFree(hData); 
        GlobalDeleteAtom(atomItem); 
        FreeDDElParam(WM_DDE_ACK, lParam); 
    } 
} 
 
if (atomItem == 0) 
{ 
    // Handle errors.  
}
</code></pre>
<p>In this example, the server application allocates a memory object to contain the data item. The data object is initialized as a <a href="/windows/desktop/api/Dde/ns-dde-ddedata"><strong>DDEDATA</strong></a> structure.</p>
<p>The server application then sets the <strong>cfFormat</strong> member of the structure to CF_TEXT to inform the client application that the data is in text format. The client responds by copying the value of the requested data into the <strong>Value</strong> member of the <a href="/windows/desktop/api/Dde/ns-dde-ddedata"><strong>DDEDATA</strong></a> structure. After the server has filled the data object, the server unlocks the data and creates a global atom containing the name of the data item.</p>
<p>Finally, the server issues the <a href="wm-dde-data.html"><strong>WM_DDE_DATA</strong></a> message by calling <a href="/windows/desktop/api/winuser/nf-winuser-postmessagea"><strong>PostMessage</strong></a>. The handle to the data object and the atom containing the item name are packed into the <em>lParam</em> parameter of the message by the <a href="/windows/desktop/api/Dde/nf-dde-packddelparam"><strong>PackDDElParam</strong></a> function.</p>
<p>If <a href="/windows/desktop/api/winuser/nf-winuser-postmessagea"><strong>PostMessage</strong></a> fails, the server must use the <a href="/windows/desktop/api/Dde/nf-dde-freeddelparam"><strong>FreeDDElParam</strong></a> function to free the packed <em>lParam</em> parameter. The server must also free the packed <em>lParam</em> parameter for the <a href="wm-dde-request.html"><strong>WM_DDE_REQUEST</strong></a> message it received.</p>
<p>If the server cannot satisfy the request, it sends a negative <a href="wm-dde-ack.html"><strong>WM_DDE_ACK</strong></a> message to the client, as shown in the following example.</p>
<pre><code>// Negative acknowledgment. 
 
PostMessage(hwndClientDDE, 
    WM_DDE_ACK, 
    (WPARAM) hwndServerDDE, 
    PackDDElParam(WM_DDE_ACK, 0, atomItem));
</code></pre>
<p>Upon receiving a <a href="wm-dde-data.html"><strong>WM_DDE_DATA</strong></a> message, the client processes the data-item value as appropriate. Then, if the <strong>fAckReq</strong> member pointed to in the <strong>WM_DDE_DATA</strong> message is 1, the client must send the server a positive <a href="wm-dde-ack.html"><strong>WM_DDE_ACK</strong></a> message, as shown in the following example.</p>
<pre><code>UnpackDDElParam(WM_DDE_DATA, lParam, (PUINT) &amp;hData, 
    (PUINT) &amp;atomItem); 
if (!(lpDDEData = (DDEDATA FAR*) GlobalLock(hData)) 
        || (lpDDEData-&gt;cfFormat != CF_TEXT)) 
{ 
    PostMessage(hwndServerDDE, 
        WM_DDE_ACK, 
        (WPARAM) hwndClientDDE, 
        PackDDElParam(WM_DDE_ACK, 0, atomItem)); // Negative ACK. 
} 
 
// Copy data from lpDDEData here. 
 
if (lpDDEData-&gt;fAckReq) 
{ 
    PostMessage(hwndServerDDE, 
        WM_DDE_ACK, 
        (WPARAM) hwndClientDDE, 
        PackDDElParam(WM_DDE_ACK, 0x8000, 
            atomItem)); // Positive ACK 
} 
 
bRelease = lpDDEData-&gt;fRelease; 
GlobalUnlock(hData); 
if (bRelease) 
    GlobalFree(hData);
</code></pre>
<p>In this example, the client examines the format of the data. If the format is not <strong>CF_TEXT</strong> (or if the client cannot lock the memory for the data), the client sends a negative <a href="wm-dde-ack.html"><strong>WM_DDE_ACK</strong></a> message to indicate that it cannot process the data. If the client cannot lock a data handle because the handle contains the <strong>fAckReq</strong> member, the client should not send a negative <strong>WM_DDE_ACK</strong> message. Instead, the client should terminate the conversation.</p>
<p>If a client sends a negative acknowledgment in response to a <a href="wm-dde-data.html"><strong>WM_DDE_DATA</strong></a> message, the server is responsible for freeing the memory (but not the <em>lParam</em> parameter) referenced by the <strong>WM_DDE_DATA</strong> message associated with the negative acknowledgment.</p>
<p>If it can process the data, the client examines the <strong>fAckReq</strong> member of the <a href="/windows/desktop/api/Dde/ns-dde-ddedata"><strong>DDEDATA</strong></a> structure to determine whether the server requested that it be informed that the client received and processed the data successfully. If the server did request this information, the client sends the server a positive <a href="wm-dde-ack.html"><strong>WM_DDE_ACK</strong></a> message.</p>
<p>Because unlocking data invalidates the pointer to the data, the client saves the value of the <strong>fRelease</strong> member before unlocking the data object. After saving the value, the client then examines it to determine whether the server application requested the client to free the memory containing the data; the client acts accordingly.</p>
<p>Upon receiving a negative <a href="wm-dde-ack.html"><strong>WM_DDE_ACK</strong></a> message, the client can ask for the same item value again, specifying a different clipboard format. Typically, a client will first ask for the most complex format it can support, then step down if necessary through progressively simpler formats until it finds one the server can provide.</p>
<p>If the server supports the Formats item of the system topic, the client can determine once what clipboard formats the server supports, instead of determining them each time the client requests an item.</p>
<h3>Submitting an Item to the Server</h3>
<p>The client may send an item value to the server by using the <a href="wm-dde-poke.html"><strong>WM_DDE_POKE</strong></a> message. The client renders the item to be sent and sends the <strong>WM_DDE_POKE</strong> message, as illustrated in the following example.</p>
<pre><code>size_t* pcch;
HRESULT hResult;
 
hResult = StringCchLength(szValue,STRSAFE_MAX_CCH, pcch);
if (FAILED(hResult))
{
// TODO: Write error handler.
 return;
}
if (!(hPokeData = GlobalAlloc(GMEM_MOVEABLE,
  (LONG) sizeof(DDEPOKE) + *pcch + 2))) 
{
    return; 
}
 
if (!(lpPokeData = (DDEPOKE *) GlobalLock(hPokeData))) 
{ 
    GlobalFree(hPokeData); 
    return; 
} 
 
lpPokeData-&gt;fRelease = TRUE; 
lpPokeData-&gt;cfFormat = CF_TEXT;
hResult = StringCchCopy((LPSTR) lpPokeData-&gt;Value, *pcch +1, (LPCSTR) szValue); // copies value to be sent
if (FAILED(hResult))
{
// TODO: Write error handler.
 return;
}  
 
// Each line of CF_TEXT data is terminated by CR/LF. 
hResult = StringCchCat((LPSTR) lpPokeData-&gt;Value, *pcch + 3, (LPCSTR) &quot;\r\n&quot;);
if (FAILED(hResult)
{
// TODO: Write error handler.
 return;
}
GlobalUnlock(hPokeData); 
if ((atomItem = GlobalAddAtom((LPSTR) szItem)) != 0) 
{ 
 
        if (!PostMessage(hwndServerDDE, 
                WM_DDE_POKE, 
                (WPARAM) hwndClientDDE, 
                PackDDElParam(WM_DDE_POKE, (UINT) hPokeData, 
                    atomItem))) 
        { 
            GlobalDeleteAtom(atomItem); 
            GlobalFree(hPokeData); 
        } 
} 
 
if (atomItem == 0) 
{ 
    // Handle errors. 
} 
</code></pre>
<blockquote>
<p>[!Note]<br />
Sending data by using a <a href="wm-dde-poke.html"><strong>WM_DDE_POKE</strong></a> message is essentially the same as sending it by using <a href="wm-dde-data.html"><strong>WM_DDE_DATA</strong></a>, except that <strong>WM_DDE_POKE</strong> is sent from the client to the server.</p>
</blockquote>
<p>Â </p>
<p>If the server is able to accept the data-item value in the format rendered by the client, the server processes the item value as appropriate and sends the client a positive <a href="wm-dde-ack.html"><strong>WM_DDE_ACK</strong></a> message. If it is unable to process the item value, because of its format or for other reasons, the server sends the client a negative <strong>WM_DDE_ACK</strong> message.</p>
<pre><code>UnpackDDElParam(WM_DDE_POKE, lParam, (PUINT) &amp;hPokeData, 
    (PUINT) &amp;atomItem); 
GlobalGetAtomName(atomItem, szItemName, ITEM_NAME_MAX_SIZE); 
if (!(lpPokeData = (DDEPOKE *) GlobalLock(hPokeData)) 
        || lpPokeData-&gt;cfFormat != CF_TEXT 
        || !IsItemSupportedByServer(szItemName)) 
{ 
    PostMessage(hwndClientDDE, 
        WM_DDE_ACK, 
        (WPARAM) hwndServerDDE, 
        PackDDElParam(WM_DDE_ACK, 0, atomItem)); // negative ACK  
}
hResult = StringCchLength(szItemValue,STRSAFE_MAX_CCH, pcch);
if (FAILED(hResult))
{
// TODO: Write error handler.
 return;
} 
hResult = StringCchCopy(szItemValue, *pcch +1, lpPokeData-&gt;Value); // copies value 
if (FAILED(hResult))
{
// TODO: Write error handler.
 return;
}  
bRelease = lpPokeData-&gt;fRelease; 
GlobalUnlock(hPokeData); 
if (bRelease) 
{ 
    GlobalFree(hPokeData); 
} 
 
PostMessage(hwndClientDDE, 
    WM_DDE_ACK, 
    (WPARAM) hwndServerDDE, 
    PackDDElParam(WM_DDE_ACK, 
         0x8000, atomItem));    // positive ACK.
</code></pre>
<p>In this example, the server calls <a href="/windows/desktop/api/Winbase/nf-winbase-globalgetatomnamea"><strong>GlobalGetAtomName</strong></a> to retrieve the name of the item the client sent. The server then determines whether it supports the item and whether the item is rendered in the correct format (that is, CF_TEXT). If the item is not supported and not rendered in the correct format, or if the server cannot lock the memory for the data, the server sends a negative acknowledgment back to the client application. Note that in this case, sending a negative acknowledgment is correct because <a href="wm-dde-poke.html"><strong>WM_DDE_POKE</strong></a> messages are always assumed to have the <strong>fAckReq</strong> member set. The server should ignore the member.</p>
<p>If a server sends a negative acknowledgment in response to a <a href="wm-dde-poke.html"><strong>WM_DDE_POKE</strong></a> message, the client is responsible for freeing the memory (but not the <em>lParam</em> parameter) referenced by the <strong>WM_DDE_POKE</strong> message associated with the negative acknowledgment.</p>
<h2>Establishing a Permanent Data Link</h2>
<p>A client application can use DDE to establish a link to an item in a server application. After such a link is established, the server sends periodic updates of the linked item to the client, typically, whenever the value of the item changes. Thus, a permanent data stream is established between the two applications; this data stream remains in place until it is explicitly disconnected.</p>
<h3>Initiating a Data Link</h3>
<p>The client initiates a data link by posting a <a href="wm-dde-advise.html"><strong>WM_DDE_ADVISE</strong></a> message, as shown in the following example.</p>
<pre><code>if (!(hOptions = GlobalAlloc(GMEM_MOVEABLE, 
        sizeof(DDEADVISE)))) 
    return; 
if (!(lpOptions = (DDEADVISE FAR*) GlobalLock(hOptions))) 
{ 
    GlobalFree(hOptions); 
    return; 
} 
 
lpOptions-&gt;cfFormat = CF_TEXT; 
lpOptions-&gt;fAckReq = TRUE; 
lpOptions-&gt;fDeferUpd = FALSE; 
GlobalUnlock(hOptions); 
if ((atomItem = GlobalAddAtom(szItemName)) != 0) 
{ 
    if (!(PostMessage(hwndServerDDE, 
            WM_DDE_ADVISE, 
            (WPARAM) hwndClientDDE, 
            PackDDElParam(WM_DDE_ADVISE, (UINT) hOptions, 
                atomItem)))) 
    { 
        GlobalDeleteAtom(atomItem); 
        GlobalFree(hOptions); 
        FreeDDElParam(WM_DDE_ADVISE, lParam); 
    } 
} 
 
if (atomItem == 0) 
{ 
    // Handle errors 
 
}
</code></pre>
<p>In this example, the client application sets the <strong>fDeferUpd</strong> flag of the <a href="wm-dde-advise.html"><strong>WM_DDE_ADVISE</strong></a> message to <strong>FALSE</strong>. This directs the server application to send the data to the client whenever the data changes.</p>
<p>If the server is unable to service the <a href="wm-dde-advise.html"><strong>WM_DDE_ADVISE</strong></a> request, it sends the client a negative <a href="wm-dde-ack.html"><strong>WM_DDE_ACK</strong></a> message. But if the server has access to the item and can render it in the requested format, the server notes the new link (recalling the flags specified in the <em>hOptions</em> parameter) and sends the client a positive <strong>WM_DDE_ACK</strong> message. From then on, until the client issues a matching <a href="wm-dde-unadvise.html"><strong>WM_DDE_UNADVISE</strong></a> message, the server sends the new data to the client every time the value of the item changes in the server.</p>
<p>The <a href="wm-dde-advise.html"><strong>WM_DDE_ADVISE</strong></a> message establishes the format of the data to be exchanged during the link. If the client attempts to establish another link with the same item but is using a different data format, the server can choose to reject the second data format or attempt to support it. If a warm link has been established for any data item, the server can support only one data format at a time. This is because the <a href="wm-dde-data.html"><strong>WM_DDE_DATA</strong></a> message for a warm link has a <strong>NULL</strong> data handle, which otherwise contains the format information. Thus, a server must reject all warm links for an item already linked, and must reject all links for an item that has warm links. Another interpretation may be that the server changes the format and the hot or warm state of a link when a second link is requested for the same data item.</p>
<p>In general, client applications should not attempt to establish more than one link at a time for a data item.</p>
<h3>Initiating a Data Link with the Paste Link Command</h3>
<p>Applications that support hot or warm data links typically support a registered clipboard format named Link. When associated with the application's Copy and Paste Link commands, this clipboard format enables the user to establish DDE conversations between applications simply by copying a data item in the server application and pasting it into the client application.</p>
<p>A server application supports the Link clipboard format by placing in the clipboard a string containing the application, topic, and item names when the user chooses the <strong>Copy</strong> command from the <strong>Edit</strong> menu. Following is the standard Link format:</p>
<p><em>application</em>**\0<em><strong>topic</strong></em>\0<em><strong>item</strong></em>\0\0**</p>
<p>A single null character separates the names, and two null characters terminate the entire string.</p>
<p>Both the client and server applications must register the Link clipboard format, as shown:</p>
<pre><code>cfLink = RegisterClipboardFormat(&quot;Link&quot;);
</code></pre>
<p>A client application supports the Link clipboard format by means of a Paste Link command on its Edit menu. When the user chooses this command, the client application parses the application, topic, and item names from the Link-format clipboard data. Using these names, the client application initiates a conversation for the application and topic, if such a conversation does not already exist. The client application then sends a <a href="wm-dde-advise.html"><strong>WM_DDE_ADVISE</strong></a> message to the server application, specifying the item name contained in the Link-format clipboard data.</p>
<p>Following is an example of a client application's response when the user chooses the Paste Link command.</p>
<pre><code>void DoPasteLink(hwndClientDDE) 
HWND hwndClientDDE; 
{ 
    HANDLE hData; 
    LPSTR lpData; 
    HWND hwndServerDDE; 
    CHAR szApplication[APP_MAX_SIZE + 1]; 
    CHAR szTopic[TOPIC_MAX_SIZE + 1]; 
    CHAR szItem[ITEM_MAX_SIZE + 1]; 
    size_t * nBufLen; 
 HRESULT hResult;
 
    if (OpenClipboard(hwndClientDDE)) 
    { 
        if (!(hData = GetClipboardData(cfLink)) || 
                !(lpData = GlobalLock(hData))) 
        { 
            CloseClipboard(); 
            return; 
        } 
 
        // Parse the clipboard data.
  hResult = StringCchLength(lpData, STRSAFE_MAX_CCH, nBufLen);
 if (FAILED(hResult) || nBufLen == NULL)
 {
// TODO: Write error handler.
  return;
 }
 if (*nBufLen &gt;= APP_MAX_SIZE)
        { 
            CloseClipboard(); 
            GlobalUnlock(hData); 
            return; 
        }
 hResult = StringCchCopy(szApplication, APP_MAX_SIZE +1, lpData);
 if (FAILED(hResult)
 {
// TODO: Write error handler.
  return;
 }
        lpData += (*nBufLen + 1); // skips over null
 hResult = StringCchLength(lpData, STRSAFE_MAX_CCH, nBufLen);
 if (FAILED(hResult) || nBufLen == NULL)
 {
 // TODO: Write error handler.
  return;
 }
 if (*nBufLen &gt;= TOPIC_MAX_SIZE)
        { 
            CloseClipboard(); 
            GlobalUnlock(hData); 
            return; 
        }
 hResult = StringCchCopy(szTopic, TOPIC_MAX_SIZE +1, lpData);
 if (FAILED(hResult)
 {
 // TODO: Write error handler.
  return;
 }
        lpData += (nBufLen + 1); // skips over null
 hResult = StringCchLength(lpData, STRSAFE_MAX_CCH, nBufLen);
 if (FAILED(hResult) || nBufLen == NULL)
 {
 // TODO: Write error handler.
  return;
 }
 if (*nBufLen &gt;= ITEM_MAX_SIZE)
        { 
            CloseClipboard(); 
            GlobalUnlock(hData); 
            return; 
        }

 hResult = StringCchCopy(szItem, ITEM_MAX_SIZE +1, lpData);
 if (FAILED(hResult)
 {
 // TODO: Write error handler.
  return;
 } 
        GlobalUnlock(hData); 
        CloseClipboard(); 
 
        if (hwndServerDDE = 
                FindServerGivenAppTopic(szApplication, szTopic)) 
        { 
            // App/topic conversation is already started. 
 
            if (DoesAdviseAlreadyExist(hwndServerDDE, szItem)) 
            {
                MessageBox(hwndMain, 
                    &quot;Advisory already established&quot;, 
                    &quot;Client&quot;, MB_ICONEXCLAMATION | MB_OK); 
            }
            else SendAdvise(hwndClientDDE, hwndServerDDE, szItem); 
        } 
        else 
        { 
            // Client must initiate a new conversation first. 
            SendInitiate(szApplication, szTopic); 
            if (hwndServerDDE = 
                    FindServerGivenAppTopic(szApplication, 
                        szTopic)) 
            {
                SendAdvise(hwndClientDDE, hwndServerDDE, szItem); 
            }
        } 
    } 
    return; 
}
</code></pre>
<p>In this example, the client application opens the clipboard and determines whether it contains data in the Link format (that is, cfLink) it had previously registered. If not, or if it cannot lock the data in the clipboard, the client returns.</p>
<p>After the client application retrieves a pointer to the clipboard data, it parses the data to extract the application, topic, and item names.</p>
<p>The client application determines whether a conversation on the topic already exists between it and the server application. If a conversation does exist, the client checks whether a link already exists for the data item. If such a link exists, the client displays a message box to the user; otherwise, it calls its own <em>SendAdvise</em> function to send a <a href="wm-dde-advise.html"><strong>WM_DDE_ADVISE</strong></a> message to the server for the item.</p>
<p>If a conversation on the topic does not already exist between the client and the server, the client first calls its own <em>SendInitiate</em> function to broadcast the <a href="wm-dde-initiate.html"><strong>WM_DDE_INITIATE</strong></a> message to request a conversation and, second, calls its own <em>FindServerGivenAppTopic</em> function to establish the conversation with the window that responds on behalf of the server application. After the conversation has begun, the client application calls <em>SendAdvise</em> to request the link.</p>
<h3>Notifying the Client that Data Has Changed</h3>
<p>When the client establishes a link by using the <a href="wm-dde-advise.html"><strong>WM_DDE_ADVISE</strong></a> message, with the <strong>fDeferUpd</strong> member not set (that is, equal to zero) in the <a href="/windows/desktop/api/Dde/ns-dde-ddedata"><strong>DDEDATA</strong></a> structure, the client has requested the server send the data item each time the item's value changes. In such cases, the server renders the new value of the data item in the previously specified format and sends the client a <a href="wm-dde-data.html"><strong>WM_DDE_DATA</strong></a> message, as shown in the following example.</p>
<pre><code>// Allocate the size of a DDE data header, plus data (a string), 
// plus a &lt;CR&gt;&lt;LF&gt;&lt;NULL&gt; 

size_t* pcch;
HRESULT hResult;
 
hResult = StringCchLength(szItemValue,STRSAFE_MAX_CCH, pcch);
if (FAILED(hResult))
{
// TODO: Write error handler.
 return;
}
if (!(hData = GlobalAlloc(GMEM_MOVEABLE,
  sizeof(DDEDATA) + *pcch + 3))) 
{
    return; 
}
if (!(lpData = (DDEDATA FAR*) GlobalLock(hData))) 
{ 
    GlobalFree(hData); 
    return; 
} 
lpData-&gt;fAckReq = bAckRequest;       // as in original WM_DDE_ADVISE 
lpData-&gt;cfFormat = CF_TEXT;
hResult = StringCchCopy(lpData-&gt;Value, *pcch +1, szItemValue); // copies value to be sent
if (FAILED(hResult))
{
// TODO: Write error handler.
 return;
}
// add CR/LF for CF_TEXT format
hResult = StringCchCat(lpData-&gt;Value, *pcch + 3, &quot;\r\n&quot;);
if (FAILED(hResult))
{
// TODO: Write error handler.
 return;
}
GlobalUnlock(hData); 
if ((atomItem = GlobalAddAtom(szItemName)) != 0) 
{ 
    if (!PostMessage(hwndClientDDE, 
            WM_DDE_DATA, 
            (WPARAM) hwndServerDDE, 
            PackDDElParam(WM_DDE_DATA, (UINT) hData, atomItem))) 
    { 
        GlobalFree(hData); 
        GlobalDeleteAtom(atomItem); 
        FreeDDElParam(WM_DDE_DATA, lParam); 
    } 
} 
 
if (atomItem == 0) 
{ 
    // Handle errors. 
 
}
</code></pre>
<p>In this example, the client processes the item value as appropriate. If the <strong>fAckReq</strong> flag for the item is set, the client sends the server a positive <a href="wm-dde-ack.html"><strong>WM_DDE_ACK</strong></a> message.</p>
<p>When the client establishes the link, with the <strong>fDeferUpd</strong> member set (that is, equal to 1), the client has requested that only a notification, not the data itself, be sent each time the data changes. In such cases, when the item value changes, the server does not render the value but simply sends the client a <a href="wm-dde-data.html"><strong>WM_DDE_DATA</strong></a> message with a null data handle, as illustrated in the following example.</p>
<pre><code>if (bDeferUpd)      // check whether flag was set in WM_DDE_ADVISE
{
    if ((atomItem = GlobalAddAtom(szItemName)) != 0) 
    { 
        if (!PostMessage(hwndClientDDE, 
                WM_DDE_DATA, 
                (WPARAM) hwndServerDDE, 
                PackDDElParam(WM_DDE_DATA, 0, 
                    atomItem)))                  // NULL data
        {
            GlobalDeleteAtom(atomItem); 
            FreeDDElParam(WM_DDE_DATA, lParam); 
        } 
    } 
} 
 
if (atomItem == 0) 
{ 
     // Handle errors. 
} 
</code></pre>
<p>As necessary, the client can request the latest value of the data item by issuing a normal <a href="wm-dde-request.html"><strong>WM_DDE_REQUEST</strong></a> message, or it can simply ignore the notice from the server that the data has changed. In either case, if <strong>fAckReq</strong> is equal to 1, the client is expected to send a positive <a href="wm-dde-ack.html"><strong>WM_DDE_ACK</strong></a> message to the server.</p>
<h3>Terminating a Data Link</h3>
<p>If the client requests that a specific data link be terminated, the client sends the server a <a href="wm-dde-unadvise.html"><strong>WM_DDE_UNADVISE</strong></a> message, as shown in the following example.</p>
<pre><code>if ((atomItem = GlobalAddAtom(szItemName)) != 0) 
{ 
    if (!PostMessage(hwndServerDDE, 
            WM_DDE_UNADVISE, 
            (WPARAM) hwndClientDDE, 
            PackDDElParam(WM_DDE_UNADVISE, 0, atomItem))) 
    { 
        GlobalDeleteAtom(atomItem); 
        FreeDDElParam(WM_DDE_UNADVISE, lParam); 
    } 
} 
 
if (atomItem == 0) 
{ 
    // Handle errors. 
}
</code></pre>
<p>The server checks whether the client currently has a link to the specific item in this conversation. If a link exists, the server sends the client a positive <a href="wm-dde-ack.html"><strong>WM_DDE_ACK</strong></a> message; the server is then no longer required to send updates about the item. If no link exists, the server sends the client a negative <strong>WM_DDE_ACK</strong> message.</p>
<p>The <a href="wm-dde-unadvise.html"><strong>WM_DDE_UNADVISE</strong></a> message specifies a data format. A format of zero informs the server to stop all links for the specified item, even if several hot links are established and each uses a different format.</p>
<p>To terminate all links for a conversation, the client application sends the server a <a href="wm-dde-unadvise.html"><strong>WM_DDE_UNADVISE</strong></a> message with a null item atom. The server determines whether the conversation has at least one link currently established. If a link exists, the server sends the client a positive <a href="wm-dde-ack.html"><strong>WM_DDE_ACK</strong></a> message; the server then no longer has to send any updates in the conversation. If no link exists, the server sends the client a negative <strong>WM_DDE_ACK</strong> message.</p>
<h2>Carrying Out Commands in a Server Application</h2>
<p>Applications can use the <a href="wm-dde-execute.html"><strong>WM_DDE_EXECUTE</strong></a> message to cause a certain command or series of commands to be carried out in another application. To do this, the client sends the server a <strong>WM_DDE_EXECUTE</strong> message containing a handle to a command string, as shown in the following example.</p>
<pre><code>HRESULT hResult;
  
if (!(hCommand = GlobalAlloc(GMEM_MOVEABLE, 
        sizeof(szCommandString) + 1))) 
{
    return; 
}
if (!(lpCommand = GlobalLock(hCommand))) 
{ 
    GlobalFree(hCommand); 
    return; 
} 

hResult = StringCbCopy(lpCommand, sizeof(szCommandString), szCommandString);
if (hResult != S_OK)
{
// TODO: Write error handler.
 return;
}
 
GlobalUnlock(hCommand); 
if (!PostMessage(hwndServerDDE, 
        WM_DDE_EXECUTE, 
        (WPARAM) hwndClientDDE, 
        PackDDElParam(WM_DDE_EXECUTE, 0, (UINT) hCommand))) 
{ 
    GlobalFree(hCommand); 
    FreeDDElParam(WM_DDE_EXECUTE, lParam); 
}
</code></pre>
<p>In this example, the server attempts to carry out the specified command string. If it succeeds, the server sends the client a positive <a href="wm-dde-ack.html"><strong>WM_DDE_ACK</strong></a> message; otherwise, it sends a negative <strong>WM_DDE_ACK</strong> message. This <strong>WM_DDE_ACK</strong> message reuses the <em>hCommand</em> handle passed in the original <a href="wm-dde-execute.html"><strong>WM_DDE_EXECUTE</strong></a> message.</p>
<p>If the client's command execution string requests that the server terminate, the server should respond by sending a positive <a href="wm-dde-ack.html"><strong>WM_DDE_ACK</strong></a> message and then post a <a href="wm-dde-terminate.html"><strong>WM_DDE_TERMINATE</strong></a> message before terminating. All other commands sent with a <a href="wm-dde-execute.html"><strong>WM_DDE_EXECUTE</strong></a> message should be executed synchronously; that is, the server should send a <strong>WM_DDE_ACK</strong> message only after successfully completing the command.</p>
<h2>Terminating a Conversation</h2>
<p>Either the client or the server can issue a <a href="wm-dde-terminate.html"><strong>WM_DDE_TERMINATE</strong></a> message to terminate a conversation at any time. Similarly, both the client and server applications should be prepared to receive this message at any time. An application must terminate all of its conversations before shutting down.</p>
<p>In the following example, the application terminating the conversation posts a <a href="wm-dde-terminate.html"><strong>WM_DDE_TERMINATE</strong></a> message.</p>
<pre><code>PostMessage(hwndServerDDE, WM_DDE_TERMINATE, 
    (WPARAM) hwndClientDDE, 0);
</code></pre>
<p>This informs the other application that the sending application will send no further messages and the recipient can close its window. The recipient is expected in all cases to respond promptly by sending a <a href="wm-dde-terminate.html"><strong>WM_DDE_TERMINATE</strong></a> message. The recipient must not send a negative, busy, or positive <a href="wm-dde-ack.html"><strong>WM_DDE_ACK</strong></a> message.</p>
<p>After an application has sent the <a href="wm-dde-terminate.html"><strong>WM_DDE_TERMINATE</strong></a> message to the partner in a DDE conversation, it must not respond to messages from that partner, since the partner might have destroyed the window to which the response would be sent.</p>
<p>If an application receives a DDE message other than <a href="wm-dde-terminate.html"><strong>WM_DDE_TERMINATE</strong></a> after it has posted <strong>WM_DDE_TERMINATE</strong>, it should free all objects associated with the received messages except the data handles for <a href="wm-dde-data.html"><strong>WM_DDE_DATA</strong></a> or <a href="wm-dde-poke.html"><strong>WM_DDE_POKE</strong></a> messages that do <strong>not</strong> have the <strong>fRelease</strong> member set.</p>
<p>When an application is about to terminate, it should end all active DDE conversations before completing processing of the <a href="/windows/desktop/winmsg/wm-destroy"><strong>WM_DESTROY</strong></a> message. However, if an application does not end its active DDE conversations, the system will terminate any DDE conversations associated with a window when the window is destroyed. The following example shows how a server application terminates all DDE conversations.</p>
<pre><code>void TerminateConversations(hwndServerDDE) 
HWND hwndServerDDE; 
{ 
    HWND hwndClientDDE; 
 
    // Terminate each active conversation. 
 
    while (hwndClientDDE = GetNextLink(hwndClientDDE)) 
    { 
        SendTerminate(hwndServerDDE, hwndClientDDE); 
    } 
    return; 
} 
 
BOOL AtLeastOneLinkActive(VOID) 
{ 
    return TRUE; 
} 
 
HWND GetNextLink(hwndDummy) 
    HWND hwndDummy; 
{ 
    return (HWND) 1; 
} 
 
VOID SendTerminate(HWND hwndServerDDE, HWND hwndClientDDE) 
{ 
    return; 
}
</code></pre>
<p>Â </p>
<p>Â </p>
</body>
