<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>glReadPixels function</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<p>title: glReadPixels function (Gl.h)
description: The glReadPixels function reads a block of pixels from the framebuffer.
ms.assetid: 41fbad5c-b8ca-456d-bbfc-b48c176e15b0
keywords:</p>
<ul>
<li>glReadPixels function OpenGL
topic_type:</li>
<li>apiref
api_name:</li>
<li>glReadPixels
api_location:</li>
<li>opengl32.dll
api_type:</li>
<li>DllExport
ms.topic: reference
ms.date: 05/31/2018</li>
</ul>
<hr />
<h1>glReadPixels function</h1>
<p>The <strong>glReadPixels</strong> function reads a block of pixels from the framebuffer.</p>
<h2>Syntax</h2>
<pre lang="C++"><code>void WINAPI glReadPixels(
   GLint   x,
   GLint   y,
   GLsizei width,
   GLsizei height,
   GLenum  format,
   GLenum  type,
   GLvoid  *pixels
);
</code></pre>
<h2>Parameters</h2>
<!-- raw HTML omitted -->
<p><em>x</em></p>
<!-- raw HTML omitted -->
<p>The window <em>x</em> coordinate of the first pixel that is read from the framebuffer. Together with the <em>y</em> coordinate, specifies the location of the lower-left corner of a rectangular block of pixels.</p>
<!-- raw HTML omitted -->
<p><em>y</em></p>
<!-- raw HTML omitted -->
<p>The window <em>y</em> coordinates of the first pixel that is read from the framebuffer. Together with the <em>x</em> coordinate, specifies the location of the lower-left corner of a rectangular block of pixels.</p>
<!-- raw HTML omitted -->
<p><em>width</em></p>
<!-- raw HTML omitted -->
<p>The width of the pixel rectangle.</p>
<!-- raw HTML omitted -->
<p><em>height</em></p>
<!-- raw HTML omitted -->
<p>The height of the pixel rectangle. <em>Width</em> and <em>height</em> parameters of value &quot;1&quot; correspond to a single pixel.</p>
<!-- raw HTML omitted -->
<p><em>format</em></p>
<!-- raw HTML omitted -->
<p>The format of the pixel data. The following symbolic values are accepted:</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><strong>GL_COLOR_INDEX</strong><!-- raw HTML omitted --> <!-- raw HTML omitted --></td>
<td>Color indexes are read from the color buffer selected by <a href="glreadbuffer.html"><strong>glReadBuffer</strong></a>. Each index is converted to fixed point, shifted left or right, depending on the value and sign of GL_INDEX_SHIFT, and added to GL_INDEX_OFFSET. If GL_MAP_COLOR is GL_TRUE, indexes are replaced by their mappings in the table GL_PIXEL_MAP_I_TO_I.<!-- raw HTML omitted --></td>
</tr>
<tr>
<td><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><strong>GL_STENCIL_INDEX</strong><!-- raw HTML omitted --> <!-- raw HTML omitted --></td>
<td>Stencil values are read from the stencil buffer. Each index is converted to fixed point, shifted left or right, depending on the value and sign of GL_INDEX_SHIFT, and added to GL_INDEX_OFFSET. If GL_MAP_STENCIL is GL_TRUE, indexes are replaced by their mappings in the table GL_PIXEL_MAP_S_TO_S.<!-- raw HTML omitted --></td>
</tr>
<tr>
<td><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><strong>GL_DEPTH_COMPONENT</strong><!-- raw HTML omitted --> <!-- raw HTML omitted --></td>
<td>Depth values are read from the depth buffer. Each component is converted to floating point such that the minimum depth value maps to 0.0 and the maximum value maps to 1.0. Each component is then multiplied by GL_DEPTH_SCALE, added to GL_DEPTH_BIAS, and finally clamped to the range [0,1].<!-- raw HTML omitted --></td>
</tr>
<tr>
<td><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --> <!-- raw HTML omitted --><strong>GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_RGBA, GL_BGR_EXT, GL_BGRA_EXT, GL_LUMINANCE, GL_LUMINANCE_ALPHA</strong><!-- raw HTML omitted --> <!-- raw HTML omitted --></td>
<td>Processing differs depending on whether color buffers store color indexes or RGBA color components. If color indexes are stored, they are read from the color buffer selected by <a href="glreadbuffer.html"><strong>glReadBuffer</strong></a>. Each index is converted to fixed point, shifted left or right, depending on the value and sign of GL_INDEX_SHIFT, and added to GL_INDEX_OFFSET. Indexes are then replaced by the red, green, blue, and alpha values obtained by indexing the GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, and GL_PIXEL_MAP_I_TO_A tables. If RGBA color components are stored in the color buffers, they are read from the color buffer selected by <strong>glReadBuffer</strong>. Each color component is converted to floating point such that zero intensity maps to 0.0 and full intensity maps to 1.0. Each component is then multiplied by GL_c_SCALE and added to GL_c_BIAS, where c is GL_RED, GL_GREEN, GL_BLUE, and GL_ALPHA. Each component is clamped to the range [0,1]. Finally, if GL_MAP_COLOR is GL_TRUE, each color component c is replaced by its mapping in the table GL_PIXEL_MAP_c_TO_c, where c again is GL_RED, GL_GREEN, GL_BLUE, and GL_ALPHA. Each component is scaled to the size of its corresponding table before the lookup is performed. Finally, unneeded data is discarded. For example, GL_RED discards the green, blue, and alpha components, while GL_RGB discards only the alpha component. GL_LUMINANCE computes a single component value as the sum of the red, green, and blue components, and GL_LUMINANCE_ALPHA does the same, while keeping alpha as a second value.<!-- raw HTML omitted --></td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<p><em>type</em></p>
<!-- raw HTML omitted -->
<p>The data type of the pixel data. Must be one of the following values.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Index mask</th>
<th>Component conversion</th>
</tr>
</thead>
<tbody>
<tr>
<td>GL_UNSIGNED_BYTE</td>
<td>281</td>
<td>(281)<em>c</em></td>
</tr>
<tr>
<td>GL_BYTE</td>
<td>271</td>
<td>[(271)<em>c</em>-1]/2</td>
</tr>
<tr>
<td>GL_BITMAP</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>GL_UNSIGNED_SHORT</td>
<td>2 61</td>
<td>(2 61)<em>c</em></td>
</tr>
<tr>
<td>GL_SHORT</td>
<td>2 51</td>
<td>[(2 51)<em>c</em>1]/2</td>
</tr>
<tr>
<td>GL_UNSIGNED_INT_</td>
<td>2  1</td>
<td>(2  1)<em>c</em></td>
</tr>
<tr>
<td>GL_INT</td>
<td>2   1</td>
<td>[(2  1)<em>c</em>1]/2</td>
</tr>
<tr>
<td>GL_FLOAT</td>
<td>none</td>
<td><em>c</em></td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<p><em>pixels</em></p>
<!-- raw HTML omitted -->
<p>Returns the pixel data.</p>
<!-- raw HTML omitted -->
<h2>Return value</h2>
<p>This function does not return a value.</p>
<h2>Error codes</h2>
<p>The following error codes can be retrieved by the <a href="glgeterror.html"><strong>glGetError</strong></a> function.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><!-- raw HTML omitted --> <!-- raw HTML omitted --><strong>GL_INVALID_ENUM</strong><!-- raw HTML omitted --> <!-- raw HTML omitted --></td>
<td><em>format</em> or <em>type</em> was not an accepted value.<!-- raw HTML omitted --></td>
</tr>
<tr>
<td><!-- raw HTML omitted --> <!-- raw HTML omitted --><strong>GL_INVALID_VALUE</strong><!-- raw HTML omitted --> <!-- raw HTML omitted --></td>
<td>Either <em>width</em> or <em>height</em> was negative.<!-- raw HTML omitted --></td>
</tr>
<tr>
<td><!-- raw HTML omitted --> <!-- raw HTML omitted --><strong>GL_INVALID_OPERATION</strong><!-- raw HTML omitted --> <!-- raw HTML omitted --></td>
<td><em>format</em> was GL_COLOR_INDEX, and the color buffers stored RGBA or BGRA color components.<!-- raw HTML omitted --></td>
</tr>
<tr>
<td><!-- raw HTML omitted --> <!-- raw HTML omitted --><strong>GL_INVALID_OPERATION</strong><!-- raw HTML omitted --> <!-- raw HTML omitted --></td>
<td><em>format</em> was GL_STENCIL_INDEX, and there was no stencil buffer.<!-- raw HTML omitted --></td>
</tr>
<tr>
<td><!-- raw HTML omitted --> <!-- raw HTML omitted --><strong>GL_INVALID_OPERATION</strong><!-- raw HTML omitted --> <!-- raw HTML omitted --></td>
<td><em>format</em> was GL_DEPTH_COMPONENT, and there was no depth buffer.<!-- raw HTML omitted --></td>
</tr>
<tr>
<td><!-- raw HTML omitted --> <!-- raw HTML omitted --><strong>GL_INVALID_OPERATION</strong><!-- raw HTML omitted --> <!-- raw HTML omitted --></td>
<td>The function was called between a call to <a href="glbegin.html"><strong>glBegin</strong></a> and the corresponding call to <a href="glend.html"><strong>glEnd</strong></a>.<!-- raw HTML omitted --></td>
</tr>
</tbody>
</table>
<h2>Remarks</h2>
<p>The <strong>glReadPixels</strong> function returns pixel data from the framebuffer, starting with the pixel whose lower-left corner is at location (<em>x</em>, <em>y</em>), into client memory starting at location <em>pixels</em>. Several parameters control the processing of the pixel data before it is placed into client memory. These parameters are set with three commands: <a href="glpixelstore-functions.html"><strong>glPixelStore</strong></a>, <a href="glpixeltransfer.html"><strong>glPixelTransfer</strong></a>, and <a href="glpixelmap.html"><strong>glPixelMap</strong></a>. This topic describes the effects on <strong>glReadPixels</strong> of most, but not all of the parameters specified by these three commands.</p>
<p>The <strong>glReadPixels</strong> function returns values from each pixel with lower-left corner at (<em>x</em> + i, <em>y</em> + j) for 0 = i &lt; <em>width</em> and 0 = j &lt; <em>height</em>. This pixel is said to be the <em>i</em>th pixel in the <em>j</em>th row. Pixels are returned in row order from the lowest to the highest row, left to right in each row.</p>
<p>The shift, scale, bias, and lookup factors described above are all specified by <a href="glpixeltransfer.html"><strong>glPixelTransfer</strong></a>. The lookup table contents are specified by <a href="glpixelmap.html"><strong>glPixelMap</strong></a>.</p>
<p>The final step involves converting the indexes or components to the proper format, as specified by <em>type</em>. If <em>format</em> is GL_COLOR_INDEX or GL_STENCIL_INDEX and <em>type</em> is not GL_FLOAT, each index is masked with the mask value given in the following table. If <em>type</em> is GL_FLOAT, then each integer index is converted to single-precision floating-point format.</p>
<p>If <em>format</em> is GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_RGBA, GL_BGR_EXT, GL_BGRA_EXT, GL_LUMINANCE, or GL_LUMINANCE_ALPHA and <em>type</em> is not GL_FLOAT, each component is multiplied by the multiplier shown in the preceding table. If type is GL_FLOAT, then each component is passed as is (or converted to the client's single-precision floating-point format if it is different from the one used by OpenGL).</p>
<p>Return values are placed in memory as follows. If <em>format</em> is GL_COLOR_INDEX, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, or GL_LUMINANCE, a single value is returned and the data for the <em>i</em>th pixel in the <em>j</em>th row is placed in location (<em>j</em> )<em>width</em> + <em>i</em>. GL_RGB and GL_BGR_EXT return three values, GL_RGBA and GL_BGRA_EXT return four values, and GL_LUMINANCE_ALPHA returns two values for each pixel, with all values corresponding to a single pixel occupying contiguous space in <em>pixels</em>. Storage parameters set by <a href="glpixelstore-functions.html"><strong>glPixelStore</strong></a>, such as GL_PACK_SWAP_BYTES and GL_PACK_LSB_FIRST, affect the way that data is written into memory. See <a href="glpixelstore-functions.html"><strong>glPixelStore</strong></a> for a description.</p>
<p>Values for pixels that lie outside the window connected to the current OpenGL context are undefined.</p>
<p>If an error is generated, no change is made to the contents of <em>pixels</em>.</p>
<p>The following function retrieves information related to <strong>glReadPixels</strong>:</p>
<p><a href="glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.html"><strong>glGet</strong></a> with argument GL_INDEX_MODE</p>
<h2>Requirements</h2>
<table>
<thead>
<tr>
<th>Requirement</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Minimum supported client<!-- raw HTML omitted --></td>
<td>Windows 2000 Professional [desktop apps only]<!-- raw HTML omitted --></td>
</tr>
<tr>
<td>Minimum supported server<!-- raw HTML omitted --></td>
<td>Windows 2000 Server [desktop apps only]<!-- raw HTML omitted --></td>
</tr>
<tr>
<td>Header<!-- raw HTML omitted --></td>
<td><!-- raw HTML omitted --> <!-- raw HTML omitted -->Gl.h<!-- raw HTML omitted --> <!-- raw HTML omitted --></td>
</tr>
<tr>
<td>Library<!-- raw HTML omitted --></td>
<td><!-- raw HTML omitted --> <!-- raw HTML omitted -->Opengl32.lib<!-- raw HTML omitted --> <!-- raw HTML omitted --></td>
</tr>
<tr>
<td>DLL<!-- raw HTML omitted --></td>
<td><!-- raw HTML omitted --> <!-- raw HTML omitted -->Opengl32.dll<!-- raw HTML omitted --> <!-- raw HTML omitted --></td>
</tr>
</tbody>
</table>
<h2>See also</h2>
<!-- raw HTML omitted -->
<p><a href="glbegin.html"><strong>glBegin</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glcopypixels.html"><strong>glCopyPixels</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="gldrawpixels.html"><strong>glDrawPixels</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glend.html"><strong>glEnd</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glpixelmap.html"><strong>glPixelMap</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glpixelstore-functions.html"><strong>glPixelStore</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glpixeltransfer.html"><strong>glPixelTransfer</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glreadbuffer.html"><strong>glReadBuffer</strong></a></p>
<!-- raw HTML omitted -->
</body>
