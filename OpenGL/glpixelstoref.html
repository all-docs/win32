<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>glPixelStoref function</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<p>title: glPixelStoref function (Gl.h)
description: Sets pixel storage modes. | glPixelStoref function (Gl.h)
ms.assetid: 8d5055d7-3ea4-40b7-9447-2a005129da58
keywords:</p>
<ul>
<li>glPixelStoref function OpenGL
topic_type:</li>
<li>apiref
api_name:</li>
<li>glPixelStoref
api_location:</li>
<li>Opengl32.dll
api_type:</li>
<li>DllExport
ms.topic: reference
ms.date: 05/31/2018</li>
</ul>
<hr />
<h1>glPixelStoref function</h1>
<p>Sets pixel storage modes.</p>
<h2>Syntax</h2>
<pre lang="C++"><code>void WINAPI glPixelStoref(
   GLenum  pname,
   GLfloat param
);
</code></pre>
<h2>Parameters</h2>
<!-- raw HTML omitted -->
<p><em>pname</em></p>
<!-- raw HTML omitted -->
<p>The symbolic name of the parameter to be set. Six of the storage parameters affect how pixel data is returned to client memory, and are therefore significant only for <a href="glreadpixels.html"><strong>glReadPixels</strong></a> commands. They are as follows:</p>
<table>
<thead>
<tr>
<th>Storage Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>GL_PACK_SWAP_BYTES</td>
<td>If true, byte ordering for multibyte color components, depth components, color indexes, or stencil indexes is reversed. That is, if a four-byte component is made up of bytes <em>b</em>0 , <em>b</em>1 , <em>b</em>2 , <em>b</em>3 , it is stored in memory as <em>b</em>3 , <em>b</em>2 , <em>b</em>1 , <em>b</em>0 if GL_PACK_SWAP_BYTES is true. GL_PACK_SWAP_BYTES has no effect on the memory order of components within a pixel, only on the order of bytes within components or indexes. For example, the three components of a GL_RGB format pixel are always stored with red first, green second, and blue third, regardless of the value of GL_PACK_SWAP_BYTES.</td>
</tr>
<tr>
<td>GL_PACK_LSB_FIRST</td>
<td>If true, bits are ordered within a byte from least significant to most significant; otherwise, the first bit in each byte is the most significant one. This parameter is significant for bitmap data only.</td>
</tr>
<tr>
<td>GL_PACK_ROW_LENGTH</td>
<td>If greater than zero, GL_PACK_ROW_LENGTH defines the number of pixels in a row. If the first pixel of a row is placed at location p in memory, then the location of the first pixel of the next row is obtained by skipping <img src="images/pix01.png" alt="Equation showing the location of the first pixel of the next row in GL_PACK_ROW_LENGTH." />[newline] components or indexes, where <em>n</em> is the number of components or indexes in a pixel, <em>l</em> is the number of pixels in a row (gl-pack-row-length if it is greater than zero, the width argument to the pixel routine otherwise), <em>a</em> is the value of gl-pack-alignment, and <em>s</em> is the size, in bytes, of a single component (if <em>a</em> <!-- raw HTML omitted --></td>
</tr>
<tr>
<td>GL_PACK_SKIP_PIXELS and <!-- raw HTML omitted --> GL_PACK_SKIP_ROWS</td>
<td>These values are provided as a convenience to the programmer; they provide no functionality that cannot be duplicated simply by incrementing the pointer passed to <a href="glreadpixels.html"><strong>glReadPixels</strong></a>. Setting GL_PACK_SKIP_PIXELS to <em>i</em> is equivalent to incrementing the pointer by <em>i n</em> components or indexes, where <em>n</em> is the number of components or indexes in each pixel. Setting GL_PACK_SKIP_ROWS to <em>j</em> is equivalent to incrementing the pointer by <em>j k</em> components or indexes, where <em>k</em> is the number of components or indexes per row, as computed above in the GL_PACK_ROW_LENGTH section.</td>
</tr>
<tr>
<td>GL_PACK_ALIGNMENT</td>
<td>Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word alignment), and 8 (rows start on double-word boundaries).</td>
</tr>
</tbody>
</table>
<p>The other six storage parameters affect how pixel data is read from client memory. These values are significant for <a href="gldrawpixels.html"><strong>glDrawPixels</strong></a>, <a href="glteximage1d.html"><strong>glTexImage1D</strong></a>, <a href="glteximage2d.html"><strong>glTexImage2D</strong></a>, <a href="glbitmap.html"><strong>glBitmap</strong></a>, and <a href="glpolygonstipple.html"><strong>glPolygonStipple</strong></a>. They are as follows:</p>
<table>
<thead>
<tr>
<th>Storage Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>GL_UNPACK_SWAP_BYTES</td>
<td>If true, byte ordering for multibyte color components, depth components, color indexes, or stencil indexes is reversed. That is, if a four-byte component is made up of bytes <em>b</em>0 , <em>b</em>1 , <em>b</em>2 , <em>b</em>3 , it is stored in memory as <em>b</em>3 , <em>b</em>2 , <em>b</em>1 , <em>b</em>0 if GL_UNPACK_SWAP_BYTES is true. GL_UNPACK_SWAP_BYTES has no effect on the memory order of components within a pixel, only on the order of bytes within components or indexes. For example, the three components of a GL_RGB format pixel are always stored with red first, green second, and blue third, regardless of the value of GL_UNPACK_SWAP_BYTES.</td>
</tr>
<tr>
<td>GL_UNPACK_LSB_FIRST</td>
<td>If true, bits are ordered within a byte from least significant to most significant; otherwise, the first bit in each byte is the most significant one. This is significant for bitmap data only.</td>
</tr>
<tr>
<td>GL_UNPACK_ROW_LENGTH</td>
<td>If greater than zero, GL_UNPACK_ROW_LENGTH defines the number of pixels in a row. If the first pixel of a row is placed at location p in memory, then the location of the first pixel of the next row is obtained by skipping <img src="images/pix01.png" alt="Equation showing the location of the first pixel of the next row in GL_UNPACK_ROW_LENGTH." />[newline] components or indexes, where <em>n</em> is the number of components or indexes in a pixel, <em>l</em> is the number of pixels in a row (gl-pack-row-length if it is greater than zero, the width argument to the pixel routine otherwise), <em>a</em> is the value of gl-pack-alignment, and <em>s</em> is the size, in bytes, of a single component (if <em>a</em> <!-- raw HTML omitted --></td>
</tr>
<tr>
<td>GL_UNPACK_SKIP_PIXELS and <!-- raw HTML omitted --> GL_UNPACK_SKIP_ROWS</td>
<td>These values are provided as a convenience to the programmer; they provide no functionality that cannot be duplicated simply by incrementing the pointer passed to <a href="gldrawpixels.html"><strong>glDrawPixels</strong></a>, <a href="glteximage1d.html"><strong>glTexImage1D</strong></a>, <a href="glteximage2d.html"><strong>glTexImage2D</strong></a>, <a href="glbitmap.html"><strong>glBitmap</strong></a>, or <a href="glpolygonstipple.html"><strong>glPolygonStipple</strong></a>. Setting GL_UNPACK_SKIP_PIXELS to <em>i</em> is equivalent to incrementing the pointer by <em>i n</em> components or indexes, where <em>n</em> is the number of components or indexes in each pixel. Setting GL_UNPACK_SKIP_ROWS to <em>j</em> is equivalent to incrementing the pointer by <em>j k</em> components or indexes, where <em>k</em> is the number of components or indexes per row, as computed above in the GL_UNPACK_ROW_LENGTH section.</td>
</tr>
<tr>
<td>GL_UNPACK_ALIGNMENT</td>
<td>Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word alignment), and 8 (rows start on double-word boundaries).</td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<p><em>param</em></p>
<!-- raw HTML omitted -->
<p>The value that <em>pname</em> is set to.</p>
<!-- raw HTML omitted -->
<h2>Return value</h2>
<p>This function does not return a value.</p>
<h2>Remarks</h2>
<p>The <strong>glPixelStore</strong> function sets pixel storage modes that affect the operation of subsequent <a href="gldrawpixels.html"><strong>glDrawPixels</strong></a> and <a href="glreadpixels.html"><strong>glReadPixels</strong></a> as well as the unpacking of polygon stipple patterns (see <a href="glpolygonstipple.html"><strong>glPolygonStipple</strong></a>), bitmaps (see <a href="glbitmap.html"><strong>glBitmap</strong></a>), and texture patterns (see <a href="glteximage1d.html"><strong>glTexImage1D</strong></a>, <a href="glteximage2d.html"><strong>glTexImage2D</strong></a>, <a href="gltexsubimage1d.html"><strong>glTexSubImage1D</strong></a>, and <a href="gltexsubimage2d.html"><strong>glTexSubImage2D</strong></a>).</p>
<p>The following table gives the type, initial value, and range of valid values for each of the storage parameters that can be set with <strong>glPixelStore</strong>.</p>
<table>
<thead>
<tr>
<th>Pname</th>
<th>Type</th>
<th>Initial Value</th>
<th>Valid Range</th>
</tr>
</thead>
<tbody>
<tr>
<td>GL_PACK_SWAP_BYTES</td>
<td>Boolean</td>
<td>false</td>
<td>true or false</td>
</tr>
<tr>
<td>GL_PACK_SWAP_BYTES</td>
<td>Boolean</td>
<td>false</td>
<td>true or false</td>
</tr>
<tr>
<td>GL_PACK_ROW_LENGTH</td>
<td>integer</td>
<td>0</td>
<td>[0,?)</td>
</tr>
<tr>
<td>GL_PACK_SKIP_ROWS</td>
<td>integer</td>
<td>0</td>
<td>[0,?)</td>
</tr>
<tr>
<td>GL_PACK_SKIP_PIXELS</td>
<td>integer</td>
<td>0</td>
<td>[0,?)</td>
</tr>
<tr>
<td>GL_PACK_ALIGNMENT</td>
<td>integer</td>
<td>4</td>
<td>1, 2, 4, or 8</td>
</tr>
<tr>
<td>GL_UNPACK_SWAP_BYTES</td>
<td>Boolean</td>
<td>false</td>
<td>true or false</td>
</tr>
<tr>
<td>GL_UNPACK_LSB_FIRST</td>
<td>Boolean</td>
<td>false</td>
<td>true or false</td>
</tr>
<tr>
<td>GL_UNPACK_ROW_LENGTH</td>
<td>integer</td>
<td>0</td>
<td>[0,?)</td>
</tr>
<tr>
<td>GL_UNPACK_SKIP_ROWS</td>
<td>integer</td>
<td>0</td>
<td>[0,?)</td>
</tr>
<tr>
<td>GL_UNPACK_SKIP_PIXELS</td>
<td>integer</td>
<td>0</td>
<td>[0,?)</td>
</tr>
<tr>
<td>GL_UNPACK_ALIGNMENT</td>
<td>integer</td>
<td>4</td>
<td>1, 2, 4, or 8</td>
</tr>
</tbody>
</table>
<p>The <strong>glPixelStoref</strong> function can be used to set any pixel store parameter. If the parameter type is Boolean, and if <em>param</em> is 0.0, then the parameter is false; otherwise it is set to true. If <em>pname</em> is an integer type parameter, then <em>param</em> is rounded to the nearest integer.</p>
<p>Likewise, the <strong>glPixelStorei</strong> function can also be used to set any of the pixel store parameters. Boolean parameters are set to false if <em>param</em> is 0 and true otherwise. The <em>param</em> parameter is converted to floating point before being assigned to real-valued parameters.</p>
<p>The pixel storage modes in effect when <a href="gldrawpixels.html"><strong>glDrawPixels</strong></a>, <a href="glreadpixels.html"><strong>glReadPixels</strong></a>, <a href="glteximage1d.html"><strong>glTexImage1D</strong></a>, <a href="glteximage2d.html"><strong>glTexImage2D</strong></a>, <a href="glbitmap.html"><strong>glBitmap</strong></a>, or <a href="glpolygonstipple.html"><strong>glPolygonStipple</strong></a> is placed in a display list control the interpretation of memory data. The pixel storage modes in effect when a display list is executed are not significant.</p>
<p>The following functions retrieve information related to <strong>glPixelStore</strong>:</p>
<p><a href="glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.html"><strong>glGet</strong></a> with argument GL_PACK_SWAP_BYTES</p>
<p><strong>glGet</strong> with argument GL_PACK_LSB_FIRST</p>
<p><strong>glGet</strong> with argument GL_PACK_ROW_LENGTH</p>
<p><strong>glGet</strong> with argument GL_PACK_SKIP_ROWS</p>
<p><strong>glGet</strong> with argument GL_PACK_SKIP_PIXELS</p>
<p><strong>glGet</strong> with argument GL_PACK_ALIGNMENT</p>
<p><strong>glGet</strong> with argument GL_UNPACK_SWAP_BYTES</p>
<p><strong>glGet</strong> with argument GL_UNPACK_LSB_FIRST</p>
<p><strong>glGet</strong> with argument GL_UNPACK_ROW_LENGTH</p>
<p><strong>glGet</strong> with argument GL_UNPACK_SKIP_ROWS</p>
<p><strong>glGet</strong> with argument GL_UNPACK_SKIP_PIXELS</p>
<p><strong>glGet</strong> with argument GL_UNPACK_ALIGNMENT</p>
<h2>Requirements</h2>
<table>
<thead>
<tr>
<th>Requirement</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Minimum supported client<!-- raw HTML omitted --></td>
<td>Windows 2000 Professional [desktop apps only]<!-- raw HTML omitted --></td>
</tr>
<tr>
<td>Minimum supported server<!-- raw HTML omitted --></td>
<td>Windows 2000 Server [desktop apps only]<!-- raw HTML omitted --></td>
</tr>
<tr>
<td>Header<!-- raw HTML omitted --></td>
<td><!-- raw HTML omitted --> <!-- raw HTML omitted -->Gl.h<!-- raw HTML omitted --> <!-- raw HTML omitted --></td>
</tr>
<tr>
<td>Library<!-- raw HTML omitted --></td>
<td><!-- raw HTML omitted --> <!-- raw HTML omitted -->Opengl32.lib<!-- raw HTML omitted --> <!-- raw HTML omitted --></td>
</tr>
<tr>
<td>DLL<!-- raw HTML omitted --></td>
<td><!-- raw HTML omitted --> <!-- raw HTML omitted -->Opengl32.dll<!-- raw HTML omitted --> <!-- raw HTML omitted --></td>
</tr>
</tbody>
</table>
<h2>See also</h2>
<!-- raw HTML omitted -->
<p><a href="glbegin.html"><strong>glBegin</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glbitmap.html"><strong>glBitmap</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="gldrawpixels.html"><strong>glDrawPixels</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glend.html"><strong>glEnd</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glpixelmap.html"><strong>glPixelMap</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glpixeltransfer.html"><strong>glPixelTransfer</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glpixelzoom.html"><strong>glPixelZoom</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glpolygonstipple.html"><strong>glPolygonStipple</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glreadpixels.html"><strong>glReadPixels</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glteximage1d.html"><strong>glTexImage1D</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glteximage2d.html"><strong>glTexImage2D</strong></a></p>
<!-- raw HTML omitted -->
</body>
