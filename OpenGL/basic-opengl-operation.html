<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Basic OpenGL Operation</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<p>title: Basic OpenGL Operation
description: Basic OpenGL Operation
ms.assetid: ad4c9321-a9e3-40c5-af80-0ad6a8b9f380
keywords:</p>
<ul>
<li>OpenGL,basic operations</li>
<li>OpenGL,data processing</li>
<li>OpenGL,processing stages</li>
<li>OpenGL,display lists</li>
<li>display lists OpenGL</li>
<li>OpenGL,evaluators</li>
<li>evaluators OpenGL</li>
<li>OpenGL,per-vertex operations</li>
<li>per-vertex operations OpenGL</li>
<li>OpenGL,primitive assembly</li>
<li>primitive assembly OpenGL</li>
<li>OpenGL,rasterization</li>
<li>rasterization OpenGL</li>
<li>OpenGL,per-fragment operations</li>
<li>per-fragment operations OpenGL</li>
<li>framebuffers,basic operations
ms.topic: article
ms.date: 05/31/2018</li>
</ul>
<hr />
<h1>Basic OpenGL Operation</h1>
<p>The following diagram illustrates how OpenGL processes data. As shown, commands enter from the left and proceed through a processing pipeline. Some commands specify geometric objects to be drawn, and others control how the objects are handled during various processing stages.</p>
<p><img src="images/basic01.png" alt="Diagram showing the OpenGL data processing pipeline stages." /></p>
<p>The processing stages in basic OpenGL operation are as follows:</p>
<ul>
<li>
<p><strong>Display list</strong> Rather than having all commands proceed immediately through the pipeline, you can choose to accumulate some of them in a display list for processing later.</p>
</li>
<li>
<p><strong>Evaluator</strong> The evaluator stage of processing provides an efficient way to approximate curve and surface geometry by evaluating polynomial commands of input values.</p>
</li>
<li>
<p><strong>Per-vertex operations and primitive assembly</strong> OpenGL processes geometric primitivespoints, line segments, and polygonsall of which are described by vertices. Vertices are transformed and lit, and primitives are clipped to the viewport in preparation for rasterization.</p>
</li>
<li>
<p><strong>Rasterization</strong> The rasterization stage produces a series of frame-buffer addresses and associated values using a two-dimensional description of a point, line segment, or polygon. Each fragment so produced is fed into the last stage, per-fragment operations.</p>
</li>
<li>
<p><strong>Per-fragment operations</strong> These are the final operations performed on the data before it is stored as pixels in the framebuffer.</p>
<p>Per-fragment operations include conditional updates to the framebuffer based on incoming and previously stored z values (for z buffering) and blending of incoming pixel colors with stored colors, as well as masking and other logical operations on pixel values.</p>
</li>
</ul>
<p>Data can be input in the form of pixels rather than vertices. Data in the form of pixels, such as might describe an image for use in texture mapping, skips the first stage of processing described above and instead is processed as pixels, in the pixel operations stage. Following pixel operations, the pixel data is either:</p>
<ul>
<li>Stored as texture memory, for use in the rasterization stage.</li>
<li>Rasterized, with the resulting fragments merged into the framebuffer just as if they were generated from geometric data.</li>
</ul>
<p>Â </p>
<p>Â </p>
</body>
