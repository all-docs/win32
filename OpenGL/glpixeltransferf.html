<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>glPixelTransferf function</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<p>title: glPixelTransferf function (Gl.h)
description: The glPixelTransferf and glPixelTransferi functions set pixel transfer modes. | glPixelTransferf function (Gl.h)
ms.assetid: c18ecbb9-af2a-4662-8e3f-0ac850b04fc1
keywords:</p>
<ul>
<li>glPixelTransferf function OpenGL
topic_type:</li>
<li>apiref
api_name:</li>
<li>glPixelTransferf
api_location:</li>
<li>Opengl32.dll
api_type:</li>
<li>DllExport
ms.topic: reference
ms.date: 05/31/2018</li>
</ul>
<hr />
<h1>glPixelTransferf function</h1>
<p>The <strong>glPixelTransferf</strong> and <a href="glpixeltransferi.html"><strong>glPixelTransferi</strong></a> functions set pixel transfer modes.</p>
<h2>Syntax</h2>
<pre lang="C++"><code>void WINAPI glPixelTransferf(
   GLenum  pname,
   GLfloat param
);
</code></pre>
<h2>Parameters</h2>
<!-- raw HTML omitted -->
<p><em>pname</em></p>
<!-- raw HTML omitted -->
<p>The symbolic name of the pixel transfer parameter to be set. The following table gives the type, initial value, and range of valid values for each of the pixel transfer parameters that are set with <strong>glPixelTransfer</strong>.</p>
<table>
<thead>
<tr>
<th>Pname</th>
<th>Type</th>
<th>Initial Value</th>
<th>Valid Range</th>
</tr>
</thead>
<tbody>
<tr>
<td>GL_MAP_COLOR</td>
<td>Boolean</td>
<td>false</td>
<td>true/false</td>
</tr>
<tr>
<td>GL_MAP_STENCIL</td>
<td>Boolean</td>
<td>false</td>
<td>true/false</td>
</tr>
<tr>
<td>GL_INDEX_SHIFT</td>
<td>integer</td>
<td>0</td>
<td>(8,8)</td>
</tr>
<tr>
<td>GL_INDEX_OFFSET</td>
<td>integer</td>
<td>0</td>
<td>(8,8)</td>
</tr>
<tr>
<td>GL_RED_SCALE</td>
<td>integer</td>
<td>1.0</td>
<td>(8,8)</td>
</tr>
<tr>
<td>GL_GREEN_SCALE</td>
<td>float</td>
<td>1.0</td>
<td>(8,8)</td>
</tr>
<tr>
<td>GL_BLUE_SCALE</td>
<td>float</td>
<td>1.0</td>
<td>(8,8)</td>
</tr>
<tr>
<td>GL_ALPHA_SCALE</td>
<td>float</td>
<td>1.0</td>
<td>(8,8)</td>
</tr>
<tr>
<td>GL_DEPTH_SCALE</td>
<td>float</td>
<td>1.0</td>
<td>(8,8)</td>
</tr>
<tr>
<td>GL_RED_BIAS</td>
<td>float</td>
<td>0.0</td>
<td>(8,8)</td>
</tr>
<tr>
<td>GL_GREEN_BIAS</td>
<td>float</td>
<td>0.0</td>
<td>(8,8)</td>
</tr>
<tr>
<td>GL_BLUE_BIAS</td>
<td>float</td>
<td>0.0</td>
<td>(8,8)</td>
</tr>
<tr>
<td>GL_ALPHA_BIAS</td>
<td>float</td>
<td>0.0</td>
<td>(8,8)</td>
</tr>
<tr>
<td>GL_DEPTH_BIAS</td>
<td>float</td>
<td>0.0</td>
<td>(8,8)</td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<p><em>param</em></p>
<!-- raw HTML omitted -->
<p>The value that <em>pname</em> is set to.</p>
<!-- raw HTML omitted -->
<h2>Return value</h2>
<p>This function does not return a value.</p>
<h2>Remarks</h2>
<p>The <strong>glPixelTransfer</strong> function sets pixel transfer modes that affect the operation of subsequent <a href="glcopypixels.html"><strong>glCopyPixels</strong></a>, <a href="glcopyteximage1d.html"><strong>glCopyTexImage1D</strong></a>, <a href="glcopyteximage2d.html"><strong>glCopyTexImage2D</strong></a>, <a href="glcopytexsubimage1d.html"><strong>glCopyTexSubImage1D</strong></a>, <a href="glcopytexsubimage2d.html"><strong>glCopyTexSubImage2D</strong></a>, <a href="gldrawpixels.html"><strong>glDrawPixels</strong></a>, <a href="glreadpixels.html"><strong>glReadPixels</strong></a>, <a href="glteximage1d.html"><strong>glTexImage1D</strong></a>, <a href="glteximage2d.html"><strong>glTexImage2D</strong></a>, <a href="gltexsubimage1d.html"><strong>glTexSubImage1D</strong></a>, and <a href="gltexsubimage2d.html"><strong>glTexSubImage2D</strong></a> commands. The algorithms that are specified by pixel transfer modes operate on pixels after they are read from the framebuffer (<strong>glReadPixels</strong> and <strong>glCopyPixels</strong>) or unpacked from client memory (<strong>glDrawPixels</strong>, <strong>glTexImage1D</strong>, and <strong>glTexImage2D</strong>). Pixel transfer operations happen in the same order, and in the same manner, regardless of the command that resulted in the pixel operation. Pixel storage modes (<a href="glpixelstore-functions.html"><strong>glPixelStore</strong></a>) control the unpacking of pixels being read from client memory, and the packing of pixels being written back into client memory.</p>
<p>Pixel transfer operations handle four fundamental pixel types: <em>color</em>, <em>color index</em>, <em>depth</em>, and <em>stencil</em>.Color pixels are made up of four floating-point values with unspecified mantissa and exponent sizes, scaled such that 0.0 represents zero intensity and 1.0 represents full intensity. Color indexes comprise a single fixed-point value, with unspecified precision to the right of the binary point. Depth pixels comprise a single floating-point value, with unspecified mantissa and exponent sizes, scaled such that 0.0 represents the minimum depth buffer value, and 1.0 represents the maximum depth buffer value. Finally, stencil pixels comprise a single fixed-point value, with unspecified precision to the right of the binary point.</p>
<p>The pixel transfer operations performed on the four basic pixel types are as follows:</p>
<table>
<thead>
<tr>
<th>Pixel type</th>
<th>Pixel transfer operation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Color</td>
<td>Each of the four color components is multiplied by a scale factor, and then added to a bias factor. That is, the red component is multiplied by GL_RED_SCALE, and then added to GL_RED_BIAS; the green component is multiplied by GL_GREEN_SCALE, and then added to GL_GREEN_BIAS; the blue component is multiplied by GL_BLUE_SCALE, and then added to GL_BLUE_BIAS; and the alpha component is multiplied by GL_ALPHA_SCALE, and then added to GL_ALPHA_BIAS. After all four color components are scaled and biased, each is clamped to the range [0,1]. All color scale and bias values are specified with <strong>glPixelTransfer</strong>. <!-- raw HTML omitted --> If GL_MAP_COLOR is true, each color component is scaled by the size of the corresponding color-to-color map, and then replaced by the contents of that map indexed by the scaled component. That is, the red component is scaled by GL_PIXEL_MAP_R_TO_R_SIZE, and then replaced by the contents of GL_PIXEL_MAP_R_TO_R indexed by itself. The green component is scaled by GL_PIXEL_MAP_G_TO_G_SIZE, and then replaced by the contents of GL_PIXEL_MAP_G_TO_G indexed by itself. The blue component is scaled by GL_PIXEL_MAP_B_TO_B_SIZE, and then replaced by the contents of GL_PIXEL_MAP_B_TO_B indexed by itself. The alpha component is scaled by GL_PIXEL_MAP_A_TO_A_SIZE, and then replaced by the contents of GL_PIXEL_MAP_A_TO_A indexed by itself. All components taken from the maps are then clamped to the range [0,1]. GL_MAP_COLOR is specified with <strong>glPixelTransfer</strong>. The contents of the various maps are specified with <strong>glPixelMap</strong>.<!-- raw HTML omitted --></td>
</tr>
<tr>
<td>Color index</td>
<td>Each color index is shifted left by GL_INDEX_SHIFT bits, filling with zeros any bits beyond the number of fraction bits carried by the fixed-point index. If GL_INDEX_SHIFT is negative, the shift is to the right, again zero filled. GL_INDEX_OFFSET is then added to the index. GL_INDEX_SHIFT and GL_INDEX_OFFSET are specified with <strong>glPixelTransfer</strong>.<!-- raw HTML omitted --> From this point, operation diverges depending on the required format of the resulting pixels. If the resulting pixels are to be written to a color-index buffer, or if they are being read back to client memory in GL_COLOR_INDEX format, the pixels continue to be treated as indexes. If GL_MAP_COLOR is true, then each index is masked by 2 ^ <em>n</em> 1, where <em>n</em> is GL_PIXEL_MAP_I_TO_I_SIZE, and then replaced by the contents of GL_PIXEL_MAP_I_TO_I indexed by the masked value. GL_MAP_COLOR is specified with <strong>glPixelTransfer</strong>. The contents of the index map are specified with <strong>glPixelMap</strong>.<!-- raw HTML omitted --> If the resulting pixels are to be written to an RGBA color buffer, or if they are being read back to client memory in a format other than GL_COLOR_INDEX, the pixels are converted from indexes to colors by referencing the four maps GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, and GL_PIXEL_MAP_I_TO_A. Before being dereferenced, the index is masked by 2 n 1, where n is GL_PIXEL_MAP_I_TO_R_SIZE for the red map, GL_PIXEL_MAP_I_TO_G_SIZE for the green map, GL_PIXEL_MAP_I_TO_B_SIZE for the blue map, and GL_PIXEL_MAP_I_TO_A_SIZE for the alpha map. All components taken from the maps are then clamped to the range [0,1]. The contents of the four maps are specified with <strong>glPixelMap</strong>.<!-- raw HTML omitted --></td>
</tr>
<tr>
<td>Depth</td>
<td>Each depth value is multiplied by GL_DEPTH_SCALE, added to GL_DEPTH_BIAS, and then clamped to the range [0,1].</td>
</tr>
<tr>
<td>Stencil</td>
<td>Each index is shifted GL_INDEX_SHIFT bits just as a color index is, and then added to GL_INDEX_OFFSET. If GL_MAP_STENCIL is true, each index is masked by 2n 1, where <em>n</em> is GL_PIXEL_MAP_S_TO_S_SIZE, then replaced by the contents of GL_PIXEL_MAP_S_TO_S indexed by the masked value.</td>
</tr>
</tbody>
</table>
<p>The <a href="glpixeltransfer.html"><strong>glPixelTransferf</strong></a> function can be used to set any pixel transfer parameter. If the parameter type is Boolean, 0.0 implies false and any other value implies true. If <em>pname</em> is an integer parameter, <em>param</em> is rounded to the nearest integer.</p>
<p>Likewise, <strong>glPixelTransferi</strong> can also be used to set any of the pixel transfer parameters. Boolean parameters are set to false if <em>param</em> is 0 and true otherwise. The <em>param</em> parameter is converted to floating point before being assigned to real-valued parameters.</p>
<p>If a <a href="gldrawpixels.html"><strong>glDrawPixels</strong></a>, <a href="glreadpixels.html"><strong>glReadPixels</strong></a>, <a href="glcopypixels.html"><strong>glCopyPixels</strong></a>, <a href="glteximage1d.html"><strong>glTexImage1D</strong></a>, or <a href="glteximage2d.html"><strong>glTexImage2D</strong></a> command is placed in a display list (see <a href="glnewlist.html"><strong>glNewList</strong></a> and <a href="glcalllist.html"><strong>glCallList</strong></a>), the pixel transfer mode settings in effect when the display list is <em>executed</em> are the ones that are used. They may be different from the settings when the command was compiled into the display list.</p>
<p>The following functions retrieve information related to <strong>glPixelTransfer</strong>:</p>
<p><a href="glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.html"><strong>glGet</strong></a> with argument GL_MAP_COLOR</p>
<p><strong>glGet</strong> with argument GL_MAP_STENCIL</p>
<p><strong>glGet</strong> with argument GL_INDEX_SHIFT</p>
<p><strong>glGet</strong> with argument GL_INDEX_OFFSET</p>
<p><strong>glGet</strong> with argument GL_RED_SCALE</p>
<p><strong>glGet</strong> with argument GL_RED_BIAS</p>
<p><strong>glGet</strong> with argument GL_GREEN_SCALE</p>
<p><strong>glGet</strong> with argument GL_GREEN_BIAS</p>
<p><strong>glGet</strong> with argument GL_BLUE_SCALE</p>
<p><strong>glGet</strong> with argument GL_BLUE_BIAS</p>
<p><strong>glGet</strong> with argument GL_ALPHA_SCALE</p>
<p><strong>glGet</strong> with argument GL_ALPHA_BIAS</p>
<p><strong>glGet</strong> with argument GL_DEPTH_SCALE</p>
<p><strong>glGet</strong> with argument GL_DEPTH_BIAS</p>
<h2>Requirements</h2>
<table>
<thead>
<tr>
<th>Requirement</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Minimum supported client<!-- raw HTML omitted --></td>
<td>Windows 2000 Professional [desktop apps only]<!-- raw HTML omitted --></td>
</tr>
<tr>
<td>Minimum supported server<!-- raw HTML omitted --></td>
<td>Windows 2000 Server [desktop apps only]<!-- raw HTML omitted --></td>
</tr>
<tr>
<td>Header<!-- raw HTML omitted --></td>
<td><!-- raw HTML omitted --> <!-- raw HTML omitted -->Gl.h<!-- raw HTML omitted --> <!-- raw HTML omitted --></td>
</tr>
<tr>
<td>Library<!-- raw HTML omitted --></td>
<td><!-- raw HTML omitted --> <!-- raw HTML omitted -->Opengl32.lib<!-- raw HTML omitted --> <!-- raw HTML omitted --></td>
</tr>
<tr>
<td>DLL<!-- raw HTML omitted --></td>
<td><!-- raw HTML omitted --> <!-- raw HTML omitted -->Opengl32.dll<!-- raw HTML omitted --> <!-- raw HTML omitted --></td>
</tr>
</tbody>
</table>
<h2>See also</h2>
<!-- raw HTML omitted -->
<p><a href="glbegin.html"><strong>glBegin</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glcalllist.html"><strong>glCallList</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glcopypixels.html"><strong>glCopyPixels</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="gldrawpixels.html"><strong>glDrawPixels</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glend.html"><strong>glEnd</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glnewlist.html"><strong>glNewList</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glpixelmap.html"><strong>glPixelMap</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glpixelstore-functions.html"><strong>glPixelStore</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glpixelzoom.html"><strong>glPixelZoom</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glreadpixels.html"><strong>glReadPixels</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glteximage1d.html"><strong>glTexImage1D</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="glteximage2d.html"><strong>glTexImage2D</strong></a></p>
<!-- raw HTML omitted -->
</body>
