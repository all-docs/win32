<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>User Allocated Sample Support</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<p>title: User Allocated Sample Support
description: User Allocated Sample Support
ms.assetid: c747139e-e157-4ea0-9132-256dc70e2b15
keywords:</p>
<ul>
<li>Windows Media Format SDK,user allocated sample support</li>
<li>Advanced Systems Format (ASF),user allocated sample support</li>
<li>ASF (Advanced Systems Format),user allocated sample support</li>
<li>user allocated sample support
ms.topic: article
ms.date: 4/26/2023
ms.custom: UpdateFrequency5</li>
</ul>
<hr />
<h1>User Allocated Sample Support</h1>
<p>[The feature associated with this page, <a href="/windows/win32/wmformat/windows-media-format-11-sdk">Windows Media Format 11 SDK</a>, is a legacy feature. It has been superseded by <a href="/windows/win32/medfound/source-reader">Source Reader</a> and <a href="/windows/win32/medfound/sink-writer">Sink Writer</a>. <strong>Source Reader</strong> and <strong>Sink Writer</strong> have been optimized for Windows 10 and Windows 11. Microsoft strongly recommends that new code use <strong>Source Reader</strong> and <strong>Sink Writer</strong> instead of <strong>Windows Media Format 11 SDK</strong>, when possible. Microsoft suggests that existing code that uses the legacy APIs be rewritten to use the new APIs if possible.]</p>
<p>Under normal circumstances, both the reader object and the synchronous reader object create a new buffer object for each sample delivered to your application. This is because the reading object has no way of knowing what your application does with the samples after it gets them. Even though many applications read samples only to render them immediately, some applications may need to maintain samples for a long time. The reading object cannot, therefore, reuse any of the buffers it allocates; it delivers them to your application, which then has control over them.</p>
<p>The problem with this approach is that a file can contain an immense number of samples. If each one of them requires a new buffer object to be created, a lot of processor time is wasted allocating and releasing memory. In time-sensitive applications such as media players, this overhead can be very detrimental to performance.</p>
<p>To alleviate the performance issues of reader-allocated samples, both the reader and the synchronous reader support user-allocated samples. To use samples allocated by your application, the reading object makes calls to a sample allocation callback method that you implement. The logic used by the callback to deliver buffers to the reading object is entirely up to you. You can use a pool of buffers for the entire file or use multiple pools of buffers, one for each output or stream, or any other scheme that works for your application.</p>
<h2>Related topics</h2>
<!-- raw HTML omitted -->
<p><a href="allocating-buffers-for-file-reading.html"><strong>Allocating Buffers for File Reading</strong></a></p>
<!-- raw HTML omitted -->
<p><a href="file-reading-features.html"><strong>File Reading Features</strong></a></p>
<!-- raw HTML omitted -->
<p>Â </p>
<p>Â </p>
</body>
