<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Debugging Events</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<h2>description: A debugging event is an incident in the process being debugged that causes the system to notify the debugger.
ms.assetid: 43ca51f1-ba73-4031-96c3-5815311ce6f6
title: Debugging Events
ms.topic: article
ms.date: 05/31/2018</h2>
<h1>Debugging Events</h1>
<p>A debugging event is an incident in the process being debugged that causes the system to notify the debugger. Debugging events include creating a process, creating a thread, loading a dynamic-link library (DLL), unloading a DLL, sending an output string, and generating an exception.</p>
<p>If a debugging event occurs while a debugger is waiting for one, the system fills the <a href="/windows/win32/api/minwinbase/ns-minwinbase-debug_event"><strong>DEBUG_EVENT</strong></a> structure specified by <a href="/windows/win32/api/debugapi/nf-debugapi-waitfordebugevent"><strong>WaitForDebugEvent</strong></a> with information describing the event.</p>
<p>When the system notifies the debugger of a debugging event, it also suspends all threads in the affected process. The threads do not resume execution until the debugger continues the debugging event by using <a href="/windows/win32/api/debugapi/nf-debugapi-continuedebugevent"><strong>ContinueDebugEvent</strong></a>. The following debugging events may occur while a process is being debugged.</p>
<table>
<thead>
<tr>
<th>Debugging event</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CREATE_PROCESS_DEBUG_EVENT<!-- raw HTML omitted --></td>
<td>Generated whenever a new process is created in a process being debugged or whenever the debugger begins debugging an already active process. The system generates this debugging event before the process begins to execute in user mode and before the system generates any other debugging events for the new process. <!-- raw HTML omitted --> The <a href="/windows/win32/api/minwinbase/ns-minwinbase-debug_event"><strong>DEBUG_EVENT</strong></a> structure contains a <a href="/windows/win32/api/minwinbase/ns-minwinbase-create_process_debug_info"><strong>CREATE_PROCESS_DEBUG_INFO</strong></a> structure. This structure includes a handle to the new process, a handle to the process's image file, a handle to the process's initial thread, and other information that describes the new process.<!-- raw HTML omitted --> The handle to the process has PROCESS_VM_READ and PROCESS_VM_WRITE access. If a debugger has these types of access to a thread, it can read and write to the process's memory by using the <a href="/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory"><strong>ReadProcessMemory</strong></a> and <a href="/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory"><strong>WriteProcessMemory</strong></a> functions. If the system previously reported an EXIT_PROCESS_DEBUG_EVENT event, the system closes this handle when the debugger calls the <a href="/windows/win32/api/debugapi/nf-debugapi-continuedebugevent"><strong>ContinueDebugEvent</strong></a> function.<!-- raw HTML omitted --> The handle to the process's image file has GENERIC_READ access and is opened for read-sharing. The debugger should close this handle while processing CREATE_PROCESS_DEBUG_EVENT.<!-- raw HTML omitted --> The handle to the process's initial thread has THREAD_GET_CONTEXT, THREAD_SET_CONTEXT, and THREAD_SUSPEND_RESUME access to the thread. If a debugger has these types of access to a thread, it can read from and write to the thread's registers by using the <a href="/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext"><strong>GetThreadContext</strong></a> and <a href="/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext"><strong>SetThreadContext</strong></a> functions and can suspend and resume the thread by using the <a href="/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread"><strong>SuspendThread</strong></a> and <a href="/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread"><strong>ResumeThread</strong></a> functions. If the system previously reported an EXIT_PROCESS_DEBUG_EVENT event, the system closes this handle when the debugger calls the <a href="/windows/win32/api/debugapi/nf-debugapi-continuedebugevent"><strong>ContinueDebugEvent</strong></a> function.<!-- raw HTML omitted --></td>
</tr>
<tr>
<td>CREATE_THREAD_DEBUG_EVENT<!-- raw HTML omitted --></td>
<td>Generated whenever a new thread is created in a process being debugged or whenever the debugger begins debugging an already active process. This debugging event is generated before the new thread begins to execute in user mode. <!-- raw HTML omitted --> The <a href="/windows/win32/api/minwinbase/ns-minwinbase-debug_event"><strong>DEBUG_EVENT</strong></a> structure contains a <a href="/windows/win32/api/minwinbase/ns-minwinbase-create_thread_debug_info"><strong>CREATE_THREAD_DEBUG_INFO</strong></a> structure. This structure includes a handle to the new thread and the thread's starting address. The handle has THREAD_GET_CONTEXT, THREAD_SET_CONTEXT, and THREAD_SUSPEND_RESUME access to the thread. If a debugger has these types of access to a thread, it can read from and write to the thread's registers by using the <a href="/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext"><strong>GetThreadContext</strong></a> and <a href="/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext"><strong>SetThreadContext</strong></a> functions and can suspend and resume the thread by using the <a href="/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread"><strong>SuspendThread</strong></a> and <a href="/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread"><strong>ResumeThread</strong></a> functions.<!-- raw HTML omitted --> If the system previously reported an EXIT_THREAD_DEBUG_EVENT event, the system closes the handle to the new thread when the debugger calls the <a href="/windows/win32/api/debugapi/nf-debugapi-continuedebugevent"><strong>ContinueDebugEvent</strong></a> function.<!-- raw HTML omitted --></td>
</tr>
<tr>
<td>EXCEPTION_DEBUG_EVENT<!-- raw HTML omitted --></td>
<td>Generated whenever an exception occurs in the process being debugged. Possible exceptions include attempting to access inaccessible memory, executing breakpoint instructions, attempting to divide by zero, or any other exception noted in <a href="structured-exception-handling.html">Structured Exception Handling</a>. <!-- raw HTML omitted --> The <a href="/windows/win32/api/minwinbase/ns-minwinbase-debug_event"><strong>DEBUG_EVENT</strong></a> structure contains an <a href="/windows/win32/api/minwinbase/ns-minwinbase-exception_debug_info"><strong>EXCEPTION_DEBUG_INFO</strong></a> structure. This structure describes the exception that caused the debugging event.<!-- raw HTML omitted --> Besides the standard exception conditions, an additional exception code can occur during console process debugging. The system generates a DBG_CONTROL_C exception code when CTRL+C is input to a console process that handles CTRL+C signals and is being debugged. This exception code is not meant to be handled by applications. An application should never use an exception handler to deal with it. It is raised only for the benefit of the debugger and is only used when a debugger is attached to the console process.<!-- raw HTML omitted --> If a process is not being debugged or if the debugger passes on the DBG_CONTROL_C exception unhandled (through the gn command), the application's list of handler functions is searched, as documented for the <a href="/windows/console/setconsolectrlhandler"><strong>SetConsoleCtrlHandler</strong></a> function.<!-- raw HTML omitted --> If the debugger handles the DBG_CONTROL_C exception (through the gh command), an application will not notice the CTRL+C except in code like this.<!-- raw HTML omitted --> <code>while ((inputChar = getchar()) != EOF) ...</code><!-- raw HTML omitted --> Thus, the debugger cannot be used to stop the read wait in such code from terminating.<!-- raw HTML omitted --></td>
</tr>
<tr>
<td>EXIT_PROCESS_DEBUG_EVENT<!-- raw HTML omitted --></td>
<td>Generated whenever the last thread in a process being debugged exits. This debugging event occurs immediately after the system unloads the process's DLLs and updates the process's exit code. <!-- raw HTML omitted --> The <a href="/windows/win32/api/minwinbase/ns-minwinbase-debug_event"><strong>DEBUG_EVENT</strong></a> structure contains an <a href="/windows/win32/api/minwinbase/ns-minwinbase-exit_process_debug_info"><strong>EXIT_PROCESS_DEBUG_INFO</strong></a> structure that specifies the exit code.<!-- raw HTML omitted --> The debugger deallocates any internal structures associated with the process on receipt of this debugging event. The system closes the debugger's handle to the exiting process and all of the process's threads. The debugger should not close these handles.<!-- raw HTML omitted --> The kernel-mode portion of process shutdown cannot be completed until the debugger that receives this event calls <a href="/windows/win32/api/debugapi/nf-debugapi-continuedebugevent"><strong>ContinueDebugEvent</strong></a>. Until then, the process handles are open and the virtual address space is not released, so the debugger can examine the child process. To receive notification when the kernel-mode portion of process shutdown is complete, duplicate the handle returned with CREATE_PROCESS_DEBUG_EVENT, call <strong>ContinueDebugEvent</strong>, and then wait for the duplicated process handle to be signaled.<!-- raw HTML omitted --></td>
</tr>
<tr>
<td>EXIT_THREAD_DEBUG_EVENT<!-- raw HTML omitted --></td>
<td>Generated whenever a thread that is part of a process being debugged exits. The system generates this debugging event immediately after it updates the thread's exit code. <!-- raw HTML omitted --> The <a href="/windows/win32/api/minwinbase/ns-minwinbase-debug_event"><strong>DEBUG_EVENT</strong></a> structure contains an <a href="/windows/win32/api/minwinbase/ns-minwinbase-exit_thread_debug_info"><strong>EXIT_THREAD_DEBUG_INFO</strong></a> structure that specifies the exit code.<!-- raw HTML omitted --> This debugging event does not occur if the exiting thread is the last thread of a process. In this case, the EXIT_PROCESS_DEBUG_EVENT debugging event occurs instead.<!-- raw HTML omitted --> The debugger deallocates any internal structures associated with the thread on receipt of this debugging event. The system closes the debugger's handle to the exiting thread. The debugger should not close this handle.<!-- raw HTML omitted --></td>
</tr>
<tr>
<td>LOAD_DLL_DEBUG_EVENT<!-- raw HTML omitted --></td>
<td>Generated whenever a process being debugged loads a DLL. This debugging event occurs when the system loader resolves links to a DLL or when the debugged process uses the <a href="/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya"><strong>LoadLibrary</strong></a> function. This debugging event only occurs the first time the system attaches a DLL to the virtual address space of a process. <!-- raw HTML omitted --> The <a href="/windows/win32/api/minwinbase/ns-minwinbase-debug_event"><strong>DEBUG_EVENT</strong></a> structure contains a <a href="/windows/win32/api/minwinbase/ns-minwinbase-load_dll_debug_info"><strong>LOAD_DLL_DEBUG_INFO</strong></a> structure. This structure includes a handle to the newly loaded DLL, the base address of the DLL, and other information that describes the DLL. The debugger should close the handle to the DLL handle while processing LOAD_DLL_DEBUG_EVENT.<!-- raw HTML omitted --> Typically, a debugger loads a symbol table associated with the DLL on receipt of this debugging event.<!-- raw HTML omitted --></td>
</tr>
<tr>
<td>OUTPUT_DEBUG_STRING_EVENT<!-- raw HTML omitted --></td>
<td>Generated when a process being debugged uses the <!-- raw HTML omitted --><a href="/windows/win32/api/debugapi/nf-debugapi-outputdebugstringa"><strong>OutputDebugString</strong></a> function. The <a href="/windows/win32/api/minwinbase/ns-minwinbase-debug_event"><strong>DEBUG_EVENT</strong></a> structure contains an <a href="/windows/win32/api/minwinbase/ns-minwinbase-output_debug_string_info"><strong>OUTPUT_DEBUG_STRING_INFO</strong></a> structure. This structure specifies the address, length, and format of the debugging string.<!-- raw HTML omitted --></td>
</tr>
<tr>
<td>UNLOAD_DLL_DEBUG_EVENT<!-- raw HTML omitted --></td>
<td>Generated whenever a process being debugged unloads a DLL by using the <a href="/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary"><strong>FreeLibrary</strong></a> function. This debugging event only occurs the last time a DLL is unloaded from a process's address space (that is, when the DLL's usage count is zero). <!-- raw HTML omitted --> The <a href="/windows/win32/api/minwinbase/ns-minwinbase-debug_event"><strong>DEBUG_EVENT</strong></a> structure contains an <a href="/windows/win32/api/minwinbase/ns-minwinbase-unload_dll_debug_info"><strong>UNLOAD_DLL_DEBUG_INFO</strong></a> structure. This structure specifies the base address of the DLL in the address space of the process that unloads the DLL.<!-- raw HTML omitted --> Typically, a debugger unloads a symbol table associated with the DLL upon receiving this debugging event.<!-- raw HTML omitted --> When a process exits, the system automatically unloads the process's DLLs, but does not generate an UNLOAD_DLL_DEBUG_EVENT debugging event.<!-- raw HTML omitted --></td>
</tr>
<tr>
<td>RIP_EVENT<!-- raw HTML omitted --></td>
<td>Generated whenever a process being debugged dies outside of the control of the system debugger.<!-- raw HTML omitted --> The <a href="/windows/win32/api/minwinbase/ns-minwinbase-debug_event"><strong>DEBUG_EVENT</strong></a> structure contains a <a href="/windows/win32/api/minwinbase/ns-minwinbase-rip_info"><strong>RIP_INFO</strong></a> structure. This structure specifies the error and type of error.<!-- raw HTML omitted --></td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>Â </p>
<p>Â </p>
</body>
