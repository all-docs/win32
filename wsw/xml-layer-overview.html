<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>XML Layer Overview</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<p>title: XML Layer Overview
description: The XML API in WWSAPI is based on the XML Reader and XML Writer objects, which allow reading or writing of XML documents in a forward only fashion. The XML Layer give the application full access to and control over the content of messages.
ms.assetid: 938ca257-fbb8-4569-b791-2148abb1a5a5
keywords:</p>
<ul>
<li>XML Layer Overview Web Services for Windows</li>
<li>WWSAPI</li>
<li>WWS
ms.topic: article
ms.date: 05/31/2018</li>
</ul>
<hr />
<h1>XML Layer Overview</h1>
<p>The XML API in WWSAPI is based on the <a href="xml-reader.html">XML Reader</a> and <a href="xml-writer.html">XML Writer</a> objects, which allow reading or writing of XML documents in a forward only fashion. The XML Layer give the application full access to and control over the content of messages.</p>
<h2>Encoding</h2>
<p>The XML API supports documents encoded as:</p>
<ul>
<li>Text (UTF-8, UTF-16LE, UTF-16BE)</li>
<li>Binary</li>
<li>MTOM</li>
</ul>
<h2>Storage</h2>
<p>The XML API supports processing documents stored as:</p>
<ul>
<li>An in-memory buffer of encoded bytes</li>
<li>A stream</li>
<li>An <a href="xml-buffer.html">XML Buffer</a></li>
</ul>
<p>An <a href="xml-buffer.html">XML Buffer</a> is a structured in-memory representation of an XML document. This is a more efficient representation than a document encoded as bytes. An XML document stored in an XML Buffer can be navigated, read, or written.</p>
<h2>I/O</h2>
<p>The XML API will never perform I/O unless specifically requested. Furthermore, any I/O may be initiated in an asynchronous fashion. See <a href="/windows/desktop/api/WebServices/nf-webservices-wsfillreader"><strong>WsFillReader</strong></a> and <a href="/windows/desktop/api/WebServices/nf-webservices-wsflushwriter"><strong>WsFlushWriter</strong></a> for details on asynchronous processing with the XML API.</p>
<h2>Processing</h2>
<p>The XML API has three distinct levels at which the document may be processed.</p>
<p>A document may be processed a <a href="/windows/desktop/api/WebServices/ns-webservices-ws_xml_node"><strong>node</strong></a> at a time. This offers the most fine-grained handling of the XML content, and provides complete fidelity of data from the document. At this level, the functions <a href="/windows/desktop/api/WebServices/nf-webservices-wsreadnode"><strong>WsReadNode</strong></a> and <a href="/windows/desktop/api/WebServices/nf-webservices-wswritenode"><strong>WsWriteNode</strong></a> and <a href="/windows/desktop/api/WebServices/nf-webservices-wscopynode"><strong>WsCopyNode</strong></a> would be used.</p>
<p>The next level of control are APIs like <a href="/windows/desktop/api/WebServices/nf-webservices-wsreadstartelement"><strong>WsReadStartElement</strong></a>, <a href="/windows/desktop/api/WebServices/nf-webservices-wsreadvalue"><strong>WsReadValue</strong></a> and <a href="/windows/desktop/api/WebServices/nf-webservices-wsreadendelement"><strong>WsReadEndElement</strong></a>. These APIs provide numerous kinds of validation, skip whitespace and comments, and normalize text and CDATA to present the consumer with a simpler view of the xml.</p>
<p>The highest level of control is to use the Serialization API. These APIs are driven off a mapping between C data types and XML, and can read or write a complex in-memory structure to xml and back with a single function like <a href="/windows/desktop/api/WebServices/nf-webservices-wswriteelement"><strong>WsWriteElement</strong></a> and <a href="/windows/desktop/api/WebServices/nf-webservices-wsreadelement"><strong>WsReadElement</strong></a>.</p>
<p>The XML Canonicalization APIs may be used to generate a canonical form of XML which may in turn be used for generating cryptographic signatures over XML content.</p>
<h2>Creating a writer</h2>
<p>To create and use a writer to write to an in-memory buffer:</p>
<pre lang="syntax"><code>WsCreateWriter              // Create an instance of a WS_XML_WRITER
// Initialize a WS_XML_WRITER_BUFFER_OUTPUT
WsSetOutput                 // Set the encoding and output of the writer along with any other writer properties
// Write Elements
WsGetWriterProperty(..., WS_XML_WRITER_PROPERTY_BYTES, ...)  // Get the generated bytes as a single byte array
// Use the generated bytes
WsFreeWriter                // Free the writer
</code></pre>
<p>To create and use a writer to write to a stream:</p>
<pre lang="syntax"><code>WsCreateWriter              // Create an instance of a WS_XML_WRITER
// Initialize a WS_XML_WRITER_STREAM_OUTPUT
WsSetOutput                 // Set the encoding and output of the writer along with any other writer properties
// Write Elements
WsFlushWriter               // Force any buffered data to be written
WsFreeWriter                // Free the writer
</code></pre>
<p>To create and use a writer to write to a <a href="ws-xml-buffer.html">WS_XML_BUFFER</a>:</p>
<pre lang="syntax"><code>WsCreateXmlBuffer           // Create the buffer to write to
WsCreateWriter              // Create an instance of a WS_XML_WRITER
WsSetOutputToBuffer         // Set the output buffer along with any other writer properties
// Write Elements
WsFreeWriter                // Free the writer
// The buffer has the generated document
</code></pre>
<p>In all cases, the property <a href="/windows/desktop/api/WebServices/ne-webservices-ws_xml_writer_property_id"><strong>WS_XML_WRITER_PROPERTY_INDENT</strong></a> may be included to format the xml.</p>
<h2>Writing Elements</h2>
<p>To write an element to a writer:</p>
<pre lang="syntax"><code>WsWriteStartElement          // Write a start element
for each attribute
{
// Write an attribute using either
WsWriteStartAttribute    // Write a start attribute
// Write Content
WsWriteEndAttribute      // Write an end attribute
// Or one of the following
WsWriteXmlnsAttribute    // Write an explicit xmlns attribute
}
// Write Elements or Content
WsWriteEndElement
</code></pre>
<p>The following may also be used:</p>
<pre lang="syntax"><code>WsWriteArray                 // Write an array of primitive values as a series of repeated elements
</code></pre>
<h2>Writing Content</h2>
<p>To write content to an element or attribute, the following may be used:</p>
<pre lang="syntax"><code>WsWriteChars                 // Write unicode characters from memory
WsWriteCharsUtf8             // Write UTF-8 encoded characters from memory
WsWriteBytes                 // Write binary data encoded as base64
WsPushBytes                  // Direct the writer to request that bytes be written
WsPullBytes                  // Direct the writer to read the bytes to be written
WsWriteValue                 // Write primitive values such as ints and BOOLs
WsWriteText                  // Write an WS_XML_TEXT
WsWriteQualifiedName         // Write a qualified name
</code></pre>
<p>The following can be used to write to a document, but may not be used when within an attribute.</p>
<pre lang="syntax"><code>WsWriteNode                  // Write a single WS_XML_NODE
WsCopyNode                   // Copy a single node, or an entire WS_XML_ELEMENT_NODE and children from an WS_XML_READER
</code></pre>
<p>The following may be used to write a CDATA section in a text document:</p>
<pre lang="syntax"><code>WsWriteStartCData            // Start a CDATA section in a text encoding
// Write Content
WsWriteEndCData              // End a CDATA section in text encoding
</code></pre>
<h2>Miscellaneous</h2>
<pre lang="syntax"><code>WsGetPrefixFromNamespace     // Find a prefix bound to a namespace
</code></pre>
<h2>Creating a reader</h2>
<p>To create and use a reader to read from an in-memory buffer:</p>
<pre lang="syntax"><code>WsCreateReader              // Create an instance of a WS_XML_READER
// Initialize a WS_XML_READER_BUFFER_INPUT
WsSetInput                  // Set the encoding and input of the reader along with any other reader properties
// Read Elements
WsFreeReader                // Free the reader
</code></pre>
<p>To create and use a reader to reader from a stream:</p>
<pre lang="syntax"><code>WsCreateReader              // Create an instance of a WS_XML_READER
// Initialize a WS_XML_READER_STREAM_INPUT
WsSetInput                  // Set the encoding and input of the reader along with any other reader properties
WsFillReader                // Populate the reader with data from the underlying stream
// Read Elements
WsFreeReader                // Free the reader
</code></pre>
<p>To create and use a reader to read from a <a href="ws-xml-buffer.html">WS_XML_BUFFER</a>:</p>
<pre lang="syntax"><code>WsCreateXmlBuffer           // Create the buffer to write to
WsCreateReader              // Create an instance of a WS_XML_READER
WsSetInputToBuffer          // Set the input buffer along with any other reader properties
// Read Elements
WsFreeReader                // Free the reader
</code></pre>
<h2>Reading Elements</h2>
<p>To read an element from a reader:</p>
<pre lang="syntax"><code>WsReadToStartElement         // Skip whitespace and comments to position the reader on a specific element
for each attribute of interest
{
WsFindAttribute          // Try Locate the attribute
if (found)
{
WsReadStartAttribute // Set the reader to read the attribute
// Read Content
WsReadEndAttribute   // Return the reader to the element
}
}
WsReadStartElement           // Advance the reader past the current element
// Read Elements or Content
WsWriteEndElement            // Advance the reader past the corresponding end element
</code></pre>
<p>The following may also be used:</p>
<pre lang="syntax"><code>WsReadArray                  // Read an array of primitive values as a series of repeated elements
</code></pre>
<h2>Reading Content</h2>
<p>To read content from an element or attribute, the following may be used:</p>
<pre lang="syntax"><code>WsReadChars                 // Read characters to memory as unicode
WsReadCharsUtf8             // Read characters to memory encoded as UTF-8
WsReadBytes                 // Read binary data encoded as base64
WsReadValue                 // Read primitive values such as ints and BOOLs
WsReadQualifiedName         // Read a qualified name
</code></pre>
<p>The following may be used to inspect the current node the reader is positioned on:</p>
<pre lang="syntax"><code>WsGetReaderNode             // Get the current node
</code></pre>
<h2>Using a buffer</h2>
<p>When writing to a <a href="ws-xml-buffer.html">WS_XML_BUFFER</a> the following may be used:</p>
<pre lang="syntax"><code>WsGetWriterPosition          // Get the current position of the writer in the document
WsSetWriterPosition          // Set the current position of the writer in the document
WsMoveWriter                 // Move relative to the current position in the document
WsRemoveNode                 // Delete an element or text from a document
</code></pre>
<p>When reading from a <a href="ws-xml-buffer.html">WS_XML_BUFFER</a> the following may be used:</p>
<pre lang="syntax"><code>WsGetReaderPosition          // Get the current position of the reader in the document
WsSetReaderPosition          // Set the current position of the reader in the document
WsMoveReader                 // Move relative to the current position in the document
</code></pre>
<p>The following may be used to modify a <a href="ws-xml-buffer.html">WS_XML_BUFFER</a>:</p>
<pre lang="syntax"><code>
WsRemoveNode                 // Delete an element or text from a document
</code></pre>
<h2>Other</h2>
<pre lang="syntax"><code>WsGetNamespaceFromPrefix     // Find a namespace bound to a prefix
WsGetXmlAttribute            // Find an &quot;xml:space&quot; or &quot;xml:lang&quot; attribute in scope
</code></pre>
<p>Â </p>
<p>Â </p>
</body>
