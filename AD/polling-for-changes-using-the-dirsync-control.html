<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Polling for Changes Using the DirSync Control</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<p>title: Polling for Changes Using the DirSync Control
description: Active Directory directory synchronization (DirSync) control is an LDAP server extension that enables an application to search an directory partition for objects that have changed since a previous state.
ms.assetid: f77caeb3-bfc9-4ae6-8d1d-73f4ee554336
ms.tgt_platform: multiple
keywords:</p>
<ul>
<li>Polling for Changes Using the DirSync Control AD
ms.topic: article
ms.date: 05/31/2018</li>
</ul>
<hr />
<h1>Polling for Changes Using the DirSync Control</h1>
<p>Active Directory directory synchronization (DirSync) control is an LDAP server extension that enables an application to search an directory partition for objects that have changed since a previous state.</p>
<p>Use the DirSync control through ADSI by specifying the <strong>ADS_SEARCHPREF_DIRSYNC</strong> search preference when using <a href="/windows/desktop/api/iads/nn-iads-idirectorysearch"><strong>IDirectorySearch</strong></a>. For more information and a code example, see <a href="example-code-using-ads-searchpref-dirsync.html">Example Code Using ADS_SEARCHPREF_DIRSYNC</a>. You can also perform a DirSync search using the LDAP API. The following describes the ADSI implementation, most of which also applies to using LDAP directly, except as discussed at the end of this topic.</p>
<p>When you perform a DirSync search, you pass in a provider-specific data element (cookie) that identifies the directory state at the time of the previous DirSync search. For the first search, you pass in a null cookie, and the search returns all objects that match the filter. The search also returns a valid cookie. Store the cookie in the same storage that you are synchronizing with the Active Directory server. On subsequent searches, get the cookie from storage and pass it with the search request. The search results now include only the objects and attributes that have changed since the previous state identified by the cookie. The search also returns a new cookie to store for the next search.</p>
<p>The following table lists search parameters that the client search request can specify.</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Base of the search</td>
<td>The base of a DirSync search must be the root of a directory partition, which can be a domain partition, the configuration partition, or the schema partition.</td>
</tr>
<tr>
<td>Scope</td>
<td>The scope of a DirSync search must be <strong>ADS_SCOPE_SUBTREE</strong>, that is, the entire subtree of the partition. Be aware that for a search of a domain partition, the subtree includes the heads, but not the contents, of the configuration and schema partitions. To poll for changes in a smaller scope, use the <strong>USNChanged</strong> technique instead of DirSync.</td>
</tr>
<tr>
<td>Filter</td>
<td>You can specify any valid search filter. For an initial search with a null cookie, the results include all objects that match the filter. For subsequent searches with a valid cookie, the search results include data only for objects that match the filter and have changed since the state indicated by the cookie. For more information about search filters, see <a href="creating-a-query-filter.html">Creating a Query Filter</a>.</td>
</tr>
<tr>
<td>Attributes</td>
<td>You can specify a list of attributes to be returned when a change occurs. For each object, the initial results include all the requested attributes set on the object. Subsequent search results include only the specified attributes that have changed. Unchanged attributes are not included in the search results. In the ADSI implementation, the search results always include the <strong>objectGUID</strong> and <strong>instanceType</strong> of each object. Also, the specified attribute list acts as an additional filter: the initial search results include only objects that have at least one of the specified attributes set; subsequent searches include only objects on which one or more of the attributes have changed (values added or deleted).</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>Also, be aware that:</p>
<ul>
<li>
<p>For incremental searches, the best practice is to bind to the same domain controller (DC) used in the previous search, that is, the DC that generated the cookie. If the same DC is unavailable, either wait until it is, or bind to a new DC and perform a full synchronization. Store the DNS name of the DC in the secondary storage with the cookie.</p>
<p>You can pass a cookie generated by one DC to a different DC hosting a replica of the same directory partition. There is no chance that a client will miss changes by using a cookie from one DC on another DC. However, it is possible that the search results from the new DC may include reported changes by the old DC; in some cases, the new DC may return all objects and attributes, as with a full synchronization. The client should just make its database consistent with reported search results for any given DirSync call, that is, handle all incremental results as if they were the latest state. It does not matter whether you have seen the change before or are even going back to a previous state because repeated incremental synchronizations will converge on consistency.</p>
</li>
<li>
<p>It is also possible the other DC rejects the cookie returned from the original DC. The search generates an LDAP error on the server like &quot;0000203D: LdapErr: DSID-xxxxxxxx, comment: Error processing control, data 0&quot;, and the client application may generate an error such as &quot;System.DirectoryServices.Protocols.DirectoryOperationException: A protocol error occurred.&quot; This may happen, for example, when the cookie is older, and the internal contents of the cookie are expected to be different when processed by an LDAP server running a different version of Windows. The cookie is an opaque structure and is not guaranteed to be structurally consistent among all Windows OS versions. The client application should handle this case and retry with a full sync if this error is encountered.</p>
</li>
<li>
<p>When an object is renamed or moved, its child objects, if any, are not included in the search results, even though the distinguished names of the child objects have changed. Similarly, when an inheritable ACE is modified in an object security-descriptor, the child objects of the object are not included in the search results, even though the security-descriptors of the child objects have changed.</p>
</li>
<li>
<p>Use the <strong>objectGUID</strong> attribute to identify the tracked objects. The <strong>objectGUID</strong> of each object remains unchanged regardless of where the object is moved within the forest.</p>
</li>
<li>
<p>Be aware that the search results of a DirSync search indicate the state of the objects on a replica of the directory partition at the time of the search. This means that changes made on other DCs will not be included if they have not been replicated to the target DC. It also means that an object's attributes may have changed several times since the previous DirSync search, but the search will show only the final state, not the sequence of changes.</p>
</li>
<li>
<p>In the ADSI implementation, the application must handle the cookie as opaque and not make any assumptions about its internal organization or value.</p>
</li>
<li>
<p>Be aware that the client stores the cookie, cookie length, and DNS name of the DC in the same storage that contains the synchronized object data. This ensures that the cookie and other parameters remain in sync with the object data if the storage is ever restored from a backup.</p>
</li>
<li>
<p>To retrieve the <a href="/windows/desktop/ADSchema/a-parentguid"><strong>parentGUID</strong></a> attribute, which is constructed for the DirSync control, it is also necessary to request the <a href="/windows/desktop/ADSchema/a-name"><strong>name</strong></a> attribute.</p>
</li>
</ul>
<p>To use the DirSync control, caller must have the &quot;directory get changes&quot; right assigned on the root of the partition being monitored. By default, this right is assigned to the Administrator and LocalSystem accounts on domain controllers. The caller must also have the <a href="/windows/desktop/ADSchema/r-ds-replication-get-changes"><strong>DS-Replication-Get-Changes</strong></a> extended control access right. For more information about implementing a change-tracking mechanism for applications that must run under an account that does not have this right, see <a href="polling-for-changes-using-usnchanged.html">Polling for Changes Using USNChanged</a>. For more information about privileges, see <a href="/windows/desktop/SecAuthZ/privileges">Privileges</a>.</p>
<h2>Retrieving Deleted Objects With a DirSync Search</h2>
<p>The <strong>ADS_SEARCHPREF_DIRSYNC</strong> search results automatically include deleted objects (tombstones) that match the specified search filter. However, a search filter that will match an object when it is live may not match the object after it is deleted. This is because tombstones retain only a subset of the attributes present on the original object. For example, you would typically use the following filter for user objects.</p>
<pre lang="C++"><code>(&amp;(objectClass=user)(objectCategory=person))
</code></pre>
<p>The <strong>objectCategory</strong> attribute is removed when an object is deleted, so the filter above would not match any tombstone objects. Conversely, the <strong>objectClass</strong> attribute is retained on tombstone objects, so a filter of &quot;(objectClass=user)&quot; would match deleted user objects.</p>
<p>The attribute list that you specify with a DirSync search also acts as a filter; search results include only objects on which one or more of the specified attributes have changed since the previous DirSync search. If the attribute list does not include any attributes that are retained on tombstones, the search results will not include tombstones. To handle this, request all attributes by specifying a null attribute list; or you can request the <strong>isDeleted</strong> attribute, set to <strong>TRUE</strong> on all tombstones. Tombstone attributes have the 0x8 bit set in the <strong>searchFlags</strong> attribute of the <strong>attributeSchema</strong> definition.</p>
<p>For more information, see <a href="retrieving-deleted-objects.html">Retrieving Deleted Objects</a>.</p>
<h2>LDAP Implementation of the DirSync Control</h2>
<p>You can also perform a DirSync search by using the LDAP API with the <a href="/previous-versions/windows/desktop/ldap/ldap-server-dirsync-oid">LDAP_SERVER_DIRSYNC_OID</a> control. If you use the LDAP API, also specify the <a href="/previous-versions/windows/desktop/ldap/ldap-server-extended-dn-oid">LDAP_SERVER_EXTENDED_DN_OID</a> and <a href="/previous-versions/windows/desktop/ldap/ldap-server-show-deleted-oid">LDAP_SERVER_SHOW_DELETED_OID</a> controls. The LDAP_SERVER_EXTENDED_DN_OID control causes an LDAP search to return an extended form of the distinguished name that includes the <strong>objectGUID</strong> and <strong>objectSID</strong> for security principal objects such as users, groups, and computers. The LDAP_SERVER_SHOW_DELETED_OID control causes the search results to include data for deleted objects. Be aware that these controls are automatically included in the ADSI implementation.</p>
<p>Â </p>
<p>Â </p>
</body>
