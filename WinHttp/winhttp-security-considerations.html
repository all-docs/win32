<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>WinHTTP Security Considerations</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<h2>description: 'The following security considerations apply to applications that use WinHTTP: Server certificates are only verified once per session.'
ms.assetid: 287e85ed-a324-4785-872a-26e4ab37986d
title: WinHTTP Security Considerations
ms.topic: article
ms.date: 05/31/2018</h2>
<h1>WinHTTP Security Considerations</h1>
<p>The following security considerations apply to applications that use WinHTTP:</p>
<ul>
<li><strong>Server certificates are only verified once per session.</strong> After a certificate has been verified, it remains valid for the duration of the current session. As long as the certificate fingerprint matches, which indicates that the certificate has not changed, the certificate continues to be re-validated. As a result, any change in the validation criteria, through the protocol, revocation-check, or certificate-error-ignore flags, does not take effect once the certificate is verified. To force such a change to take effect immediately, the current session must be ended and a new one started. Similarly, expiration of a certificate during the course of a session can only be detected if the application itself checks the certificate server periodically to retrieve expiration data.</li>
<li><strong>Auto-proxy involves downloading and executing scripts.</strong> The automatic proxy discovery support involves detecting through DHCP or DNS, downloading, and executing proxy scripts such as Java scripts. To achieve a higher degree of security, an application must avoid passing the <strong>WINHTTP_AUTOPROXY_RUN_INPROCESS</strong> flag, so that the auto-proxy discovery is initiated out-of-process. Even then, WinHTTP tries by default to run an auto-proxy script in-process if the script fails to run properly out-of-process. If you believe that this fallback behavior poses an unacceptable risk, disable the fallback behavior with the <strong>WINHTTP_AUTOPROXY_RUN_OUTPROCESS_ONLY</strong> flag.</li>
<li><strong>WINHTTP_STATUS_CALLBACK functions must return promptly.</strong> When you write one of these callback functions, be careful that it does not block. For example, neither the callback nor any function it calls should display a user dialog or wait for an event. If a <a href="/windows/win32/api/winhttp/nc-winhttp-winhttp_status_callback"><em>WINHTTP_STATUS_CALLBACK</em></a> function does block, it affects WinHTTP's internal scheduling and causes other requests within the same process to be denied service.</li>
<li><strong>WINHTTP_STATUS_CALLBACK functions must be reentrant.</strong> When writing a callback, avoid static variables or other constructs that are unsafe under reentrance, and avoid calling other functions that are not reentrant.</li>
<li><strong>If asynchronous operation is possible, pass NULLs for OUT parameters.</strong> If you have enabled asynchronous operation by registering a callback function, always pass <strong>NULL</strong> values for such OUT parameters as <em>lpdwDataAvailable</em> for <a href="/windows/desktop/api/Winhttp/nf-winhttp-winhttpquerydataavailable"><strong>WinHttpQueryDataAvailable</strong></a>, <em>lpdwBytesRead</em> for <a href="/windows/desktop/api/Winhttp/nf-winhttp-winhttpreaddata"><strong>WinHttpReadData</strong></a>, or <em>lpdwBytesWritten</em> for <a href="/windows/desktop/api/Winhttp/nf-winhttp-winhttpwritedata"><strong>WinHttpWriteData</strong></a>. Under some circumstances, the calling thread is terminated before the operation completes, and if the OUT parameters are not <strong>NULL</strong>, the function can end up writing to memory that has already been freed.</li>
<li><strong>Passport authentication is not foolproof.</strong> Any cookie-based authentication scheme is vulnerable to attack. Passport version 1.4 is cookie based, and therefore subject to the vulnerabilities that are associated with any cookie or form-based authentication scheme. Passport support is disabled by default in WinHTTP; it can be enabled using <a href="/windows/desktop/api/Winhttp/nf-winhttp-winhttpsetoption"><strong>WinHttpSetOption</strong></a>.</li>
<li><strong>Basic authentication should only be used over a secure connection.</strong> Basic authentication, which sends the user name and password in clear text (see <a href="https://www.ietf.org/rfc/rfc2617.txt">RFC 2617</a>), should be used only over encrypted SSL or TLS connections.</li>
<li><strong>Setting Auto-Logon Policy to &quot;low&quot; can pose a risk.</strong> When the Auto-Logon Policy is set to low, a user's logon credential can be used to authenticate against any site. However, it is not good security practice to authenticate against sites you do not trust.</li>
<li><strong>SSL 2.0 connections are not used unless explicitly enabled.</strong> The TLS 1.0 and SSL 3.0 security protocols are considered more secure than SSL 2.0. By default, WinHTTP requests TLS 1.0 or SSL 3.0 when negotiating an SSL connection, not SSL 2.0. SSL 2.0 support in WinHTTP can only be enabled by calling <a href="/windows/desktop/api/Winhttp/nf-winhttp-winhttpsetoption"><strong>WinHttpSetOption</strong></a>.</li>
<li><strong>Certificate-revocation checking must be explicitly requested.</strong> By default, when performing certificate authentication, WinHTTP does not check whether the server's certificate has been revoked. Certificate-revocation checking can be enabled using <a href="/windows/desktop/api/Winhttp/nf-winhttp-winhttpsetoption"><strong>WinHttpSetOption</strong></a>.</li>
<li><strong>Applications must ensure that a session maps to a single identity.</strong> A WinHTTP session should map to one and only one identity; that is, a WinHTTP session is used to manage the Internet activity of a single authenticated user, or a group of anonymous users. However, because WinHTTP does not enforce this mapping automatically, your application must take steps to ensure that only a single identity is involved.</li>
<li><strong>Operations on a WinHTTP request handle should be synchronized.</strong> For example, an application should avoid closing a request handle on one thread while another thread is sending or receiving a request. To terminate an asynchronous request, close the request handle during a callback notification. To terminate a synchronous request, close the handle when the previous WinHTTP call returns.</li>
<li><strong>Trace files contain sensitive information.</strong> Trace files are protected using Access-Control Lists (ACLs) so that one can normally be accessed only by the local administrator or by the user account that created it.Avoid compromising trace files by any unauthorized access.</li>
<li><strong>Avoid passing sensitive data through</strong> <a href="/windows/desktop/api/Winhttp/nf-winhttp-winhttpsetoption"><strong>WinHttpSetOption</strong></a>. Do not supply a user name, password or any other credentials to <strong>WinHttpSetOption</strong> because you have no control over the authentication scheme that is used, and the sensitive data could unexpectedly be sent in clear text. Use <a href="/windows/desktop/api/Winhttp/nf-winhttp-winhttpqueryauthschemes"><strong>WinHttpQueryAuthSchemes</strong></a> and <strong>WinHttpSetCredentials</strong> instead of <strong>WinHttpSetOption</strong> for setting credentials.</li>
<li><strong>Automatic redirection can pose a security risk.</strong> By default, redirection (a 302 message) is followed automatically even for a POST. To avoid the possibility of spurious redirects, applications should disable auto-redirect or monitor re-direction in callbacks when posting sensitive information.</li>
<li><strong>User-defined headers are transferred across redirects unchanged.</strong> User-defined headers, such as cookies added with <strong>WinHTTPAddRequestHeaders</strong>, are transferred across redirects without modification, while headers generated by WinHTTP are automatically updated. If transferring a user-defined header across redirects poses a security risk, use the <a href="/windows/win32/api/winhttp/nc-winhttp-winhttp_status_callback"><em>WINHTTP_STATUS_CALLBACK</em></a> callback with the <strong>WINHTTP_CALLBACK_STATUS_REDIRECT</strong> completion to modify the header in question whenever a redirect occurs.</li>
<li><strong>WinHTTP is not reentrant in synchronous mode.</strong> Because WinHTTP is not reentrant in synchronous mode, do not schedule asynchronous procedure calls (APC) that can call into WinHTTP on an application thread that executes inside a WinHTTP function. While in synchronous mode, WinHTTP performs an &quot;alertable wait,&quot; and if the waiting thread is pre-empted to execute an APC and then later re-enters WinHTTP again, WinHTTP's internal state can be corrupted.</li>
</ul>
<p>Â </p>
<p>Â </p>
</body>
