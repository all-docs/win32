<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Window Features</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<h2>description: This overview discusses features of windows such as window types, states, size, and position.
ms.assetid: 8318c22f-85a2-490e-8233-ee1e234890d9
title: Window Features
ms.topic: article
ms.date: 05/31/2018</h2>
<h1>Window Features</h1>
<p>This overview discusses features of windows such as window types, states, size, and position.</p>
<ul>
<li><a href="#window-types">Window Types</a>
<ul>
<li><a href="#overlapped-windows">Overlapped Windows</a></li>
<li><a href="#pop-up-windows">Pop-up Windows</a></li>
<li><a href="#child-windows">Child Windows</a>
<ul>
<li><a href="#positioning">Positioning</a></li>
<li><a href="#clipping">Clipping</a></li>
<li><a href="#relationship-to-parent-window">Relationship to Parent Window</a></li>
<li><a href="#size-and-position-messages">Messages</a></li>
</ul>
</li>
<li><a href="#layered-windows">Layered Windows</a></li>
<li><a href="#message-only-windows">Message-Only Windows</a></li>
</ul>
</li>
<li><a href="#window-relationships">Window Relationships</a>
<ul>
<li><a href="#foreground-and-background-windows">Foreground and Background Windows</a></li>
<li><a href="#owned-windows">Owned Windows</a></li>
<li><a href="#z-order">Z-Order</a></li>
</ul>
</li>
<li><a href="#window-show-state">Window Show State</a>
<ul>
<li><a href="#active-window">Active Window</a></li>
<li><a href="#disabled-windows">Disabled Windows</a></li>
<li><a href="#window-visibility">Window Visibility</a></li>
<li><a href="#minimized-maximized-and-restored-windows">Minimized, Maximized, and Restored Windows</a></li>
</ul>
</li>
<li><a href="#window-size-and-position">Window Size and Position</a>
<ul>
<li><a href="#default-size-and-position">Default Size and Position</a></li>
<li><a href="#tracking-size">Tracking Size</a></li>
<li><a href="#system-commands">System Commands</a></li>
<li><a href="#size-and-position-functions">Size and Position Functions</a></li>
<li><a href="#size-and-position-messages">Size and Position Messages</a></li>
</ul>
</li>
<li><a href="#window-animation">Window Animation</a></li>
<li><a href="#window-layout-and-mirroring">Window Layout and Mirroring</a>
<ul>
<li><a href="#mirroring-dialog-boxes-and-message-boxes">Mirroring Dialog Boxes and Message Boxes</a></li>
<li><a href="#mirroring-device-contexts-not-associated-with-a-window">Mirroring Device Contexts Not Associated with a Window</a></li>
</ul>
</li>
<li><a href="#window-destruction">Window Destruction</a></li>
</ul>
<h2>Window Types</h2>
<p>This section contains the following topics that describe window types.</p>
<ul>
<li><a href="#overlapped-windows">Overlapped Windows</a></li>
<li><a href="#pop-up-windows">Pop-up Windows</a></li>
<li><a href="#child-windows">Child Windows</a></li>
<li><a href="#layered-windows">Layered Windows</a></li>
<li><a href="#message-only-windows">Message-Only Windows</a></li>
</ul>
<h3>Overlapped Windows</h3>
<p>An <em>overlapped window</em> is a top-level window (non-child window) that has a title bar, border, and client area; it is meant to serve as an application's main window. It can also have a window menu, minimize and maximize buttons, and scroll bars. An overlapped window used as a main window typically includes all of these components.</p>
<p>By specifying the <a href="window-styles.html"><strong>WS_OVERLAPPED</strong></a> or <strong>WS_OVERLAPPEDWINDOW</strong> style in the <a href="/windows/win32/api/winuser/nf-winuser-createwindowexa"><strong>CreateWindowEx</strong></a> function, an application creates an overlapped window. If you use the <strong>WS_OVERLAPPED</strong> style, the window has a title bar and border. If you use the <strong>WS_OVERLAPPEDWINDOW</strong> style, the window has a title bar, sizing border, window menu, and minimize and maximize buttons.</p>
<h3>Pop-up Windows</h3>
<p>A <em>pop-up window</em> is a special type of overlapped window used for dialog boxes, message boxes, and other temporary windows that appear outside an application's main window. Title bars are optional for pop-up windows; otherwise, pop-up windows are the same as overlapped windows of the <a href="window-styles.html"><strong>WS_OVERLAPPED</strong></a> style.</p>
<p>You create a pop-up window by specifying the <a href="window-styles.html"><strong>WS_POPUP</strong></a> style in <a href="/windows/win32/api/winuser/nf-winuser-createwindowexa"><strong>CreateWindowEx</strong></a>. To include a title bar, specify the <strong>WS_CAPTION</strong> style. Use the <strong>WS_POPUPWINDOW</strong> style to create a pop-up window that has a border and a window menu. The <strong>WS_CAPTION</strong> style must be combined with the <strong>WS_POPUPWINDOW</strong> style to make the window menu visible.</p>
<h3>Child Windows</h3>
<p>A <em>child window</em> has the <a href="window-styles.html"><strong>WS_CHILD</strong></a> style and is confined to the client area of its parent window. An application typically uses child windows to divide the client area of a parent window into functional areas. You create a child window by specifying the <strong>WS_CHILD</strong> style in the <a href="/windows/win32/api/winuser/nf-winuser-createwindowexa"><strong>CreateWindowEx</strong></a> function.</p>
<p>A child window must have a parent window. The parent window can be an overlapped window, a pop-up window, or even another child window. You specify the parent window when you call <a href="/windows/win32/api/winuser/nf-winuser-createwindowexa"><strong>CreateWindowEx</strong></a>. If you specify the <a href="window-styles.html"><strong>WS_CHILD</strong></a> style in <strong>CreateWindowEx</strong> but do not specify a parent window, the system does not create the window.</p>
<p>A child window has a client area but no other features, unless they are explicitly requested. An application can request a title bar, a window menu, minimize and maximize buttons, a border, and scroll bars for a child window, but a child window cannot have a menu. If the application specifies a menu handle, either when it registers the child's window class or creates the child window, the menu handle is ignored. If no border style is specified, the system creates a borderless window. An application can use borderless child windows to divide a parent window's client area while keeping the divisions invisible to the user.</p>
<p>This section discusses the following aspects of child windows:</p>
<ul>
<li><a href="#positioning">Positioning</a></li>
<li><a href="#clipping">Clipping</a></li>
<li><a href="#relationship-to-parent-window">Relationship to Parent Window</a></li>
<li><a href="#size-and-position-messages">Messages</a></li>
</ul>
<h4>Positioning</h4>
<p>The system always positions a child window relative to the upper left corner of its parent window's client area. No part of a child window ever appears outside the borders of its parent window. If an application creates a child window that is larger than the parent window or positions a child window so that some or all of the child window extends beyond the borders of the parent, the system clips the child window; that is, the portion outside the parent window's client area is not displayed. Actions that affect the parent window can also affect the child window, as follows.</p>
<table>
<thead>
<tr>
<th>Parent Window</th>
<th>Child Window</th>
</tr>
</thead>
<tbody>
<tr>
<td>Destroyed</td>
<td>Destroyed before the parent window is destroyed.</td>
</tr>
<tr>
<td>Hidden</td>
<td>Hidden before the parent window is hidden. A child window is visible only when the parent window is visible.</td>
</tr>
<tr>
<td>Moved</td>
<td>Moved with the parent window's client area. The child window is responsible for painting its client area after the move.</td>
</tr>
<tr>
<td>Shown</td>
<td>Shown after the parent window is shown.</td>
</tr>
</tbody>
</table>
<p>Â </p>
<h4>Clipping</h4>
<p>The system does not automatically clip a child window from the parent window's client area. This means the parent window draws over the child window if it carries out any drawing in the same location as the child window. However, the system does clip the child window from the parent window's client area if the parent window has the <a href="window-styles.html"><strong>WS_CLIPCHILDREN</strong></a> style. If the child window is clipped, the parent window cannot draw over it.</p>
<p>A child window can overlap other child windows in the same client area. A child window that shares the same parent window as one or more other child windows is called a <em>sibling window</em>. Sibling windows can draw in each other's client area, unless one of the child windows has the <a href="window-styles.html"><strong>WS_CLIPSIBLINGS</strong></a> style. If a child window does have this style, any portion of its sibling window that lies within the child window is clipped.</p>
<p>If a window has either the <a href="window-styles.html"><strong>WS_CLIPCHILDREN</strong></a> or <strong>WS_CLIPSIBLINGS</strong> style, a slight loss in performance occurs. Each window takes up system resources, so an application should not use child windows indiscriminately. For best performance, an application that needs to logically divide its main window should do so in the window procedure of the main window rather than by using child windows.</p>
<h4>Relationship to Parent Window</h4>
<p>An application can change the parent window of an existing child window by calling the <a href="/windows/win32/api/winuser/nf-winuser-setparent"><strong>SetParent</strong></a> function. In this case, the system removes the child window from the client area of the old parent window and moves it to the client area of the new parent window. If <strong>SetParent</strong> specifies a <strong>NULL</strong> handle, the desktop window becomes the new parent window. In this case, the child window is drawn on the desktop, outside the borders of any other window. The <a href="/windows/win32/api/winuser/nf-winuser-getparent"><strong>GetParent</strong></a> function retrieves a handle to a child window's parent window.</p>
<p>The parent window relinquishes a portion of its client area to a child window, and the child window receives all input from this area. The window class need not be the same for each of the child windows of the parent window. This means that an application can fill a parent window with child windows that look different and carry out different tasks. For example, a dialog box can contain many types of controls, each one a child window that accepts different types of data from the user.</p>
<p>A child window has only one parent window, but a parent can have any number of child windows. Each child window, in turn, can have child windows. In this chain of windows, each child window is called a descendant window of the original parent window. An application uses the <a href="/windows/win32/api/winuser/nf-winuser-ischild"><strong>IsChild</strong></a> function to discover whether a given window is a child window or a descendant window of a given parent window.</p>
<p>The <a href="/windows/win32/api/winuser/nf-winuser-enumchildwindows"><strong>EnumChildWindows</strong></a> function enumerates the child windows of a parent window. Then, <strong>EnumChildWindows</strong> passes the handle to each child window to an application-defined callback function. Descendant windows of the given parent window are also enumerated.</p>
<h4>Messages</h4>
<p>The system passes a child window's input messages directly to the child window; the messages are not passed through the parent window. The only exception is if the child window has been disabled by the <a href="/windows/win32/api/winuser/nf-winuser-enablewindow"><strong>EnableWindow</strong></a> function. In this case, the system passes any input messages that would have gone to the child window to the parent window instead. This permits the parent window to examine the input messages and enable the child window, if necessary.</p>
<p>A child window can have a unique integer identifier. Child window identifiers are important when working with control windows. An application directs a control's activity by sending it messages. The application uses the control's child window identifier to direct the messages to the control. In addition, a control sends notification messages to its parent window. A notification message includes the control's child window identifier, which the parent uses to identify which control sent the message. An application specifies the child-window identifier for other types of child windows by setting the <em>hMenu</em> parameter of the <a href="/windows/win32/api/winuser/nf-winuser-createwindowexa"><strong>CreateWindowEx</strong></a> function to a value rather than a menu handle.</p>
<h3>Layered Windows</h3>
<p>Using a layered window can significantly improve performance and visual effects for a window that has a complex shape, animates its shape, or wishes to use alpha blending effects. The system automatically composes and repaints layered windows and the windows of underlying applications. As a result, layered windows are rendered smoothly, without the flickering typical of complex window regions. In addition, layered windows can be partially translucent, that is, alpha-blended.</p>
<p>To create a layered window, specify the <strong>WS_EX_LAYERED</strong> extended window style when calling the <a href="/windows/win32/api/winuser/nf-winuser-createwindowexa"><strong>CreateWindowEx</strong></a> function, or call the <a href="/windows/win32/api/winuser/nf-winuser-setwindowlonga"><strong>SetWindowLong</strong></a> function to set <strong>WS_EX_LAYERED</strong> after the window has been created. After the <strong>CreateWindowEx</strong> call, the layered window will not become visible until the <a href="/windows/win32/api/winuser/nf-winuser-setlayeredwindowattributes"><strong>SetLayeredWindowAttributes</strong></a> or <a href="/windows/win32/api/winuser/nf-winuser-updatelayeredwindow"><strong>UpdateLayeredWindow</strong></a> function has been called for this window.</p>
<blockquote>
<p>[!Note]<br />
Beginning with WindowsÂ 8, <strong>WS_EX_LAYERED</strong> can be used with child windows and top-level windows. Previous Windows versions support <strong>WS_EX_LAYERED</strong> only for top-level windows.</p>
</blockquote>
<p>Â </p>
<p>To set the opacity level or the transparency color key for a given layered window, call <a href="/windows/win32/api/winuser/nf-winuser-setlayeredwindowattributes"><strong>SetLayeredWindowAttributes</strong></a>. After the call, the system may still ask the window to paint when the window is shown or resized. However, because the system stores the image of a layered window, the system will not ask the window to paint if parts of it are revealed as a result of relative window moves on the desktop. Legacy applications do not need to restructure their painting code if they want to add translucency or transparency effects for a window, because the system redirects the painting of windows that called <strong>SetLayeredWindowAttributes</strong> into off-screen memory and recomposes it to achieve the desired effect.</p>
<p>For faster and more efficient animation or if per-pixel alpha is needed, call <a href="/windows/win32/api/winuser/nf-winuser-updatelayeredwindow"><strong>UpdateLayeredWindow</strong></a>. <strong>UpdateLayeredWindow</strong> should be used primarily when the application must directly supply the shape and content of a layered window, without using the redirection mechanism the system provides through <a href="/windows/win32/api/winuser/nf-winuser-setlayeredwindowattributes"><strong>SetLayeredWindowAttributes</strong></a>. In addition, using <strong>UpdateLayeredWindow</strong> directly uses memory more efficiently, because the system does not need the additional memory required for storing the image of the redirected window. For maximum efficiency in animating windows, call <strong>UpdateLayeredWindow</strong> to change the position and the size of a layered window. Please note that after <strong>SetLayeredWindowAttributes</strong> has been called, subsequent <strong>UpdateLayeredWindow</strong> calls will fail until the layering style bit is cleared and set again.</p>
<p>Hit testing of a layered window is based on the shape and transparency of the window. This means that the areas of the window that are color-keyed or whose alpha value is zero will let the mouse messages through. However, if the layered window has the <strong>WS_EX_TRANSPARENT</strong> extended window style, the shape of the layered window will be ignored and the mouse events will be passed to other windows underneath the layered window.</p>
<h3>Message-Only Windows</h3>
<p>A <em>message-only window</em> enables you to send and receive messages. It is not visible, has no z-order, cannot be enumerated, and does not receive broadcast messages. The window simply dispatches messages.</p>
<p>To create a message-only window, specify the <a href="#message-only-windows">HWND_MESSAGE</a> constant or a handle to an existing message-only window in the <em>hWndParent</em> parameter of the <a href="/windows/win32/api/winuser/nf-winuser-createwindowexa"><strong>CreateWindowEx</strong></a> function. You can also change an existing window to a message-only window by specifying HWND_MESSAGE in the <em>hWndNewParent</em> parameter of the <a href="/windows/win32/api/winuser/nf-winuser-setparent"><strong>SetParent</strong></a> function.</p>
<p>To find message-only windows, specify <a href="#message-only-windows">HWND_MESSAGE</a> in the <em>hwndParent</em> parameter of the <a href="/windows/win32/api/winuser/nf-winuser-findwindowexa"><strong>FindWindowEx</strong></a> function. In addition, <strong>FindWindowEx</strong> searches message-only windows as well as top-level windows if both the <em>hwndParent</em> and <em>hwndChildAfter</em> parameters are <strong>NULL</strong>.</p>
<h2>Window Relationships</h2>
<p>There are many ways that a window can relate to the user or another window. A window may be an owned window, foreground window, or background window. A window also has a z-order relative to other windows. For more information, see the following topics:</p>
<ul>
<li><a href="#foreground-and-background-windows">Foreground and Background Windows</a></li>
<li><a href="#owned-windows">Owned Windows</a></li>
<li><a href="#z-order">Z-Order</a></li>
</ul>
<h3>Foreground and Background Windows</h3>
<p>Each process can have multiple threads of execution, and each thread can create windows. The thread that created the window with which the user is currently working is called the foreground thread, and the window is called the <em>foreground window</em>. All other threads are background threads, and the windows created by background threads are called <em>background windows</em>.</p>
<p>Each thread has a priority level that determines the amount of CPU time the thread receives. Although an application can set the priority level of its threads, normally the foreground thread has a slightly higher priority level than the background threads. Because it has a higher priority, the foreground thread receives more CPU time than the background threads. The foreground thread has a normal base priority of 9; a background thread has a normal base priority of 7.</p>
<p>The user sets the foreground window by clicking a window, or by using the ALT+TAB or ALT+ESC key combination. To retrieve a handle to the foreground window, use the <a href="/windows/win32/api/winuser/nf-winuser-getforegroundwindow"><strong>GetForegroundWindow</strong></a> function. To check if your application window is the foreground window, compare the handle returned by <strong>GetForegroundWindow</strong> to that of your application window.</p>
<p>An application sets the foreground window by using the <a href="/windows/win32/api/winuser/nf-winuser-setforegroundwindow"><strong>SetForegroundWindow</strong></a> function.</p>
<p>The system restricts which processes can set the foreground window. A process can set the foreground window only if:</p>
<ul>
<li>All of the following conditions are true:
<ul>
<li>The process calling <strong>SetForegroundWindow</strong> belongs to a desktop application, not a UWP app or a Windows Store app designed for Windows 8 or 8.1.</li>
<li>The foreground process has not disabled calls to <strong>SetForegroundWindow</strong> by a previous call to the <a href="/windows/win32/api/winuser/nf-winuser-locksetforegroundwindow"><strong>LockSetForegroundWindow</strong></a> function.</li>
<li>The foreground lock time-out has expired (see <a href="/windows/win32/api/winuser/nf-winuser-systemparametersinfoa#SPI_GETFOREGROUNDLOCKTIMEOUT"><strong>SPI_GETFOREGROUNDLOCKTIMEOUT</strong> in <strong>SystemParametersInfo</strong></a>).</li>
<li>No menus are active.</li>
</ul>
</li>
<li>Additionally, at least one of the following conditions is true:
<ul>
<li>The calling process is the foreground process.</li>
<li>The calling process was started by the foreground process.</li>
<li>There is currently no foreground window, and thus no foreground process.</li>
<li>The calling process received the last input event.</li>
<li>Either the foreground process or the calling process is being debugged.</li>
</ul>
</li>
</ul>
<p>It is possible for a process to be denied the right to set the foreground window even if it meets these conditions.</p>
<p>A process that can set the foreground window can enable another process to set the foreground window by calling the <a href="/windows/win32/api/winuser/nf-winuser-allowsetforegroundwindow"><strong>AllowSetForegroundWindow</strong></a> function, or by calling the <a href="/windows/win32/api/winuser/nf-winuser-broadcastsystemmessage"><strong>BroadcastSystemMessage</strong></a> function with the <strong>BSF_ALLOWSFW</strong> flag. The foreground process can disable calls to <a href="/windows/win32/api/winuser/nf-winuser-setforegroundwindow"><strong>SetForegroundWindow</strong></a> by calling the <a href="/windows/win32/api/winuser/nf-winuser-locksetforegroundwindow"><strong>LockSetForegroundWindow</strong></a> function.</p>
<h3>Owned Windows</h3>
<p>An overlapped or pop-up window can be owned by another overlapped or pop-up window. Being owned places several constraints on a window.</p>
<ul>
<li>An owned window is always above its owner in the z-order.</li>
<li>The system automatically destroys an owned window when its owner is destroyed.</li>
<li>An owned window is hidden when its owner is minimized.</li>
</ul>
<p>Only an overlapped or pop-up window can be an owner window; a child window cannot be an owner window. An application creates an owned window by specifying the owner's window handle as the <em>hwndParent</em> parameter of <a href="/windows/win32/api/winuser/nf-winuser-createwindowexa"><strong>CreateWindowEx</strong></a> when it creates a window with the <a href="window-styles.html"><strong>WS_OVERLAPPED</strong></a> or <strong>WS_POPUP</strong> style. The <em>hwndParent</em> parameter must identify an overlapped or pop-up window. If <em>hwndParent</em> identifies a child window, the system assigns ownership to the top-level parent window of the child window. After creating an owned window, an application cannot transfer ownership of the window to another window.</p>
<p>Dialog boxes and message boxes are owned windows by default. An application specifies the owner window when calling a function that creates a dialog box or message box.</p>
<p>An application can use the <a href="/windows/win32/api/winuser/nf-winuser-getwindow"><strong>GetWindow</strong></a> function with the <strong>GW_OWNER</strong> flag to retrieve a handle to a window's owner.</p>
<h3>Z-Order</h3>
<p>The <em>z-order</em> of a window indicates the window's position in a stack of overlapping windows. This window stack is oriented along an imaginary axis, the z-axis, extending outward from the screen. The window at the top of the z-order overlaps all other windows. The window at the bottom of the z-order is overlapped by all other windows.</p>
<p>The system maintains the z-order in a single list. It adds windows to the z-order based on whether they are topmost windows, top-level windows, or child windows. A <em>topmost window</em> overlaps all other non-topmost windows, regardless of whether it is the active or foreground window. A topmost window has the <strong>WS_EX_TOPMOST</strong> style. All topmost windows appear in the z-order before any non-topmost windows. A child window is grouped with its parent in z-order.</p>
<p>When an application creates a window, the system puts it at the top of the z-order for windows of the same type. You can use the <a href="/windows/win32/api/winuser/nf-winuser-bringwindowtotop"><strong>BringWindowToTop</strong></a> function to bring a window to the top of the z-order for windows of the same type. You can rearrange the z-order by using the <a href="/windows/win32/api/winuser/nf-winuser-setwindowpos"><strong>SetWindowPos</strong></a> and <a href="/windows/win32/api/winuser/nf-winuser-deferwindowpos"><strong>DeferWindowPos</strong></a> functions.</p>
<p>The user changes the z-order by activating a different window. The system positions the active window at the top of the z-order for windows of the same type. When a window comes to the top of z-order, so do its child windows. You can use the <a href="/windows/win32/api/winuser/nf-winuser-gettopwindow"><strong>GetTopWindow</strong></a> function to search all child windows of a parent window and return a handle to the child window that is highest in z-order. The <a href="/windows/win32/api/winuser/nf-winuser-getnextwindow"><strong>GetNextWindow</strong></a> function retrieves a handle to the next or previous window in z-order.</p>
<h2>Window Show State</h2>
<p>At any one given time, a window may be active or inactive; hidden or visible; and minimized, maximized, or restored. These qualities are referred to collectively as the <em>window show state</em>. The following topics discuss the window show state:</p>
<ul>
<li><a href="#active-window">Active Window</a></li>
<li><a href="#disabled-windows">Disabled Windows</a></li>
<li><a href="#window-visibility">Window Visibility</a></li>
<li><a href="#minimized-maximized-and-restored-windows">Minimized, Maximized, and Restored Windows</a></li>
</ul>
<h3>Active Window</h3>
<p>An <em>active window</em> is the top-level window of the application with which the user is currently working. To allow the user to easily identify the active window, the system places it at the top of the z-order and changes the color of its title bar and border to the system-defined active window colors. Only a top-level window can be an active window. When the user is working with a child window, the system activates the top-level parent window associated with the child window.</p>
<p>Only one top-level window in the system is active at a time. The user activates a top-level window by clicking it (or one of its child windows), or by using the ALT+ESC or ALT+TAB key combination. An application activates a top-level window by calling the <a href="/windows/win32/api/winuser/nf-winuser-setactivewindow"><strong>SetActiveWindow</strong></a> function. Other functions can cause the system to activate a different top-level window, including <a href="/windows/win32/api/winuser/nf-winuser-setwindowpos"><strong>SetWindowPos</strong></a>, <a href="/windows/win32/api/winuser/nf-winuser-deferwindowpos"><strong>DeferWindowPos</strong></a>, <a href="/windows/win32/api/winuser/nf-winuser-setwindowplacement"><strong>SetWindowPlacement</strong></a>, and <a href="/windows/win32/api/winuser/nf-winuser-destroywindow"><strong>DestroyWindow</strong></a>. Although an application can activate a different top-level window at any time, to avoid confusing the user, it should do so only in response to a user action. An application uses the <a href="/windows/win32/api/winuser/nf-winuser-getactivewindow"><strong>GetActiveWindow</strong></a> function to retrieve a handle to the active window.</p>
<p>When the activation changes from a top-level window of one application to the top-level window of another, the system sends a <a href="wm-activateapp.html"><strong>WM_ACTIVATEAPP</strong></a> message to both applications, notifying them of the change. When the activation changes to a different top-level window in the same application, the system sends both windows a <a href="../inputdev/wm-activate.html"><strong>WM_ACTIVATE</strong></a> message.</p>
<h3>Disabled Windows</h3>
<p>A window can be disabled. A <em>disabled window</em> receives no keyboard or mouse input from the user, but it can receive messages from other windows, from other applications, and from the system. An application typically disables a window to prevent the user from using the window. For example, an application may disable a push button in a dialog box to prevent the user from choosing it. An application can enable a disabled window at any time; enabling a window restores normal input.</p>
<p>By default, a window is enabled when created. An application can specify the <a href="window-styles.html"><strong>WS_DISABLED</strong></a> style, however, to disable a new window. An application enables or disables an existing window by using the <a href="/windows/win32/api/winuser/nf-winuser-enablewindow"><strong>EnableWindow</strong></a> function. The system sends a <a href="wm-enable.html"><strong>WM_ENABLE</strong></a> message to a window when its enabled state is about to change. An application can determine whether a window is enabled by using the <a href="/windows/win32/api/winuser/nf-winuser-iswindowenabled"><strong>IsWindowEnabled</strong></a> function.</p>
<p>When a child window is disabled, the system passes the child's mouse input messages to the parent window. The parent uses the messages to determine whether to enable the child window. For more information, see <a href="../inputdev/mouse-input.html">Mouse Input</a>.</p>
<p>Only one window at a time can receive keyboard input; that window is said to have the keyboard focus. If an application uses the <a href="/windows/win32/api/winuser/nf-winuser-enablewindow"><strong>EnableWindow</strong></a> function to disable a keyboard-focus window, the window loses the keyboard focus in addition to being disabled. <strong>EnableWindow</strong> then sets the keyboard focus to <strong>NULL</strong>, meaning no window has the focus. If a child window, or other descendant window, has the keyboard focus, the descendant window loses the focus when the parent window is disabled. For more information, see <a href="../inputdev/keyboard-input.html">Keyboard Input</a>.</p>
<h3>Window Visibility</h3>
<p>A window can be either visible or hidden. The system displays a <em>visible window</em> on the screen. It hides a <em>hidden window</em> by not drawing it. If a window is visible, the user can supply input to the window and view the window's output. If a window is hidden, it is effectively disabled. A hidden window can process messages from the system or from other windows, but it cannot process input from the user or display output. An application sets a window's visibility state when creating the window. Later, the application can change the visibility state.</p>
<p>A window is visible when the <a href="window-styles.html"><strong>WS_VISIBLE</strong></a> style is set for the window. By default, the <a href="/windows/win32/api/winuser/nf-winuser-createwindowexa"><strong>CreateWindowEx</strong></a> function creates a hidden window unless the application specifies the <strong>WS_VISIBLE</strong> style. Typically, an application sets the <strong>WS_VISIBLE</strong> style after it has created a window to keep details of the creation process hidden from the user. For example, an application may keep a new window hidden while it customizes the window's appearance. If the <strong>WS_VISIBLE</strong> style is specified in <strong>CreateWindowEx</strong>, the system sends the <a href="wm-showwindow.html"><strong>WM_SHOWWINDOW</strong></a> message to the window after creating the window, but before displaying it.</p>
<p>An application can determine whether a window is visible by using the <a href="/windows/win32/api/winuser/nf-winuser-iswindowvisible"><strong>IsWindowVisible</strong></a> function. An application can show (make visible) or hide a window by using the <a href="/windows/win32/api/winuser/nf-winuser-showwindow"><strong>ShowWindow</strong></a>, <a href="/windows/win32/api/winuser/nf-winuser-setwindowpos"><strong>SetWindowPos</strong></a>, <a href="/windows/win32/api/winuser/nf-winuser-deferwindowpos"><strong>DeferWindowPos</strong></a>, or <a href="/windows/win32/api/winuser/nf-winuser-setwindowplacement"><strong>SetWindowPlacement</strong></a> or <a href="/windows/win32/api/winuser/nf-winuser-setwindowlonga"><strong>SetWindowLong</strong></a> function. These functions show or hide a window by setting or removing the <a href="window-styles.html"><strong>WS_VISIBLE</strong></a> style for the window. They also send the <a href="wm-showwindow.html"><strong>WM_SHOWWINDOW</strong></a> message to the window before showing or hiding it.</p>
<p>When an owner window is minimized, the system automatically hides the associated owned windows. Similarly, when an owner window is restored, the system automatically shows the associated owned windows. In both cases, the system sends the <a href="wm-showwindow.html"><strong>WM_SHOWWINDOW</strong></a> message to the owned windows before hiding or showing them. Occasionally, an application may need to hide the owned windows without having to minimize or hide the owner. In this case, the application uses the <a href="/windows/win32/api/winuser/nf-winuser-showownedpopups"><strong>ShowOwnedPopups</strong></a> function. This function sets or removes the <a href="window-styles.html"><strong>WS_VISIBLE</strong></a> style for all owned windows and sends the <strong>WM_SHOWWINDOW</strong> message to the owned windows before hiding or showing them. Hiding an owner window has no effect on the visibility state of the owned windows.</p>
<p>When a parent window is visible, its associated child windows are also visible. Similarly, when the parent window is hidden, its child windows are also hidden. Minimizing the parent window has no effect on the visibility state of the child windows; that is, the child windows are minimized along with the parent, but the <a href="window-styles.html"><strong>WS_VISIBLE</strong></a> style is not changed.</p>
<p>Even if a window has the <a href="window-styles.html"><strong>WS_VISIBLE</strong></a> style, the user may not be able to see the window on the screen; other windows may completely overlap it or it may have been moved beyond the edge of the screen. Also, a visible child window is subject to the clipping rules established by its parent-child relationship. If the window's parent window is not visible, it will also not be visible. If the parent window moves beyond the edge of the screen, the child window also moves because a child window is drawn relative to the parent's upper left corner. For example, a user may move the parent window containing the child window far enough off the edge of the screen that the user may not be able to see the child window, even though the child window and its parent window both have the <strong>WS_VISIBLE</strong> style.</p>
<h3>Minimized, Maximized, and Restored Windows</h3>
<p>A <em>maximized window</em> is a window that has the <a href="window-styles.html"><strong>WS_MAXIMIZE</strong></a> style. By default, the system enlarges a maximized window so that it fills the screen or, in the case of a child window, the parent window's client area. Although a window's size can be set to the same size of a maximized window, a maximized window is slightly different. The system automatically moves the window's title bar to the top of the screen or to the top of the parent window's client area. Also, the system disables the window's sizing border and the window-positioning capability of the title bar (so that the user cannot move the window by dragging the title bar).</p>
<p>A <em>minimized window</em> is a window that has the <a href="window-styles.html"><strong>WS_MINIMIZE</strong></a> style. By default, the system reduces a minimized window to the size of its taskbar button and moves the minimized window to the taskbar. A <em>restored window</em> is a window that has been returned to its previous size and position, that is, the size it was before it was minimized or maximized.</p>
<p>If an application specifies the <a href="window-styles.html"><strong>WS_MAXIMIZE</strong></a> or <strong>WS_MINIMIZE</strong> style in the <a href="/windows/win32/api/winuser/nf-winuser-createwindowexa"><strong>CreateWindowEx</strong></a> function, the window is initially maximized or minimized. After creating a window, an application can use the <a href="/windows/win32/api/winuser/nf-winuser-closewindow"><strong>CloseWindow</strong></a> function to minimize the window. The <a href="/windows/win32/api/winuser/nf-winuser-arrangeiconicwindows"><strong>ArrangeIconicWindows</strong></a> function arranges the icons on the desktop, or it arranges a parent window's minimized child windows in the parent window. The <a href="/windows/win32/api/winuser/nf-winuser-openicon"><strong>OpenIcon</strong></a> function restores a minimized window to its previous size and position.</p>
<p>The <a href="/windows/win32/api/winuser/nf-winuser-showwindow"><strong>ShowWindow</strong></a> function can minimize, maximize, or restore a window. It can also set the window's visibility and activation states. The <a href="/windows/win32/api/winuser/nf-winuser-setwindowplacement"><strong>SetWindowPlacement</strong></a> function includes the same functionality as <strong>ShowWindow</strong>, but it can override the window's default minimized, maximized, and restored positions.</p>
<p>The <a href="/windows/win32/api/winuser/nf-winuser-iszoomed"><strong>IsZoomed</strong></a> and <a href="/windows/win32/api/winuser/nf-winuser-isiconic"><strong>IsIconic</strong></a> functions determine whether a given window is maximized or minimized, respectively. The <a href="/windows/win32/api/winuser/nf-winuser-getwindowplacement"><strong>GetWindowPlacement</strong></a> function retrieves the minimized, maximized, and restored positions for the window, and also determines the window's show state.</p>
<p>When the system receives a command to maximize or restore a minimized window, it sends the window a <a href="wm-queryopen.html"><strong>WM_QUERYOPEN</strong></a> message. If the window procedure returns <strong>FALSE</strong>, the system ignores the maximize or restore command.</p>
<p>The system automatically sets the size and position of a maximized window to the system-defined defaults for a maximized window. To override these defaults, an application can either call the <a href="/windows/win32/api/winuser/nf-winuser-setwindowplacement"><strong>SetWindowPlacement</strong></a> function or process the <a href="wm-getminmaxinfo.html"><strong>WM_GETMINMAXINFO</strong></a> message that is received by a window when the system is about to maximize the window. <strong>WM_GETMINMAXINFO</strong> includes a pointer to a <a href="/windows/win32/api/winuser/ns-winuser-minmaxinfo"><strong>MINMAXINFO</strong></a> structure containing values the system uses to set the maximized size and position. Replacing these values overrides the defaults.</p>
<h2>Window Size and Position</h2>
<p>A window's size and position are expressed as a bounding rectangle, given in coordinates relative to the screen or the parent window. The coordinates of a top-level window are relative to the upper left corner of the screen; the coordinates of a child window are relative to the upper left corner of the parent window. An application specifies a window's initial size and position when it creates the window, but it can change the window's size and position at any time. For more information, see <a href="../gdi/filled-shapes.html">Filled Shapes</a>.</p>
<p>This section contains the following topics:</p>
<ul>
<li><a href="#default-size-and-position">Default Size and Position</a></li>
<li><a href="#tracking-size">Tracking Size</a></li>
<li><a href="#system-commands">System Commands</a></li>
<li><a href="#size-and-position-functions">Size and Position Functions</a></li>
<li><a href="#size-and-position-messages">Size and Position Messages</a></li>
</ul>
<h3>Default Size and Position</h3>
<p>An application can allow the system to calculate the initial size or position of a top-level window by specifying CW_USEDEFAULT in <a href="/windows/win32/api/winuser/nf-winuser-createwindowexa"><strong>CreateWindowEx</strong></a>. If the application sets the window's coordinates to CW_USEDEFAULT and has created no other top-level windows, the system sets the new window's position relative to the upper left corner of the screen; otherwise, it sets the position relative to the position of the top-level window that the application created most recently. If the width and height parameters are set to CW_USEDEFAULT, the system calculates the size of the new window. If the application has created other top-level windows, the system bases the size of the new window on the size of the application's most recently created top-level window. Specifying CW_USEDEFAULT when creating a child or pop-up window causes the system to set the window's size to the default minimum window size.</p>
<h3>Tracking Size</h3>
<p>The system maintains a minimum and maximum tracking size for a window of the <a href="window-styles.html"><strong>WS_THICKFRAME</strong></a> style; a window with this style has a sizing border. The <em>minimum tracking size</em> is the smallest window size you can produce by dragging the window's sizing border. Similarly, the <em>maximum tracking size</em> is the largest window size you can produce by dragging the sizing border.</p>
<p>A window's minimum and maximum tracking sizes are set to system-defined default values when the system creates the window. An application can discover the defaults and override them by processing the <a href="wm-getminmaxinfo.html"><strong>WM_GETMINMAXINFO</strong></a> message. For more information, see <a href="#size-and-position-messages">Size and Position Messages</a>.</p>
<h3>System Commands</h3>
<p>An application that has a window menu can change the size and position of that window by sending system commands. System commands are generated when the user chooses commands from the window menu. An application can emulate the user action by sending a <a href="../menurc/wm-syscommand.html"><strong>WM_SYSCOMMAND</strong></a> message to the window. The following system commands affect the size and position of a window.</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>SC_CLOSE</td>
<td>Closes the window. This command sends a <a href="wm-close.html"><strong>WM_CLOSE</strong></a> message to the window. The window carries out any steps needed to clean up and destroy itself.</td>
</tr>
<tr>
<td>SC_MAXIMIZE</td>
<td>Maximizes the window.</td>
</tr>
<tr>
<td>SC_MINIMIZE</td>
<td>Minimizes the window.</td>
</tr>
<tr>
<td>SC_MOVE</td>
<td>Moves the window.</td>
</tr>
<tr>
<td>SC_RESTORE</td>
<td>Restores a minimized or maximized window to its previous size and position.</td>
</tr>
<tr>
<td>SC_SIZE</td>
<td>Starts a size command. To change the size of the window, use the mouse or keyboard.</td>
</tr>
</tbody>
</table>
<p>Â </p>
<h3>Size and Position Functions</h3>
<p>After creating a window, an application can set the window's size or position by calling one of several different functions, including <a href="/windows/win32/api/winuser/nf-winuser-setwindowplacement"><strong>SetWindowPlacement</strong></a>, <a href="/windows/win32/api/winuser/nf-winuser-movewindow"><strong>MoveWindow</strong></a>, <a href="/windows/win32/api/winuser/nf-winuser-setwindowpos"><strong>SetWindowPos</strong></a>, and <a href="/windows/win32/api/winuser/nf-winuser-deferwindowpos"><strong>DeferWindowPos</strong></a>. <strong>SetWindowPlacement</strong> sets a window's minimized position, maximized position, restored size and position, and show state. The <strong>MoveWindow</strong> and <strong>SetWindowPos</strong> functions are similar; both set the size or position of a single application window. The <strong>SetWindowPos</strong> function includes a set of flags that affect the window's show state; <strong>MoveWindow</strong> does not include these flags. Use the <a href="/windows/win32/api/winuser/nf-winuser-begindeferwindowpos"><strong>BeginDeferWindowPos</strong></a>, <strong>DeferWindowPos</strong>, and <a href="/windows/win32/api/winuser/nf-winuser-enddeferwindowpos"><strong>EndDeferWindowPos</strong></a> functions to simultaneously set the position of a number of windows, including the size, position, position in the z-order, and show state.</p>
<p>An application can retrieve the coordinates of a window's bounding rectangle by using the <a href="/windows/win32/api/winuser/nf-winuser-getwindowrect"><strong>GetWindowRect</strong></a> function. <strong>GetWindowRect</strong> fills a <a href="/windows/win32/api/windef/ns-windef-rect"><strong>RECT</strong></a> structure with the coordinates of the window's upper left and lower right corners. The coordinates are relative to the upper left corner of the screen, even for a child window. The <a href="/windows/win32/api/winuser/nf-winuser-screentoclient"><strong>ScreenToClient</strong></a> or <a href="/windows/win32/api/winuser/nf-winuser-mapwindowpoints"><strong>MapWindowPoints</strong></a> function maps the screen coordinates of a child window's bounding rectangle to coordinates relative to the parent window's client area.</p>
<p>The <a href="/windows/win32/api/winuser/nf-winuser-getclientrect"><strong>GetClientRect</strong></a> function retrieves the coordinates of a window's client area. <strong>GetClientRect</strong> fills a <a href="/windows/win32/api/windef/ns-windef-rect"><strong>RECT</strong></a> structure with the coordinates of the upper left and lower right corners of the client area, but the coordinates are relative to the client area itself. This means the coordinates of a client area's upper left corner are always (0,0), and the coordinates of the lower right corner are the width and height of the client area.</p>
<p>The <a href="/windows/win32/api/winuser/nf-winuser-cascadewindows"><strong>CascadeWindows</strong></a> function cascades the windows on the desktop or cascades the child windows of the specified parent window. The <a href="/windows/win32/api/winuser/nf-winuser-tilewindows"><strong>TileWindows</strong></a> function tiles the windows on the desktop or tiles the child windows of the specified parent window.</p>
<h3>Size and Position Messages</h3>
<p>The system sends the <a href="wm-getminmaxinfo.html"><strong>WM_GETMINMAXINFO</strong></a> message to a window whose size or position is about to change. For example, the message is sent when the user clicks <strong>Move</strong> or <strong>Size</strong> from the window menu or clicks the sizing border or title bar; the message is also sent when an application calls <a href="/windows/win32/api/winuser/nf-winuser-setwindowpos"><strong>SetWindowPos</strong></a> to move or size the window. <strong>WM_GETMINMAXINFO</strong> includes a pointer to a <a href="/windows/win32/api/winuser/ns-winuser-minmaxinfo"><strong>MINMAXINFO</strong></a> structure containing the default maximized size and position for the window, as well as the default minimum and maximum tracking sizes. An application can override the defaults by processing <strong>WM_GETMINMAXINFO</strong> and setting the appropriate members of <strong>MINMAXINFO</strong>. A window must have the <a href="window-styles.html"><strong>WS_THICKFRAME</strong></a> or <strong>WS_CAPTION</strong> style to receive <strong>WM_GETMINMAXINFO</strong>. A window with the <strong>WS_THICKFRAME</strong> style receives this message during the window-creation process, as well as when it is being moved or sized.</p>
<p>The system sends the <a href="wm-windowposchanging.html"><strong>WM_WINDOWPOSCHANGING</strong></a> message to a window whose size, position, position in the z-order, or show state is about to change. This message includes a pointer to a <a href="/windows/win32/api/winuser/ns-winuser-windowpos"><strong>WINDOWPOS</strong></a> structure that specifies the window's new size, position, position in the z-order, and show state. By setting the members of <strong>WINDOWPOS</strong>, an application can affect the window's new size, position, and appearance.</p>
<p>After changing a window's size, position, position in the z-order, or show state, the system sends the <a href="wm-windowposchanged.html"><strong>WM_WINDOWPOSCHANGED</strong></a> message to the window. This message includes a pointer to <a href="/windows/win32/api/winuser/ns-winuser-windowpos"><strong>WINDOWPOS</strong></a> that informs the window of its new size, position, position in the z-order, and show state. Setting the members of the <strong>WINDOWPOS</strong> structure that is passed with <strong>WM_WINDOWPOSCHANGED</strong> has no effect on the window. A window that must process <a href="wm-size.html"><strong>WM_SIZE</strong></a> and <a href="wm-move.html"><strong>WM_MOVE</strong></a> messages must pass <strong>WM_WINDOWPOSCHANGED</strong> to the <a href="/windows/desktop/api/winuser/nf-winuser-defwindowproca"><strong>DefWindowProc</strong></a> function; otherwise, the system does not send <strong>WM_SIZE</strong> and <strong>WM_MOVE</strong> messages to the window.</p>
<p>The system sends the <a href="wm-nccalcsize.html"><strong>WM_NCCALCSIZE</strong></a> message to a window when the window is created or sized. The system uses the message to calculate the size of a window's client area and the position of the client area relative to the upper left corner of the window. A window typically passes this message to the default window procedure; however, this message can be useful in applications that customize a window's nonclient area or preserve portions of the client area when the window is sized. For more information, see <a href="../gdi/painting-and-drawing.html">Painting and Drawing</a>.</p>
<h2>Window Animation</h2>
<p>You can produce special effects when showing or hiding windows by using the <a href="/windows/win32/api/winuser/nf-winuser-animatewindow"><strong>AnimateWindow</strong></a> function. When the window is animated in this manner, the system will either roll, slide, or fade the window, depending on the flags you specify in a call to <strong>AnimateWindow</strong>.</p>
<p>By default, the system uses <em>roll animation</em>. With this effect, the window appears to roll open (showing the window) or roll closed (hiding the window). You can use the <em>dwFlags</em> parameter to specify whether the window rolls horizontally, vertically, or diagonally.</p>
<p>When you specify the <strong>AW_SLIDE</strong> flag, the system uses <em>slide animation</em>. With this effect, the window appears to slide into view (showing the window) or slide out of view (hiding the window). You can use the <em>dwFlags</em> parameter to specify whether the window slides horizontally, vertically, or diagonally.</p>
<p>When you specify the <strong>AW_BLEND</strong> flag, the system uses an <em>alpha-blended fade</em>.</p>
<p>You can also use the <strong>AW_CENTER</strong> flag to make a window appear to collapse inward or expand outward.</p>
<h2>Window Layout and Mirroring</h2>
<p>The window layout defines how text and Windows Graphics Device Interface (GDI) objects are laid out in a window or device context (DC). Some languages, such as English, French, and German, require a left-to-right (LTR) layout. Other languages, such as Arabic and Hebrew, require right-to-left (RTL) layout. The window layout applies to text but also affects the other GDI elements of the window, including bitmaps, icons, the location of the origin, buttons, cascading tree controls, and whether the horizontal coordinate increases as you go left or right. For example, after an application has set RTL layout, the origin is positioned at the right edge of the window or device, and the number representing the horizontal coordinate increases as you move left. However, not all objects are affected by the layout of a window. For example, the layout for dialog boxes, message boxes, and device contexts that are not associated with a window, such as metafile and printer DCs, must be handled separately. Specifics for these are mentioned later in this topic.</p>
<p>The window functions allow you to specify or change the window layout in Arabic and Hebrew versions of Windows. Note that changing to a RTL layout (also known as mirroring) is not supported for windows that have the style <a href="about-window-classes.html">CS_OWNDC</a> or for a DC with the GM_ADVANCED graphic mode.</p>
<p>By default, the window layout is left-to-right (LTR). To set the RTL window layout, call <a href="/windows/win32/api/winuser/nf-winuser-createwindowexa"><strong>CreateWindowEx</strong></a> with the style <strong>WS_EX_LAYOUTRTL</strong>. Also by default, a child window (that is, one created with the <a href="window-styles.html"><strong>WS_CHILD</strong></a> style and with a valid parent <em>hWnd</em> parameter in the call to <a href="/windows/win32/api/winuser/nf-winuser-createwindowa"><strong>CreateWindow</strong></a> or <strong>CreateWindowEx</strong>) has the same layout as its parent. To disable inheritance of mirroring to all child windows, specify <strong>WS_EX_NOINHERITLAYOUT</strong> in the call to <strong>CreateWindowEx</strong>. Note, mirroring is not inherited by owned windows (those created without the <strong>WS_CHILD</strong> style) or those created with the parent <em>hWnd</em> parameter in <strong>CreateWindowEx</strong> set to <strong>NULL</strong>. To disable inheritance of mirroring for an individual window, process the <a href="wm-nccreate.html"><strong>WM_NCCREATE</strong></a> message with <a href="/windows/win32/api/winuser/nf-winuser-getwindowlonga"><strong>GetWindowLong</strong></a> and <a href="/windows/win32/api/winuser/nf-winuser-setwindowlonga"><strong>SetWindowLong</strong></a> to turn off the <strong>WS_EX_LAYOUTRTL</strong> flag. This processing is in addition to whatever other processing is needed. The following code fragment shows how this is done.</p>
<pre><code>SetWindowLong (hWnd, 
               GWL_EXSTYLE, 
               GetWindowLong(hWnd,GWL_EXSTYLE) &amp; ~WS_EX_LAYOUTRTL))
</code></pre>
<p>You can set the default layout to RTL by calling <a href="/windows/win32/api/winuser/nf-winuser-setprocessdefaultlayout"><strong>SetProcessDefaultLayout</strong></a>(LAYOUT_RTL). All windows created after the call will be mirrored, but existing windows are not affected. To turn off default mirroring, call <strong>SetProcessDefaultLayout</strong>(0).</p>
<p>Note, <a href="/windows/win32/api/winuser/nf-winuser-setprocessdefaultlayout"><strong>SetProcessDefaultLayout</strong></a> mirrors the DCs only of mirrored windows. To mirror any DC, call <a href="/windows/win32/api/wingdi/nf-wingdi-setlayout"><strong>SetLayout</strong></a>(hdc, LAYOUT_RTL). For more information, see the discussion on mirroring device contexts not associated with windows, which comes later in this topic.</p>
<p>Bitmaps and icons in a mirrored window are also mirrored by default. However, not all of these should be mirrored. For example, those with text, a business logo, or an analog clock should not be mirrored. To disable mirroring of bitmaps, call <a href="/windows/win32/api/wingdi/nf-wingdi-setlayout"><strong>SetLayout</strong></a> with the LAYOUT_BITMAPORIENTATIONPRESERVED bit set in <em>dwLayout</em>. To disable mirroring in a DC, call <strong>SetLayout</strong>(hdc, 0).</p>
<p>To query the current default layout, call <a href="/windows/win32/api/winuser/nf-winuser-getprocessdefaultlayout"><strong>GetProcessDefaultLayout</strong></a>. Upon a successful return, <em>pdwDefaultLayout</em> contains LAYOUT_RTL or 0. To query the layout settings of the device context, call <a href="/windows/win32/api/wingdi/nf-wingdi-getlayout"><strong>GetLayout</strong></a>. Upon a successful return, <strong>GetLayout</strong> returns a <strong>DWORD</strong> that indicates the layout settings by the settings of the LAYOUT_RTL and the LAYOUT_BITMAPORIENTATIONPRESERVED bits.</p>
<p>After a window has been created, you change the layout using the <a href="/windows/win32/api/winuser/nf-winuser-setwindowlonga"><strong>SetWindowLong</strong></a> function. For example, this is necessary when the user changes the user interface language of an existing window from Arabic or Hebrew to German. However, when changing the layout of an existing window, you must invalidate and update the window to ensure that the contents of the window are all drawn on the same layout. The following code example is from sample code that changes the window layout as needed:</p>
<pre><code>// Using ANSI versions of GetWindowLong and SetWindowLong because Unicode
// is not needed for these calls

lExStyles = GetWindowLongA(hWnd, GWL_EXSTYLE);

// Check whether new layout is opposite the current layout
if (!!(pLState -&gt; IsRTLLayout) != !!(lExStyles &amp; WS_EX_LAYOUTRTL))
{
    // the following lines will update the window layout

    lExStyles ^= WS_EX_LAYOUTRTL;        // toggle layout
    SetWindowLongA(hWnd, GWL_EXSTYLE, lExStyles);
    InvalidateRect(hWnd, NULL, TRUE);    // to update layout in the client area
}
</code></pre>
<p>In mirroring, you should think in terms of &quot;near&quot; and &quot;far&quot; instead of &quot;left&quot; and &quot;right&quot;. Failure to do so can cause problems. One common coding practice that causes problems in a mirrored window occurs when mapping between screen coordinates and client coordinates. For example, applications often use code similar to the following to position a control in a window:</p>
<pre><code>// DO NOT USE THIS IF APPLICATION MIRRORS THE WINDOW

// get coordinates of the window in screen coordinates
GetWindowRect(hControl, (LPRECT) &amp;rControlRect);  

// map screen coordinates to client coordinates in dialog
ScreenToClient(hDialog, (LPPOINT) &amp;rControlRect.left); 
ScreenToClient(hDialog, (LPPOINT) &amp;rControlRect.right);
</code></pre>
<p>This causes problems in mirroring because the left edge of the rectangle becomes the right edge in a mirrored window, and vice versa. To avoid this problem, replace the <a href="/windows/win32/api/winuser/nf-winuser-screentoclient"><strong>ScreenToClient</strong></a> calls with a call to <a href="/windows/win32/api/winuser/nf-winuser-mapwindowpoints"><strong>MapWindowPoints</strong></a> as follows:</p>
<pre><code>// USE THIS FOR MIRRORING

GetWindowRect(hControl, (LPRECT) &amp;rControlRect);
MapWindowPoints(NULL, hDialog, (LPPOINT) &amp;rControlRect, 2)
</code></pre>
<p>This code works because, on platforms that support mirroring, <a href="/windows/win32/api/winuser/nf-winuser-mapwindowpoints"><strong>MapWindowPoints</strong></a> is modified to swap the left and right point coordinates when the client window is mirrored. For more information, see the Remarks section of <strong>MapWindowPoints</strong>.</p>
<p>Another common practice that can cause problems in mirrored windows is positioning objects in a client window using offsets in screen coordinates instead of client coordinates. For example, the following code uses the difference in screen coordinates as the x position in client coordinates to position a control in a dialog box.</p>
<pre><code>// OK if LTR layout and mapping mode of client is MM_TEXT,
// but WRONG for a mirrored dialog 

RECT rdDialog;
RECT rcControl;

HWND hControl = GetDlgItem(hDlg, IDD_CONTROL);
GetWindowRect(hDlg, &amp;rcDialog);             // gets rect in screen coordinates
GetWindowRect(hControl, &amp;rcControl);
MoveWindow(hControl,
           rcControl.left - rcDialog.left,  // uses x position in client coords
           rcControl.top - rcDialog.top,
           nWidth,
           nHeight,
           FALSE);
</code></pre>
<p>This code is fine when the dialog window has left-to-right (LTR) layout and the mapping mode of the client is MM_TEXT, because the new x position in client coordinates corresponds to the difference in left edges of the control and the dialog in screen coordinates. However, in a mirrored dialog, left and right are reversed, so instead you should use <a href="/windows/win32/api/winuser/nf-winuser-mapwindowpoints"><strong>MapWindowPoints</strong></a> as follows:</p>
<pre><code>RECT rcDialog;
RECT rcControl;

HWND hControl - GetDlgItem(hDlg, IDD_CONTROL);
GetWindowRect(hControl, &amp;rcControl);

// MapWindowPoints works correctly in both mirrored and non-mirrored windows.
MapWindowPoints(NULL, hDlg, (LPPOINT) &amp;rcControl, 2);

// Now rcControl is in client coordinates.
MoveWindow(hControl, rcControl.left, rcControl.top, nWidth, nHeight, FALSE)
</code></pre>
<h3>Mirroring Dialog Boxes and Message Boxes</h3>
<p>Dialog boxes and message boxes do not inherit layout, so you must set the layout explicitly. To mirror a message box, call <a href="/windows/win32/api/winuser/nf-winuser-messagebox"><strong>MessageBox</strong></a> or <a href="/windows/win32/api/winuser/nf-winuser-messageboxexa"><strong>MessageBoxEx</strong></a> with the <strong>MB_RTLREADING</strong> option. To layout a dialog box right-to-left, use the extended style WS_EX_LAYOUTRTL in the dialog template structure <a href="../dlgbox/dlgtemplateex.html"><strong>DLGTEMPLATEEX</strong></a>. Property sheets are a special case of dialog boxes. Each tab is treated as a separate dialog box, so you need to include the WS_EX_LAYOUTRTL style in every tab that you want mirrored.</p>
<h3>Mirroring Device Contexts Not Associated with a Window</h3>
<p>DCs that are not associated with a window, such as metafile or printer DCs, do not inherit layout, so you must set the layout explicitly. To change the device context layout, use the <a href="/windows/win32/api/wingdi/nf-wingdi-setlayout"><strong>SetLayout</strong></a> function.</p>
<p>The <a href="/windows/win32/api/wingdi/nf-wingdi-setlayout"><strong>SetLayout</strong></a> function is rarely used with windows. Typically, windows receive an associated DC only in processing a <a href="../gdi/wm-paint.html"><strong>WM_PAINT</strong></a> message. Occasionally, a program creates a DC for a window by calling <a href="/windows/win32/api/winuser/nf-winuser-getdc"><strong>GetDC</strong></a>. Either way, the initial layout for the DC is set by <a href="/windows/win32/api/winuser/nf-winuser-beginpaint"><strong>BeginPaint</strong></a> or <strong>GetDC</strong> according to the window's WS_EX_LAYOUTRTL flag.</p>
<p>The values returned by <a href="/windows/win32/api/wingdi/nf-wingdi-getwindoworgex"><strong>GetWindowOrgEx</strong></a>, <a href="/windows/win32/api/wingdi/nf-wingdi-getwindowextex"><strong>GetWindowExtEx</strong></a>, <a href="/windows/win32/api/wingdi/nf-wingdi-getviewportorgex"><strong>GetViewportOrgEx</strong></a> and <a href="/windows/win32/api/wingdi/nf-wingdi-getviewportextex"><strong>GetViewportExtEx</strong></a> are not affected by calling <a href="/windows/win32/api/wingdi/nf-wingdi-setlayout"><strong>SetLayout</strong></a>.</p>
<p>When the layout is RTL, <a href="/windows/win32/api/wingdi/nf-wingdi-getmapmode"><strong>GetMapMode</strong></a> will return MM_ANISOTROPIC instead of MM_TEXT. Calling <a href="/windows/win32/api/wingdi/nf-wingdi-setmapmode"><strong>SetMapMode</strong></a> with MM_TEXT will function correctly; only the return value from <strong>GetMapMode</strong> is affected. Similarly, calling <a href="/windows/win32/api/wingdi/nf-wingdi-setlayout"><strong>SetLayout</strong></a>(hdc, LAYOUT_RTL) when the mapping mode is MM_TEXT causes the reported mapping mode to change to MM_ANISOTROPIC.</p>
<h2>Window Destruction</h2>
<p>In general, an application must destroy all the windows it creates. It does this by using the <a href="/windows/win32/api/winuser/nf-winuser-destroywindow"><strong>DestroyWindow</strong></a> function. When a window is destroyed, the system hides the window, if it is visible, and then removes any internal data associated with the window. This invalidates the window handle, which can no longer be used by the application.</p>
<p>An application destroys many of the windows it creates soon after creating them. For example, an application usually destroys a dialog box window as soon as the application has sufficient input from the user to continue its task. An application eventually destroys the main window of the application (before terminating).</p>
<p>Before destroying a window, an application should save or remove any data associated with the window, and it should release any system resources allocated for the window. If the application does not release the resources, the system will free any resources not freed by the application.</p>
<p>Destroying a window does not affect the window class from which the window is created. New windows can still be created using that class, and any existing windows of that class continue to operate. Destroying a window also destroys the window's descendant windows. The <a href="/windows/win32/api/winuser/nf-winuser-destroywindow"><strong>DestroyWindow</strong></a> function sends a <a href="wm-destroy.html"><strong>WM_DESTROY</strong></a> message first to the window, then to its child windows and descendant windows. In this way, all descendant windows of the window being destroyed are also destroyed.</p>
<p>A window with a window menu receives a <a href="wm-close.html"><strong>WM_CLOSE</strong></a> message when the user clicks <strong>Close</strong>. By processing this message, an application can prompt the user for confirmation before destroying the window. If the user confirms that the window should be destroyed, the application can call the <a href="/windows/win32/api/winuser/nf-winuser-destroywindow"><strong>DestroyWindow</strong></a> function to destroy the window.</p>
<p>If the window being destroyed is the active window, both the active and focus states are transferred to another window. The window that becomes the active window is the next window, as determined by the ALT+ESC key combination. The new active window then determines which window receives the keyboard focus.</p>
<p>Â </p>
<p>Â </p>
</body>
