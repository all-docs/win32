<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>About Messages and Message Queues</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<h2>description: This section discusses Windows messages and message queues.
ms.assetid: 21a4d40b-52da-49e4-a374-afc4927e96e8
title: About Messages and Message Queues
ms.topic: article
ms.date: 10/26/2021</h2>
<h1>About Messages and Message Queues</h1>
<p>Unlike MS-DOS-based applications, Windows-based applications are event-driven. They do not make explicit function calls (such as C run-time library calls) to obtain input. Instead, they wait for the system to pass input to them.</p>
<p>The system passes all input for an application to the various windows in the application. Each window has a function, called a window procedure, that the system calls whenever it has input for the window. The window procedure processes the input and returns control to the system. For more information about window procedures, see <a href="window-procedures.html">Window Procedures</a>.</p>
<p>If a top-level window stops responding to messages for more than several seconds, the system considers the window to be not responding. In this case, the system hides the window and replaces it with a ghost window that has the same Z order, location, size, and visual attributes. This allows the user to move it, resize it, or even close the application. However, these are the only actions available because the application is actually not responding. When in the debugger mode, the system does not generate a ghost window.</p>
<p>This section discusses the following topics:</p>
<ul>
<li><a href="#windows-messages">Windows Messages</a></li>
<li><a href="#message-types">Message Types</a>
<ul>
<li><a href="#system-defined-messages">System-Defined Messages</a></li>
<li><a href="#application-defined-messages">Application-Defined Messages</a></li>
</ul>
</li>
<li><a href="#message-routing">Message Routing</a>
<ul>
<li><a href="#queued-messages">Queued Messages</a></li>
<li><a href="#nonqueued-messages">Nonqueued Messages</a></li>
</ul>
</li>
<li><a href="#message-handling">Message Handling</a>
<ul>
<li><a href="#message-loop">Message Loop</a></li>
<li><a href="#window-procedure">Window Procedure</a></li>
</ul>
</li>
<li><a href="#message-filtering">Message Filtering</a></li>
<li><a href="#posting-and-sending-messages">Posting and Sending Messages</a>
<ul>
<li><a href="#posting-messages">Posting Messages</a></li>
<li><a href="#sending-messages">Sending Messages</a></li>
</ul>
</li>
<li><a href="#message-deadlocks">Message Deadlocks</a></li>
<li><a href="#broadcasting-messages">Broadcasting Messages</a></li>
<li><a href="#query-messages">Query Messages</a></li>
</ul>
<h2>Windows Messages</h2>
<p>The system passes input to a window procedure in the form of a <em>message</em>. Messages are generated by both the system and applications. The system generates a message at each input eventâ€”for example, when the user types, moves the mouse, or clicks a control such as a scroll bar. The system also generates messages in response to changes in the system brought about by an application, such as when an application changes the pool of system font resources or resizes one of its windows. An application can generate messages to direct its own windows to perform tasks or to communicate with windows in other applications.</p>
<p>The system sends a message to a window procedure with a set of four parameters: a window handle, a message identifier, and two values called <em>message parameters</em>. The <em>window handle</em> identifies the window for which the message is intended. The system uses it to determine which window procedure should receive the message.</p>
<p>A <em>message identifier</em> is a named constant that identifies the purpose of a message. When a window procedure receives a message, it uses a message identifier to determine how to process the message. For example, the message identifier <a href="/windows/desktop/gdi/wm-paint"><strong>WM_PAINT</strong></a> tells the window procedure that the window's client area has changed and must be repainted.</p>
<p>Message parameters specify data or the location of data used by a window procedure when processing a message. The meaning and value of the message parameters depend on the message. A message parameter can contain an integer, packed bit flags, a pointer to a structure containing additional data, and so on. When a message does not use message parameters, they are typically set to <strong>NULL</strong>. A window procedure must check the message identifier to determine how to interpret the message parameters.</p>
<h2>Message Types</h2>
<p>This section describes the two types of messages:</p>
<ul>
<li><a href="#system-defined-messages">System-Defined Messages</a></li>
<li><a href="#application-defined-messages">Application-Defined Messages</a></li>
</ul>
<h3>System-Defined Messages</h3>
<p>The system sends or posts a <em>system-defined message</em> when it communicates with an application. It uses these messages to control the operations of applications and to provide input and other information for applications to process. An application can also send or post system-defined messages. Applications generally use these messages to control the operation of control windows created by using preregistered window classes.</p>
<p>Each system-defined message has a unique message identifier and a corresponding symbolic constant (defined in the software development kit (SDK) header files) that states the purpose of the message. For example, the <a href="/windows/desktop/gdi/wm-paint"><strong>WM_PAINT</strong></a> constant requests that a window paint its contents.</p>
<p>Symbolic constants specify the category to which system-defined messages belong. The prefix of the constant identifies the type of window that can interpret and process the message. Following are the prefixes and their related message categories.</p>
<table>
<thead>
<tr>
<th>Prefix</th>
<th>Message category</th>
<th>Documentation</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ABM</strong> and <strong>ABN</strong></td>
<td>Application desktop toolbar</td>
<td><a href="/windows/desktop/shell/control-panel-applications">Shell Messages and Notifications</a></td>
</tr>
<tr>
<td><strong>ACM</strong> and <strong>ACN</strong></td>
<td>Animation control</td>
<td><a href="/windows/desktop/Controls/bumper-animation-control-reference-messages">Animation Control Messages</a> and <a href="/windows/desktop/Controls/bumper-animation-control-reference-notifications">Animation Control Notifications</a></td>
</tr>
<tr>
<td><strong>BCM</strong>, <strong>BCN</strong>, <strong>BM</strong>, and <strong>BN</strong></td>
<td>Button control</td>
<td><a href="/windows/desktop/Controls/bumper-button-control-reference-messages">Button Control Messages</a> and <a href="/windows/desktop/Controls/bumper-button-control-reference-notifications">Button Control Notifications</a></td>
</tr>
<tr>
<td><strong>CB</strong> and <strong>CBN</strong></td>
<td>ComboBox control</td>
<td><a href="/windows/desktop/Controls/bumper-combobox-control-reference-messages">ComboBox Control Messages</a> and <a href="/windows/desktop/Controls/bumper-combobox-control-reference-notifications">ComboBox Control Notifications</a></td>
</tr>
<tr>
<td><strong>CBEM</strong> and <strong>CBEN</strong></td>
<td>ComboBoxEx control</td>
<td><a href="/windows/desktop/Controls/bumper-comboboxex-control-reference-messages">ComboBoxEx Messages</a> and <a href="/windows/desktop/Controls/bumper-comboboxex-control-reference-notifications">ComboBoxEx Notifications</a></td>
</tr>
<tr>
<td><strong>CCM</strong></td>
<td>General control</td>
<td><a href="/windows/desktop/Controls/bumper-general-control-reference-messages">Control Messages</a></td>
</tr>
<tr>
<td><strong>CDM</strong></td>
<td>Common dialog box</td>
<td><a href="/windows/desktop/dlgbox/common-dialog-box-messages">Common Dialog Box Messages</a></td>
</tr>
<tr>
<td><strong>DFM</strong></td>
<td>Default context menu</td>
<td><a href="/windows/desktop/shell/control-panel-applications">Shell Messages and Notifications</a></td>
</tr>
<tr>
<td><strong>DL</strong></td>
<td>Drag list box</td>
<td><a href="/previous-versions//ff485914(v=vs.85)">Drag List Box Notifications</a></td>
</tr>
<tr>
<td><strong>DM</strong></td>
<td>Default push button control</td>
<td><a href="/windows/desktop/dlgbox/dialog-box-messages">Dialog Box Messages</a></td>
</tr>
<tr>
<td><strong>DTM</strong> and <strong>DTN</strong></td>
<td>Date and time picker control</td>
<td><a href="/windows/desktop/Controls/bumper-date-and-time-picker-control-reference-messages">Date and Time Picker Messages</a> and <a href="/windows/desktop/Controls/bumper-date-and-time-picker-control-reference-notifications">Date and Time Picker Notifications</a></td>
</tr>
<tr>
<td><strong>EM</strong> and <strong>EN</strong></td>
<td>Edit control</td>
<td><a href="/windows/desktop/Controls/bumper-edit-control-reference-messages">Edit Control Messages</a>, <a href="/windows/desktop/Controls/bumper-edit-control-reference-notifications">Edit Control Notifications</a>, <a href="/windows/desktop/Controls/bumper-rich-edit-control-reference-messages">Rich Edit Messages</a>, and <a href="/windows/desktop/Controls/bumper-rich-edit-control-reference-notifications">Rich Edit Notifications</a></td>
</tr>
<tr>
<td><strong>HDM</strong> and <strong>HDN</strong></td>
<td>Header control</td>
<td><a href="/windows/desktop/Controls/bumper-header-control-reference-messages">Header Control Messages</a> and <a href="/windows/desktop/Controls/bumper-header-control-reference-notifications">Header Control Notifications</a></td>
</tr>
<tr>
<td><strong>HKM</strong></td>
<td>Hot key control</td>
<td><a href="/windows/desktop/Controls/bumper-hot-key-control-reference-messages">Hot Key Control Messages</a></td>
</tr>
<tr>
<td><strong>IPM</strong> and <strong>IPN</strong></td>
<td>IP address control</td>
<td><a href="/windows/desktop/Controls/bumper-ip-address-control-reference-messages">IP Address Messages</a> and <a href="/windows/desktop/Controls/bumper-ip-address-control-reference-notifications">IP Address Notifications</a></td>
</tr>
<tr>
<td><strong>LB</strong> and <strong>LBN</strong></td>
<td>List box control</td>
<td><a href="/windows/desktop/Controls/bumper-list-box-control-reference-messages">List Box Messages</a> and <a href="/windows/desktop/Controls/bumper-list-box-control-reference-notifications">List Box Notifications</a></td>
</tr>
<tr>
<td><strong>LM</strong></td>
<td>SysLink control</td>
<td><a href="/windows/desktop/Controls/bumper-syslink-control-reference-messages">SysLink Control Messages</a></td>
</tr>
<tr>
<td><strong>LVM</strong> and <strong>LVN</strong></td>
<td>List view control</td>
<td><a href="/windows/desktop/Controls/bumper-list-view-control-reference-messages">List View Messages</a> and <a href="/windows/desktop/Controls/bumper-list-view-control-reference-notifications">List View Notifications</a></td>
</tr>
<tr>
<td><strong>MCM</strong> and <strong>MCN</strong></td>
<td>Month calendar control</td>
<td><a href="/windows/desktop/Controls/bumper-month-calendar-control-reference-messages">Month Calendar Messages</a> and <a href="/windows/desktop/Controls/bumper-month-calendar-control-reference-notifications">Month Calendar Notifications</a></td>
</tr>
<tr>
<td><strong>PBM</strong></td>
<td>Progress bar</td>
<td><a href="/windows/desktop/Controls/bumper-progress-bar-control-reference-messages">Progress Bar Messages</a></td>
</tr>
<tr>
<td><strong>PGM</strong> and <strong>PGN</strong></td>
<td>Pager control</td>
<td><a href="/windows/desktop/Controls/bumper-pager-control-reference-messages">Pager Control Messages</a> and <a href="/windows/desktop/Controls/bumper-pager-control-reference-notifications">Pager Control Notifications</a></td>
</tr>
<tr>
<td><strong>PSM</strong> and <strong>PSN</strong></td>
<td>Property sheet</td>
<td><a href="/windows/desktop/Controls/bumper-property-sheets-reference-messages">Property Sheet Messages</a> and <a href="/windows/desktop/Controls/bumper-property-sheets-reference-notifications">Property Sheet Notifications</a></td>
</tr>
<tr>
<td><strong>RB</strong> and <strong>RBN</strong></td>
<td>Rebar control</td>
<td><a href="/windows/desktop/Controls/bumper-rebar-control-reference-messages">Rebar Control Messages</a> and <a href="/windows/desktop/Controls/bumper-rebar-control-reference-notifications">Rebar Control Notifications</a></td>
</tr>
<tr>
<td><strong>SB</strong> and <strong>SBN</strong></td>
<td>Status bar window</td>
<td><a href="/windows/desktop/Controls/bumper-status-bars-reference-messages">Status Bar Messages</a> and <a href="/windows/desktop/Controls/bumper-status-bars-reference-notifications">Status Bar Notifications</a></td>
</tr>
<tr>
<td><strong>SBM</strong></td>
<td>Scroll bar control</td>
<td><a href="/windows/desktop/Controls/bumper-scroll-bars-reference-messages">Scroll Bar Messages</a></td>
</tr>
<tr>
<td><strong>SMC</strong></td>
<td>Shell menu</td>
<td><a href="/windows/desktop/shell/control-panel-applications">Shell Messages and Notifications</a></td>
</tr>
<tr>
<td><strong>STM</strong> and <strong>STN</strong></td>
<td>Static control</td>
<td><a href="/windows/desktop/Controls/bumper-static-control-reference-messages">Static Control Messages</a> and <a href="/windows/desktop/Controls/bumper-static-control-reference-notifications">Static Control Notifications</a></td>
</tr>
<tr>
<td><strong>TB</strong> and <strong>TBN</strong></td>
<td>Toolbar</td>
<td><a href="/windows/desktop/Controls/bumper-toolbar-control-reference-messages">Toolbar Control Messages</a> and <a href="/windows/desktop/Controls/bumper-toolbar-control-reference-notifications">Toolbar Control Notifications</a></td>
</tr>
<tr>
<td><strong>TBM</strong> and <strong>TRBN</strong></td>
<td>Trackbar control</td>
<td><a href="/windows/desktop/Controls/bumper-trackbar-control-reference-messages">Trackbar Control Messages</a> and <a href="/windows/desktop/Controls/bumper-trackbar-control-reference-notifications">Trackbar Control Notifications</a></td>
</tr>
<tr>
<td><strong>TCM</strong> and <strong>TCN</strong></td>
<td>Tab control</td>
<td><a href="/windows/desktop/Controls/bumper-tab-control-reference-messages">Tab Control Messages</a> and <a href="/windows/desktop/Controls/bumper-tab-control-reference-notifications">Tab Control Notifications</a></td>
</tr>
<tr>
<td><strong>TDM</strong> and <strong>TDN</strong></td>
<td>Task dialog</td>
<td><a href="/windows/desktop/Controls/bumper-task-dialogs-reference-messages">Task Dialog Messages</a> and <a href="/windows/desktop/Controls/bumper-task-dialogs-reference-notifications">Task Dialog Notifications</a></td>
</tr>
<tr>
<td><strong>TTM</strong> and <strong>TTN</strong></td>
<td>Tooltip control</td>
<td><a href="/windows/desktop/Controls/bumper-tooltip-control-reference-messages">Tooltip Control Messages</a> and <a href="/windows/desktop/Controls/bumper-tooltip-control-reference-notifications">Tooltip Control Notifications</a></td>
</tr>
<tr>
<td><strong>TVM</strong> and <strong>TVN</strong></td>
<td>Tree-view control</td>
<td><a href="/windows/desktop/Controls/bumper-tree-view-control-reference-messages">Tree View Messages</a> and <a href="/windows/desktop/Controls/bumper-tree-view-control-reference-notifications">Tree View Notifications</a></td>
</tr>
<tr>
<td><strong>UDM</strong> and <strong>UDN</strong></td>
<td>Up-down control</td>
<td><a href="/windows/desktop/Controls/bumper-up-down-control-reference-messages">Up-Down Messages</a> and <a href="/windows/desktop/Controls/bumper-up-down-control-reference-notifications">Up-Down Notifications</a></td>
</tr>
<tr>
<td><strong>WM</strong></td>
<td>General</td>
<td><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="/windows/desktop/dataxchg/clipboard-messages">Clipboard Messages</a><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="/windows/desktop/dataxchg/clipboard-notifications">Clipboard Notifications</a><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="/windows/desktop/dlgbox/common-dialog-box-notifications">Common Dialog Box Notifications</a><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="/windows/desktop/menurc/cursor-notifications">Cursor Notifications</a><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="/windows/desktop/dataxchg/wm-copydata">Data Copy Message</a><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="/windows/desktop/dwm/dwm-messages">Desktop Window Manager Messages</a><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="/windows/desktop/DevIO/device-management-messages">Device Management Messages</a><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="/windows/desktop/dlgbox/dialog-box-notifications">Dialog Box Notifications</a><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="/windows/desktop/dataxchg/dynamic-data-exchange-messages">Dynamic Data Exchange Messages</a><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="/windows/desktop/dataxchg/dynamic-data-exchange-notifications">Dynamic Data Exchange Notifications</a><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="hook-notifications.html">Hook Notifications</a><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="/windows/desktop/menurc/keyboard-accelerator-messages">Keyboard Accelerator Messages</a><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="/windows/desktop/menurc/keyboard-accelerator-notifications">Keyboard Accelerator Notifications</a><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="/windows/desktop/inputdev/keyboard-input-messages">Keyboard Input Messages</a><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="/windows/desktop/inputdev/keyboard-input-notifications">Keyboard Input Notifications</a><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="/windows/desktop/menurc/menu-notifications">Menu Notifications</a><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="/windows/desktop/inputdev/mouse-input-notifications">Mouse Input Notifications</a><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="multiple-document-interface-messages.html">Multiple Document Interface Messages</a><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="/windows/desktop/inputdev/raw-input-notifications">Raw Input Notifications</a><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="/windows/desktop/Controls/bumper-scroll-bars-reference-notifications">Scroll Bar Notifications</a><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="timer-notifications.html">Timer Notifications</a><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="window-messages.html">Window Messages</a><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="window-notifications.html">Window Notifications</a><!-- raw HTML omitted --> <!-- raw HTML omitted --></td>
</tr>
</tbody>
</table>
<p>General window messages cover a wide range of information and requests, including messages for mouse and keyboard input, menu and dialog box input, window creation and management, and Dynamic Data Exchange (DDE).</p>
<h3>Application-Defined Messages</h3>
<p>An application can create messages to be used by its own windows or to communicate with windows in other processes. If an application creates its own messages, the window procedure that receives them must interpret the messages and provide appropriate processing.</p>
<p>Message-identifier values are used as follows:</p>
<ul>
<li>The system reserves message-identifier values in the range 0x0000 through 0x03FF (the value of <a href="wm-user.html"><strong>WM_USER</strong></a>Â  â€“ 1) for system-defined messages. Applications cannot use these values for private messages.</li>
<li>Values in the range 0x0400 (the value of <a href="wm-user.html"><strong>WM_USER</strong></a>) through 0x7FFF are available for message identifiers for private window classes.</li>
<li>If your application is marked version 4.0, you can use message-identifier values in the range 0x8000 (<a href="wm-app.html"><strong>WM_APP</strong></a>) through 0xBFFF for private messages.</li>
<li>The system returns a message identifier in the range 0xC000 through 0xFFFF when an application calls the <a href="/windows/win32/api/winuser/nf-winuser-registerwindowmessagea"><strong>RegisterWindowMessage</strong></a> function to register a message. The message identifier returned by this function is guaranteed to be unique throughout the system. Use of this function prevents conflicts that can arise if other applications use the same message identifier for different purposes.</li>
</ul>
<h2>Message Routing</h2>
<p>The system uses two methods to route messages to a window procedure: posting messages to a first-in, first-out queue called a <em>message queue</em>, a system-defined memory object that temporarily stores messages, and sending messages directly to a window procedure.</p>
<p>A messages that is posted to a message queue is called a <em>queued message</em>. These are primarily the result of user input entered through the mouse or keyboard, such as <a href="/windows/desktop/inputdev/wm-mousemove"><strong>WM_MOUSEMOVE</strong></a>, <a href="/windows/desktop/inputdev/wm-lbuttondown"><strong>WM_LBUTTONDOWN</strong></a>, <a href="/windows/desktop/inputdev/wm-keydown"><strong>WM_KEYDOWN</strong></a>, and <a href="/windows/desktop/inputdev/wm-char"><strong>WM_CHAR</strong></a> messages. Other queued messages include the timer, paint, and quit messages: <a href="wm-timer.html"><strong>WM_TIMER</strong></a>, <a href="/windows/desktop/gdi/wm-paint"><strong>WM_PAINT</strong></a>, and <a href="wm-quit.html"><strong>WM_QUIT</strong></a>. Most other messages, which are sent directly to a window procedure, are called <em>nonqueued messages</em>.</p>
<ul>
<li><a href="#queued-messages">Queued Messages</a></li>
<li><a href="#nonqueued-messages">Nonqueued Messages</a></li>
</ul>
<h3>Queued Messages</h3>
<p>The system can display any number of windows at a time. To route mouse and keyboard input to the appropriate window, the system uses message queues.</p>
<p>The system maintains a single system message queue and one thread-specific message queue for each GUI thread. To avoid the overhead of creating a message queue for nonâ€“GUI threads, all threads are created initially without a message queue. The system creates a thread-specific message queue only when the thread makes its first call to one of the specific user functions; no GUI function calls result in the creation of a message queue.</p>
<p>Whenever the user moves the mouse, clicks the mouse buttons, or types on the keyboard, the device driver for the mouse or keyboard converts the input into messages and places them in the system message queue. The system removes the messages, one at a time, from the system message queue, examines them to determine the destination window, and then posts them to the message queue of the thread that created the destination window. A thread's message queue receives all mouse and keyboard messages for the windows created by the thread. The thread removes messages from its queue and directs the system to send them to the appropriate window procedure for processing.</p>
<p>With the exception of the <a href="/windows/desktop/gdi/wm-paint"><strong>WM_PAINT</strong></a> message, the <a href="wm-timer.html"><strong>WM_TIMER</strong></a> message, and the <a href="wm-quit.html"><strong>WM_QUIT</strong></a> message, the system always posts messages at the end of a message queue. This ensures that a window receives its input messages in the proper first in, first out (FIFO) sequence. The <strong>WM_PAINT</strong> message, the <strong>WM_TIMER</strong> message, and the <strong>WM_QUIT</strong> message, however, are kept in the queue and are forwarded to the window procedure only when the queue contains no other messages. In addition, multiple <strong>WM_PAINT</strong> messages for the same window are combined into a single <strong>WM_PAINT</strong> message, consolidating all invalid parts of the client area into a single area. Combining <strong>WM_PAINT</strong> messages reduces the number of times a window must redraw the contents of its client area.</p>
<p>The system posts a message to a thread's message queue by filling an <a href="/windows/win32/api/winuser/ns-winuser-msg"><strong>MSG</strong></a> structure and then copying it to the message queue. Information in <strong>MSG</strong> includes: the handle of the window for which the message is intended, the message identifier, the two message parameters, the time the message was posted, and the mouse cursor position. A thread can post a message to its own message queue or to the queue of another thread by using the <a href="/windows/win32/api/winuser/nf-winuser-postmessagea"><strong>PostMessage</strong></a> or <a href="/windows/win32/api/winuser/nf-winuser-postthreadmessagea"><strong>PostThreadMessage</strong></a> function.</p>
<p>An application can remove a message from its queue by using the <a href="/windows/win32/api/winuser/nf-winuser-getmessage"><strong>GetMessage</strong></a> function. To examine a message without removing it from its queue, an application can use the <a href="/windows/win32/api/winuser/nf-winuser-peekmessagea"><strong>PeekMessage</strong></a> function. This function fills <a href="/windows/win32/api/winuser/ns-winuser-msg"><strong>MSG</strong></a> with information about the message.</p>
<p>After removing a message from its queue, an application can use the <a href="/windows/win32/api/winuser/nf-winuser-dispatchmessage"><strong>DispatchMessage</strong></a> function to direct the system to send the message to a window procedure for processing. <strong>DispatchMessage</strong> takes a pointer to <a href="/windows/win32/api/winuser/ns-winuser-msg"><strong>MSG</strong></a> that was filled by a previous call to the <a href="/windows/win32/api/winuser/nf-winuser-getmessage"><strong>GetMessage</strong></a> or <a href="/windows/win32/api/winuser/nf-winuser-peekmessagea"><strong>PeekMessage</strong></a> function. <strong>DispatchMessage</strong> passes the window handle, the message identifier, and the two message parameters to the window procedure, but it does not pass the time the message was posted or mouse cursor position. An application can retrieve this information by calling the <a href="/windows/win32/api/winuser/nf-winuser-getmessagetime"><strong>GetMessageTime</strong></a> and <a href="/windows/win32/api/winuser/nf-winuser-getmessagepos"><strong>GetMessagePos</strong></a> functions while processing a message.</p>
<p>A thread can use the <a href="/windows/win32/api/winuser/nf-winuser-waitmessage"><strong>WaitMessage</strong></a> function to yield control to other threads when it has no messages in its message queue. The function suspends the thread and does not return until a new message is placed in the thread's message queue.</p>
<p>You can call the <a href="/windows/win32/api/winuser/nf-winuser-setmessageextrainfo"><strong>SetMessageExtraInfo</strong></a> function to associate a value with the current thread's message queue. Then call the <a href="/windows/win32/api/winuser/nf-winuser-getmessageextrainfo"><strong>GetMessageExtraInfo</strong></a> function to get the value associated with the last message retrieved by the <a href="/windows/win32/api/winuser/nf-winuser-getmessage"><strong>GetMessage</strong></a> or <a href="/windows/win32/api/winuser/nf-winuser-peekmessagea"><strong>PeekMessage</strong></a> function.</p>
<h3>Nonqueued Messages</h3>
<p>Nonqueued messages are sent immediately to the destination window procedure, bypassing the system message queue and thread message queue. The system typically sends nonqueued messages to notify a window of events that affect it. For example, when the user activates a new application window, the system sends the window a series of messages, including <a href="/windows/desktop/inputdev/wm-activate"><strong>WM_ACTIVATE</strong></a>, <a href="/windows/desktop/inputdev/wm-setfocus"><strong>WM_SETFOCUS</strong></a>, and <a href="/windows/desktop/menurc/wm-setcursor"><strong>WM_SETCURSOR</strong></a>. These messages notify the window that it has been activated, that keyboard input is being directed to the window, and that the mouse cursor has been moved within the borders of the window. Nonqueued messages can also result when an application calls certain system functions. For example, the system sends the <a href="wm-windowposchanged.html"><strong>WM_WINDOWPOSCHANGED</strong></a> message after an application uses the <a href="/windows/win32/api/winuser/nf-winuser-setwindowpos"><strong>SetWindowPos</strong></a> function to move a window.</p>
<p>Some functions that send nonqueued messages are <a href="/windows/win32/api/winuser/nf-winuser-broadcastsystemmessage"><strong>BroadcastSystemMessage</strong></a>, <a href="/windows/win32/api/winuser/nf-winuser-broadcastsystemmessageexa"><strong>BroadcastSystemMessageEx</strong></a>, <a href="/windows/win32/api/winuser/nf-winuser-sendmessage"><strong>SendMessage</strong></a>, <a href="/windows/win32/api/winuser/nf-winuser-sendmessagetimeouta"><strong>SendMessageTimeout</strong></a>, and <a href="/windows/win32/api/winuser/nf-winuser-sendnotifymessagea"><strong>SendNotifyMessage</strong></a>.</p>
<h2>Message Handling</h2>
<p>An application must remove and process messages posted to the message queues of its threads. A single-threaded application usually uses a <em>message loop</em> in its <a href="/windows/win32/api/winbase/nf-winbase-winmain"><strong>WinMain</strong></a> function to remove and send messages to the appropriate window procedures for processing. Applications with multiple threads can include a message loop in each thread that creates a window. The following sections describe how a message loop works and explain the role of a window procedure:</p>
<ul>
<li><a href="#message-loop">Message Loop</a></li>
<li><a href="#window-procedure">Window Procedure</a></li>
</ul>
<h3>Message Loop</h3>
<p>A simple message loop consists of one function call to each of these three functions: <a href="/windows/win32/api/winuser/nf-winuser-getmessage"><strong>GetMessage</strong></a>, <a href="/windows/win32/api/winuser/nf-winuser-translatemessage"><strong>TranslateMessage</strong></a>, and <a href="/windows/win32/api/winuser/nf-winuser-dispatchmessage"><strong>DispatchMessage</strong></a>. Note that if there is an error, <strong>GetMessage</strong> returns â€“1, thus the need for the special testing.</p>
<pre lang="cpp"><code>MSG msg;
BOOL bRet;

while( (bRet = GetMessage( &amp;msg, NULL, 0, 0 )) != 0)
{ 
    if (bRet == -1)
    {
        // handle the error and possibly exit
    }
    else
    {
        TranslateMessage(&amp;msg); 
        DispatchMessage(&amp;msg); 
    }
}
</code></pre>
<p>The <a href="/windows/win32/api/winuser/nf-winuser-getmessage"><strong>GetMessage</strong></a> function retrieves a message from the queue and copies it to a structure of type <a href="/windows/win32/api/winuser/ns-winuser-msg"><strong>MSG</strong></a>. It returns a nonzero value, unless it encounters the <a href="wm-quit.html"><strong>WM_QUIT</strong></a> message, in which case it returns <strong>FALSE</strong> and ends the loop. In a single-threaded application, ending the message loop is often the first step in closing the application. An application can end its own loop by using the <a href="/windows/win32/api/winuser/nf-winuser-postquitmessage"><strong>PostQuitMessage</strong></a> function, typically in response to the <a href="wm-destroy.html"><strong>WM_DESTROY</strong></a> message in the window procedure of the application's main window.</p>
<p>If you specify a window handle as the second parameter of <a href="/windows/win32/api/winuser/nf-winuser-getmessage"><strong>GetMessage</strong></a>, only messages for the specified window are retrieved from the queue. <strong>GetMessage</strong> can also filter messages in the queue, retrieving only those messages that fall within a specified range. For more information about filtering messages, see <a href="#message-filtering">Message Filtering</a>.</p>
<p>A thread's message loop must include <a href="/windows/win32/api/winuser/nf-winuser-translatemessage"><strong>TranslateMessage</strong></a> if the thread is to receive character input from the keyboard. The system generates virtual-key messages (<a href="/windows/desktop/inputdev/wm-keydown"><strong>WM_KEYDOWN</strong></a> and <a href="/windows/desktop/inputdev/wm-keyup"><strong>WM_KEYUP</strong></a>) each time the user presses a key. A virtual-key message contains a virtual-key code that identifies which key was pressed, but not its character value. To retrieve this value, the message loop must contain <strong>TranslateMessage</strong>, which translates the virtual-key message into a character message (<a href="/windows/desktop/inputdev/wm-char"><strong>WM_CHAR</strong></a>) and places it back into the application message queue. The character message can then be removed upon a subsequent iteration of the message loop and dispatched to a window procedure.</p>
<p>The <a href="/windows/win32/api/winuser/nf-winuser-dispatchmessage"><strong>DispatchMessage</strong></a> function sends a message to the window procedure associated with the window handle specified in the <a href="/windows/win32/api/winuser/ns-winuser-msg"><strong>MSG</strong></a> structure. If the window handle is <strong>HWND_TOPMOST</strong>, <strong>DispatchMessage</strong> sends the message to the window procedures of all top-level windows in the system. If the window handle is <strong>NULL</strong>, <strong>DispatchMessage</strong> does nothing with the message.</p>
<p>An application's main thread starts its message loop after initializing the application and creating at least one window. After it is started, the message loop continues to retrieve messages from the thread's message queue and to dispatch them to the appropriate windows. The message loop ends when the <a href="/windows/win32/api/winuser/nf-winuser-getmessage"><strong>GetMessage</strong></a> function removes the <a href="wm-quit.html"><strong>WM_QUIT</strong></a> message from the message queue.</p>
<p>Only one message loop is needed for a message queue, even if an application contains many windows. <a href="/windows/win32/api/winuser/nf-winuser-dispatchmessage"><strong>DispatchMessage</strong></a> always dispatches the message to the proper window; this is because each message in the queue is an <a href="/windows/win32/api/winuser/ns-winuser-msg"><strong>MSG</strong></a> structure that contains the handle of the window to which the message belongs.</p>
<p>You can modify a message loop in a variety of ways. For example, you can retrieve messages from the queue without dispatching them to a window. This is useful for applications that post messages not specifying a window. You can also direct <a href="/windows/win32/api/winuser/nf-winuser-getmessage"><strong>GetMessage</strong></a> to search for specific messages, leaving other messages in the queue. This is useful if you must temporarily bypass the usual FIFO order of the message queue.</p>
<p>An application that uses accelerator keys must be able to translate keyboard messages into command messages. To do this, the application's message loop must include a call to the <a href="/windows/desktop/api/winuser/nf-winuser-translateacceleratora"><strong>TranslateAccelerator</strong></a> function. For more information about accelerator keys, see <a href="/windows/desktop/menurc/keyboard-accelerators">Keyboard Accelerators</a>.</p>
<p>If a thread uses a modeless dialog box, the message loop must include the <a href="/windows/desktop/api/winuser/nf-winuser-isdialogmessagea"><strong>IsDialogMessage</strong></a> function so that the dialog box can receive keyboard input.</p>
<h3>Window Procedure</h3>
<p>A window procedure is a function that receives and processes all messages sent to the window. Every window class has a window procedure, and every window created with that class uses that same window procedure to respond to messages.</p>
<p>The system sends a message to a window procedure by passing the message data as arguments to the procedure. The window procedure then performs an appropriate action for the message; it checks the message identifier and, while processing the message, uses the information specified by the message parameters.</p>
<p>A window procedure does not usually ignore a message. If it does not process a message, it must send the message back to the system for default processing. The window procedure does this by calling the <a href="/windows/desktop/api/winuser/nf-winuser-defwindowproca"><strong>DefWindowProc</strong></a> function, which performs a default action and returns a message result. The window procedure must then return this value as its own message result. Most window procedures process just a few messages and pass the others on to the system by calling <strong>DefWindowProc</strong>.</p>
<p>Because a window procedure is shared by all windows belonging to the same class, it can process messages for several different windows. To identify the specific window affected by the message, a window procedure can examine the window handle passed with a message. For more information about window procedures, see <a href="window-procedures.html">Window Procedures</a>.</p>
<h2>Message Filtering</h2>
<p>An application can choose specific messages to retrieve from the message queue (while ignoring other messages) by using the <a href="/windows/win32/api/winuser/nf-winuser-getmessage"><strong>GetMessage</strong></a> or <a href="/windows/win32/api/winuser/nf-winuser-peekmessagea"><strong>PeekMessage</strong></a> function to specify a message filter. The filter is a range of message identifiers (specified by a first and last identifier), a window handle, or both. <strong>GetMessage</strong> and <strong>PeekMessage</strong> use a message filter to select which messages to retrieve from the queue. Message filtering is useful if an application must search the message queue for messages that have arrived later in the queue. It is also useful if an application must process input (hardware) messages before processing posted messages.</p>
<p>The <strong>WM_KEYFIRST</strong> and <strong>WM_KEYLAST</strong> constants can be used as filter values to retrieve all keyboard messages; the <strong>WM_MOUSEFIRST</strong> and <strong>WM_MOUSELAST</strong> constants can be used to retrieve all mouse messages.</p>
<p>Any application that filters messages must ensure that a message satisfying the message filter can be posted. For example, if an application filters for a <a href="/windows/desktop/inputdev/wm-char"><strong>WM_CHAR</strong></a> message in a window that does not receive keyboard input, the <a href="/windows/win32/api/winuser/nf-winuser-getmessage"><strong>GetMessage</strong></a> function does not return. This effectively &quot;hangs&quot; the application.</p>
<h2>Posting and Sending Messages</h2>
<p>Any application can post and send messages. Like the system, an application posts a message by copying it to a message queue and sends a message by passing the message data as arguments to a window procedure. To post messages, an application uses the <a href="/windows/win32/api/winuser/nf-winuser-postmessagea"><strong>PostMessage</strong></a> function. An application can send a message by calling the <a href="/windows/win32/api/winuser/nf-winuser-sendmessage"><strong>SendMessage</strong></a>, <a href="/windows/win32/api/winuser/nf-winuser-broadcastsystemmessage"><strong>BroadcastSystemMessage</strong></a>, <a href="/windows/win32/api/winuser/nf-winuser-sendmessagecallbacka"><strong>SendMessageCallback</strong></a>, <a href="/windows/win32/api/winuser/nf-winuser-sendmessagetimeouta"><strong>SendMessageTimeout</strong></a>, <a href="/windows/win32/api/winuser/nf-winuser-sendnotifymessagea"><strong>SendNotifyMessage</strong></a>, or <a href="/windows/desktop/api/winuser/nf-winuser-senddlgitemmessagea"><strong>SendDlgItemMessage</strong></a> function.</p>
<h3>Posting Messages</h3>
<p>An application typically posts a message to notify a specific window to perform a task. <a href="/windows/win32/api/winuser/nf-winuser-postmessagea"><strong>PostMessage</strong></a> creates an <a href="/windows/win32/api/winuser/ns-winuser-msg"><strong>MSG</strong></a> structure for the message and copies the message to the message queue. The application's message loop eventually retrieves the message and dispatches it to the appropriate window procedure.</p>
<p>An application can post a message without specifying a window. If the application supplies a <strong>NULL</strong> window handle when calling <a href="/windows/win32/api/winuser/nf-winuser-postmessagea"><strong>PostMessage</strong></a>, the message is posted to the queue associated with the current thread. Because no window handle is specified, the application must process the message in the message loop. This is one way to create a message that applies to the entire application, instead of to a specific window.</p>
<p>Occasionally, you may want to post a message to all top-level windows in the system. An application can post a message to all top-level windows by calling <a href="/windows/win32/api/winuser/nf-winuser-postmessagea"><strong>PostMessage</strong></a> and specifying <strong>HWND_TOPMOST</strong> in the <em>hwnd</em> parameter.</p>
<p>A common programming error is to assume that the <a href="/windows/win32/api/winuser/nf-winuser-postmessagea"><strong>PostMessage</strong></a> function always posts a message. This is not true when the message queue is full. An application should check the return value of the <strong>PostMessage</strong> function to determine whether the message has been posted and, if it has not been, repost it.</p>
<h3>Sending Messages</h3>
<p>An application typically sends a message to notify a window procedure to perform a task immediately. The <a href="/windows/win32/api/winuser/nf-winuser-sendmessage"><strong>SendMessage</strong></a> function sends the message to the window procedure corresponding to the given window. The function waits until the window procedure completes processing and then returns the message result. Parent and child windows often communicate by sending messages to each other. For example, a parent window that has an edit control as its child window can set the text of the control by sending a message to it. The control can notify the parent window of changes to the text that are carried out by the user by sending messages back to the parent.</p>
<p>The <a href="/windows/win32/api/winuser/nf-winuser-sendmessagecallbacka"><strong>SendMessageCallback</strong></a> function also sends a message to the window procedure corresponding to the given window. However, this function returns immediately. After the window procedure processes the message, the system calls the specified callback function. For more information about the callback function, see the <a href="/windows/win32/api/winuser/nc-winuser-sendasyncproc"><strong>SendAsyncProc</strong></a> function.</p>
<p>Occasionally, you may want to send a message to all top-level windows in the system. For example, if the application changes the system time, it must notify all top-level windows about the change by sending a <a href="../sysinfo/wm-timechange.html"><strong>WM_TIMECHANGE</strong></a> message. An application can send a message to all top-level windows by calling <a href="/windows/win32/api/winuser/nf-winuser-sendmessage"><strong>SendMessage</strong></a> and specifying <strong>HWND_TOPMOST</strong> in the <em>hwnd</em> parameter. You can also broadcast a message to all applications by calling the <a href="/windows/win32/api/winuser/nf-winuser-broadcastsystemmessage"><strong>BroadcastSystemMessage</strong></a> function and specifying <strong>BSM_APPLICATIONS</strong> in the <em>lpdwRecipients</em> parameter.</p>
<p>By using the <a href="/windows/win32/api/winuser/nf-winuser-insendmessage"><strong>InSendMessage</strong></a> or <a href="/windows/win32/api/winuser/nf-winuser-insendmessageex"><strong>InSendMessageEx</strong></a> function, a window procedure can determine whether it is processing a message sent by another thread. This capability is useful when message processing depends on the origin of the message.</p>
<h2>Message Deadlocks</h2>
<p>A thread that calls the <a href="/windows/win32/api/winuser/nf-winuser-sendmessage"><strong>SendMessage</strong></a> function to send a message to another thread cannot continue executing until the window procedure that receives the message returns. If the receiving thread yields control while processing the message, the sending thread cannot continue executing, because it is waiting for <strong>SendMessage</strong> to return. If the receiving thread is attached to the same queue as the sender, it can cause an application deadlock to occur. (Note that journal hooks attach threads to the same queue.)</p>
<p>Note that the receiving thread need not yield control explicitly; calling any of the following functions can cause a thread to yield control implicitly.</p>
<ul>
<li><a href="/windows/desktop/api/winuser/nf-winuser-dialogboxa"><strong>DialogBox</strong></a></li>
<li><a href="/windows/desktop/api/winuser/nf-winuser-dialogboxindirecta"><strong>DialogBoxIndirect</strong></a></li>
<li><a href="/windows/desktop/api/winuser/nf-winuser-dialogboxindirectparama"><strong>DialogBoxIndirectParam</strong></a></li>
<li><a href="/windows/desktop/api/winuser/nf-winuser-dialogboxparama"><strong>DialogBoxParam</strong></a></li>
<li><a href="/windows/win32/api/winuser/nf-winuser-getmessage"><strong>GetMessage</strong></a></li>
<li><a href="/windows/desktop/api/winuser/nf-winuser-messagebox"><strong>MessageBox</strong></a></li>
<li><a href="/windows/win32/api/winuser/nf-winuser-peekmessagea"><strong>PeekMessage</strong></a></li>
<li><a href="/windows/win32/api/winuser/nf-winuser-sendmessage"><strong>SendMessage</strong></a></li>
</ul>
<p>To avoid potential deadlocks in your application, consider using the <a href="/windows/win32/api/winuser/nf-winuser-sendnotifymessagea"><strong>SendNotifyMessage</strong></a> or <a href="/windows/win32/api/winuser/nf-winuser-sendmessagetimeouta"><strong>SendMessageTimeout</strong></a> functions. Otherwise, a window procedure can determine whether a message it has received was sent by another thread by calling the <a href="/windows/win32/api/winuser/nf-winuser-insendmessage"><strong>InSendMessage</strong></a> or <a href="/windows/win32/api/winuser/nf-winuser-insendmessageex"><strong>InSendMessageEx</strong></a> function. Before calling any of the functions in the preceding list while processing a message, the window procedure should first call <strong>InSendMessage</strong> or <strong>InSendMessageEx</strong>. If this function returns <strong>TRUE</strong>, the window procedure must call the <a href="/windows/win32/api/winuser/nf-winuser-replymessage"><strong>ReplyMessage</strong></a> function before any function that causes the thread to yield control.</p>
<h2>Broadcasting Messages</h2>
<p>Each message consists of a message identifier and two parameters, <em>wParam</em> and <em>lParam</em>. The message identifier is a unique value that specifies the message purpose. The parameters provide additional information that is message-specific, but the <em>wParam</em> parameter is generally a type value that provides more information about the message.</p>
<p>A <em>message broadcast</em> is simply the sending of a message to multiple recipients in the system. To broadcast a message from an application, use the <a href="/windows/win32/api/winuser/nf-winuser-broadcastsystemmessage"><strong>BroadcastSystemMessage</strong></a> function, specifying the recipients of the message. Rather than specify individual recipients, you must specify one or more types of recipients. These types are applications, installable drivers, network drivers, and system-level device drivers. The system sends broadcast messages to all members of each specified type.</p>
<p>The system typically broadcasts messages in response to changes that take place within system-level device drivers or related components. The driver or related component broadcasts the message to applications and other components to notify them of the change. For example, the component responsible for disk drives broadcasts a message whenever the device driver for the floppy disk drive detects a change of media such as when the user inserts a disk in the drive.</p>
<p>The system broadcasts messages to recipients in this order: system-level device drivers, network drivers, installable drivers, and applications. This means that system-level device drivers, if chosen as recipients, always get the first opportunity to respond to a message. Within a given recipient type, no driver is guaranteed to receive a given message before any other driver. This means that a message intended for a specific driver must have a globally-unique message identifier so that no other driver unintentionally processes it.</p>
<p>You can also broadcast messages to all top-level windows by specifying <strong>HWND_BROADCAST</strong> in the <a href="/windows/win32/api/winuser/nf-winuser-sendmessage"><strong>SendMessage</strong></a>, <a href="/windows/win32/api/winuser/nf-winuser-sendmessagecallbacka"><strong>SendMessageCallback</strong></a>, <a href="/windows/win32/api/winuser/nf-winuser-sendmessagetimeouta"><strong>SendMessageTimeout</strong></a>, or <a href="/windows/win32/api/winuser/nf-winuser-sendnotifymessagea"><strong>SendNotifyMessage</strong></a> function.</p>
<p>Applications receive messages through the window procedure of their top-level windows. Messages are not sent to child windows. Services can receive messages through a window procedure or their service control handlers.</p>
<blockquote>
<p>[!NOTE]<br />
System-level device drivers use a related, system-level function to broadcast system messages.</p>
</blockquote>
<h2>Query Messages</h2>
<p>You can create your own custom messages and use them to coordinate activities between your applications and other components in the system. This is especially useful if you have created your own installable drivers or system-level device drivers. Your custom messages can carry information to and from your driver and the applications that use the driver.</p>
<p>To poll recipients for permission to carry out a given action, use a <em>query message</em>. You can generate your own query messages by setting the <strong>BSF_QUERY</strong> value in the <em>dwFlags</em> parameter when calling <a href="/windows/win32/api/winuser/nf-winuser-broadcastsystemmessage"><strong>BroadcastSystemMessage</strong></a>. Each recipient of the query message must return <strong>TRUE</strong> for the function to send the message to the next recipient. If any recipient returns <strong>BROADCAST_QUERY_DENY</strong>, the broadcast ends immediately and the function returns a zero.</p>
</body>
