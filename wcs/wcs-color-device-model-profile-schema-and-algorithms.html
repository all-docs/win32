<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>WCS Color Device Model Profile Schema and Algorithms</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<p>title: WCS Color Device Model Profile Schema and Algorithms
description: This topic provides information about the WCS Color Device Model Profile Schema and its associated algorithms.This topic contains the following sections OverviewColor Device Model Profile ArchitectureThe CDMP SchemaWCS CDMP v2.0 Calibration AdditionThe CDMP Schema ElementsColorDeviceModelProfileColorDeviceModelNamespaceVersionVersionDocumentationCRTDevice elementLCDDevice elementProjectorDevice elementScannerDevice elementCameraDevice elementRGBPrinterDevice elementCMYKPrinterDevice elementRGBVirtualDevice elementPlugInDeviceTypeRGBVirtualMeasurementTypeGammaTypeGammaOffsetGainTypeGammaOffsetGainLinearGainTypeToneResponseCurvesTypeGamutBoundarySamplesTypeFloatPairListCMYKPrinterMeasurementTypeRGBPrinterMeasurementTypeRGBCaptureMeasurementTypeOneBasedIndexRGBProjectorMeasurementTypeDisplayMeasurementTypeMeasurementConditionsTypeGeometryTypeRGBPrimariesGroupNonNegativeCMYKSampleTypeNonNegativeRGBSampleTypeNonNegativeCMYKTypeNonNegativeRGBTypeExtensionTypeNonNegativeXYZTypeXYZTypeThe CDMP Baseline AlgorithmsCRT Device Model BaselineLCD Device Model BaselineRGB Printer Device Model BaselineRGB Virtual Device Model BaselineCMYK Printer Device Model BaselineRGB Projector Device Model BaselineICC Device Model BaselineRelated topics
ms.assetid: bbb3b50d-75fc-476d-a011-af7dcc2ac520
keywords:</p>
<ul>
<li>Windows Color System (WCS),color device model profile (CDMP)</li>
<li>WCS (Windows Color System),color device model profile (CDMP)</li>
<li>image color management,color device model profile (CDMP)</li>
<li>color management,color device model profile (CDMP)</li>
<li>colors,color device model profile (CDMP)</li>
<li>Windows Color System (WCS),profiles</li>
<li>WCS (Windows Color System),profiles</li>
<li>image color management,profiles</li>
<li>color management,profiles</li>
<li>colors,profiles</li>
<li>schemas,color device model profile (CDMP)</li>
<li>algorithms,color device model profile (CDMP)</li>
<li>color device model profile (CDMP)</li>
<li>CDMP (color device model profile)</li>
<li>WCS color device model profile</li>
</ul>
<h2>ms.topic: article
ms.date: 05/31/2018</h2>
<h1>WCS Color Device Model Profile Schema and Algorithms</h1>
<p>This topic provides information about the WCS Color Device Model Profile Schema and its associated algorithms.</p>
<p>This topic contains the following sections:</p>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#color-device-model-profile-architecture">Color Device Model Profile Architecture</a></li>
<li><a href="#the-cdmp-schema">The CDMP Schema</a></li>
<li><a href="#wcs-cdmp-v20-calibration-addition">WCS CDMP v2.0 Calibration Addition</a></li>
<li><a href="#the-cdmp-schema-elements">The CDMP Schema Elements</a>
<ul>
<li><a href="#colordevicemodelprofile">ColorDeviceModelProfile</a></li>
<li><a href="#colordevicemodelprofile">ColorDeviceModel</a></li>
<li><a href="#namespaceversion">NamespaceVersion</a></li>
<li><a href="#namespaceversion">Version</a></li>
<li><a href="#documentation">Documentation</a></li>
<li><a href="#crtdevice-element">CRTDevice element</a></li>
<li><a href="#lcddevice-element">LCDDevice element</a></li>
<li><a href="#projectordevice-element">ProjectorDevice element</a></li>
<li><a href="#scannerdevice-element">ScannerDevice element</a></li>
<li><a href="#cameradevice-element">CameraDevice element</a></li>
<li><a href="#rgbprinterdevice-element">RGBPrinterDevice element</a></li>
<li><a href="#cmykprinterdevice-element">CMYKPrinterDevice element</a></li>
<li><a href="#rgbvirtualdevice-element">RGBVirtualDevice element</a></li>
<li><a href="#plugindevicetype">PlugInDeviceType</a></li>
<li><a href="#rgbvirtualmeasurementtype">RGBVirtualMeasurementType</a></li>
<li><a href="#gammatype">GammaType</a></li>
<li><a href="#gammaoffsetgaintype">GammaOffsetGainType</a></li>
<li><a href="#gammaoffsetgainlineargaintype">GammaOffsetGainLinearGainType</a></li>
<li><a href="#toneresponsecurvestype">ToneResponseCurvesType</a></li>
<li><a href="#gamutboundarysamplestype">GamutBoundarySamplesType</a></li>
<li><a href="#floatpairlist">FloatPairList</a></li>
<li><a href="#cmykprintermeasurementtype">CMYKPrinterMeasurementType</a></li>
<li><a href="#rgbprintermeasurementtype">RGBPrinterMeasurementType</a></li>
<li><a href="#rgbcapturemeasurementtype">RGBCaptureMeasurementType</a></li>
<li><a href="#onebasedindex">OneBasedIndex</a></li>
<li><a href="#rgbprojectormeasurementtype">RGBProjectorMeasurementType</a></li>
<li><a href="#displaymeasurementtype">DisplayMeasurementType</a></li>
<li><a href="#measurementconditionstype">MeasurementConditionsType</a></li>
<li><a href="#geometrytype">GeometryType</a></li>
<li><a href="#rgbprimariesgroup">RGBPrimariesGroup</a></li>
<li><a href="#nonnegativecmyksampletype">NonNegativeCMYKSampleType</a></li>
<li><a href="#nonnegativergbsampletype">NonNegativeRGBSampleType</a></li>
<li><a href="#nonnegativecmyktype">NonNegativeCMYKType</a></li>
<li><a href="#nonnegativergbtype">NonNegativeRGBType</a></li>
<li><a href="#extensiontype">ExtensionType</a></li>
<li><a href="#nonnegativexyztype">NonNegativeXYZType</a></li>
<li><a href="#nonnegativexyztype">XYZType</a></li>
</ul>
</li>
<li><a href="#the-cdmp-baseline-algorithms">The CDMP Baseline Algorithms</a>
<ul>
<li><a href="#crt-device-model-baseline">CRT Device Model Baseline</a></li>
<li><a href="#lcd-device-model-baseline">LCD Device Model Baseline</a></li>
<li><a href="#rgb-printer-device-model-baseline">RGB Printer Device Model Baseline</a></li>
<li><a href="#rgb-virtual-device-model-baseline">RGB Virtual Device Model Baseline</a></li>
<li><a href="#cmyk-printer-device-model-baseline">CMYK Printer Device Model Baseline</a></li>
<li><a href="#rgb-projector-device-model-baseline">RGB Projector Device Model Baseline</a></li>
<li><a href="#icc-device-model-baseline">ICC Device Model Baseline</a></li>
</ul>
</li>
<li><a href="#related-topics">Related topics</a></li>
</ul>
<h2>Overview</h2>
<p>This schema is used to specify the content of a color device model profile(CDMP). The associated baseline algorithms are described below.</p>
<p>The basic device model profile (DMP) schema consists of the sampling measurement data.</p>
<p>The sampling component of the DMP XML schema provides support for basic color measurement targets, focusing on common standard targets and targets optimized for the baseline device models.</p>
<p>In addition, the device profile provides specific information on the targeted device model and provides a policy that the baseline fallback device model can use if the targeted model is unavailable. The profile instances can include private extensions using standard XML extension mechanisms.</p>
<h2>Color Device Model Profile Architecture</h2>
<p><img src="images/cdmp-image002new.png" alt="Diagram that shows the information that makes up a Device Model Profile." /></p>
<h2>The CDMP Schema</h2>
<pre lang="C++"><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;xs:schema 
  xmlns:cdm=&quot;http://schemas.microsoft.com/windows/2005/02/color/ColorDeviceModel&quot;
  xmlns:wcs=&quot;http://schemas.microsoft.com/windows/2005/02/color/WcsCommonProfileTypes&quot;
  targetNamespace=&quot;http://schemas.microsoft.com/windows/2005/02/color/ColorDeviceModel&quot;
  xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
  elementFormDefault=&quot;qualified&quot;
  attributeFormDefault=&quot;unqualified&quot;
  blockDefault=&quot;#all&quot;
  version=&quot;1.0&quot;&gt;

  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      Color Device Model profile schema.
      Copyright (C) Microsoft. All rights reserved.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;

  &lt;xs:import namespace=&quot;http://schemas.microsoft.com/windows/2005/02/color/WcsCommonProfileTypes&quot; /&gt;

  &lt;xs:complexType name=&quot;RGBType&quot;&gt;
    &lt;xs:attribute name=&quot;R&quot; type=&quot;xs:float&quot; use=&quot;required&quot;/&gt;
    &lt;xs:attribute name=&quot;G&quot; type=&quot;xs:float&quot; use=&quot;required&quot;/&gt;
    &lt;xs:attribute name=&quot;B&quot; type=&quot;xs:float&quot; use=&quot;required&quot;/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name=&quot;NonNegativeRGBType&quot;&gt;
    &lt;xs:attribute name=&quot;R&quot; type=&quot;wcs:NonNegativeFloatType&quot; use=&quot;required&quot;/&gt;
    &lt;xs:attribute name=&quot;G&quot; type=&quot;wcs:NonNegativeFloatType&quot; use=&quot;required&quot;/&gt;
    &lt;xs:attribute name=&quot;B&quot; type=&quot;wcs:NonNegativeFloatType&quot; use=&quot;required&quot;/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name=&quot;NonNegativeCMYKType&quot;&gt;
    &lt;xs:attribute name=&quot;C&quot; type=&quot;wcs:NonNegativeFloatType&quot; use=&quot;required&quot;/&gt;
    &lt;xs:attribute name=&quot;M&quot; type=&quot;wcs:NonNegativeFloatType&quot; use=&quot;required&quot;/&gt;
    &lt;xs:attribute name=&quot;Y&quot; type=&quot;wcs:NonNegativeFloatType&quot; use=&quot;required&quot;/&gt;
    &lt;xs:attribute name=&quot;K&quot; type=&quot;wcs:NonNegativeFloatType&quot; use=&quot;required&quot;/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name=&quot;NonNegativeRGBSampleType&quot;&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name=&quot;RGB&quot; type=&quot;cdm:NonNegativeRGBType&quot;/&gt;
      &lt;xs:element name=&quot;CIEXYZ&quot; type=&quot;wcs:NonNegativeCIEXYZType&quot;/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name=&quot;Tag&quot; type=&quot;xs:string&quot; use=&quot;optional&quot;/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name=&quot;NonNegativeCMYKSampleType&quot;&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name=&quot;CMYK&quot; type=&quot;cdm:NonNegativeCMYKType&quot;/&gt;
      &lt;xs:element name=&quot;CIEXYZ&quot; type=&quot;wcs:NonNegativeCIEXYZType&quot;/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name=&quot;Tag&quot; type=&quot;xs:string&quot; use=&quot;optional&quot;/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:group name=&quot;RGBPrimariesGroup&quot;&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name=&quot;WhitePrimary&quot; type=&quot;wcs:NonNegativeCIEXYZType&quot;/&gt;
      &lt;xs:element name=&quot;RedPrimary&quot; type=&quot;wcs:NonNegativeCIEXYZType&quot;/&gt;
      &lt;xs:element name=&quot;GreenPrimary&quot; type=&quot;wcs:NonNegativeCIEXYZType&quot;/&gt;
      &lt;xs:element name=&quot;BluePrimary&quot; type=&quot;wcs:NonNegativeCIEXYZType&quot;/&gt;
      &lt;xs:element name=&quot;BlackPrimary&quot; type=&quot;wcs:NonNegativeCIEXYZType&quot;/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:group&gt; 
  
  &lt;xs:complexType name=&quot;MeasurementConditionsType&quot;&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
      Optional measurement conditions. 
       
      We only support CIEXYZ for measurement color space in this version. 
      If the white point value from the measurement conditions is not available, 
      the default processing will use
        - &quot;D50&quot; for printer and scanners
        - &quot;D65&quot; for camera and displays.          
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name=&quot;ColorSpace&quot; minOccurs=&quot;0&quot;&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction base=&quot;xs:string&quot;&gt;
            &lt;xs:enumeration value=&quot;CIEXYZ&quot;/&gt;
          &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;    
      &lt;/xs:element&gt;
      &lt;xs:choice minOccurs=&quot;0&quot;&gt;
        &lt;xs:element name=&quot;WhitePoint&quot; type=&quot;wcs:NonNegativeCIEXYZType&quot;/&gt;
        &lt;xs:element name=&quot;WhitePointName&quot;&gt;
          &lt;xs:simpleType&gt;
            &lt;xs:restriction base=&quot;xs:string&quot;&gt;
              &lt;xs:enumeration value=&quot;D50&quot;/&gt;
              &lt;xs:enumeration value=&quot;D65&quot;/&gt;
              &lt;xs:enumeration value=&quot;A&quot;/&gt;
              &lt;xs:enumeration value=&quot;F2&quot;/&gt;
            &lt;/xs:restriction&gt;
          &lt;/xs:simpleType&gt;
        &lt;/xs:element&gt;
      &lt;/xs:choice&gt;
      &lt;xs:element name=&quot;Geometry&quot; minOccurs=&quot;0&quot;&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction base=&quot;xs:string&quot;&gt;
            &lt;xs:enumeration value=&quot;0/45&quot;/&gt;
            &lt;xs:enumeration value=&quot;0/diffuse&quot;/&gt;
            &lt;xs:enumeration value=&quot;diffuse/0&quot;/&gt;
            &lt;xs:enumeration value=&quot;direct&quot;/&gt;
          &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;   
      &lt;/xs:element&gt;
      &lt;xs:element name=&quot;ApertureSize&quot; type=&quot;xs:int&quot; minOccurs=&quot;0&quot;/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name=&quot;DisplayMeasurementType&quot;&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref=&quot;cdm:RGBPrimariesGroup&quot;/&gt;
      &lt;xs:element name=&quot;GrayRamp&quot;&gt;
        &lt;xs:complexType&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element name=&quot;Sample&quot; type=&quot;cdm:NonNegativeRGBSampleType&quot; maxOccurs=&quot;4096&quot;/&gt; 
          &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt;
      &lt;xs:element name=&quot;RedRamp&quot;&gt;
        &lt;xs:complexType&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element name=&quot;Sample&quot; type=&quot;cdm:NonNegativeRGBSampleType&quot; maxOccurs=&quot;4096&quot;/&gt; 
          &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt;
      &lt;xs:element name=&quot;GreenRamp&quot;&gt;
        &lt;xs:complexType&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element name=&quot;Sample&quot; type=&quot;cdm:NonNegativeRGBSampleType&quot; maxOccurs=&quot;4096&quot;/&gt; 
          &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt;
      &lt;xs:element name=&quot;BlueRamp&quot;&gt;
        &lt;xs:complexType&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element name=&quot;Sample&quot; type=&quot;cdm:NonNegativeRGBSampleType&quot; maxOccurs=&quot;4096&quot;/&gt; 
          &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name=&quot;TimeStamp&quot; type=&quot;xs:dateTime&quot;/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name=&quot;RGBProjectorMeasurementType&quot;&gt;
    &lt;xs:sequence&gt;
      &lt;xs:group ref=&quot;cdm:RGBPrimariesGroup&quot;/&gt;
      &lt;xs:element name=&quot;ColorSamples&quot;&gt;
        &lt;xs:complexType&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element name=&quot;Sample&quot; type=&quot;cdm:NonNegativeRGBSampleType&quot; maxOccurs=&quot;unbounded&quot;/&gt; 
          &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name=&quot;TimeStamp&quot; type=&quot;xs:dateTime&quot;/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:simpleType name=&quot;OneBasedIndex&quot;&gt;
    &lt;xs:restriction base=&quot;xs:int&quot;&gt;
      &lt;xs:minInclusive value=&quot;1&quot;/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
    
  &lt;xs:complexType name=&quot;RGBCaptureMeasurementType&quot;&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name=&quot;PrimaryIndex&quot;&gt;
        &lt;xs:complexType&gt;
          &lt;xs:all&gt;
            &lt;xs:element name=&quot;White&quot; type=&quot;cdm:OneBasedIndex&quot;/&gt;
            &lt;xs:element name=&quot;Black&quot; type=&quot;cdm:OneBasedIndex&quot; minOccurs=&quot;0&quot;/&gt;
            &lt;xs:element name=&quot;Red&quot; type=&quot;cdm:OneBasedIndex&quot; minOccurs=&quot;0&quot;/&gt;
            &lt;xs:element name=&quot;Green&quot; type=&quot;cdm:OneBasedIndex&quot; minOccurs=&quot;0&quot;/&gt;
            &lt;xs:element name=&quot;Blue&quot; type=&quot;cdm:OneBasedIndex&quot; minOccurs=&quot;0&quot;/&gt;
            &lt;xs:element name=&quot;Cyan&quot; type=&quot;cdm:OneBasedIndex&quot; minOccurs=&quot;0&quot;/&gt;
            &lt;xs:element name=&quot;Magenta&quot; type=&quot;cdm:OneBasedIndex&quot; minOccurs=&quot;0&quot;/&gt;
            &lt;xs:element name=&quot;Yellow&quot; type=&quot;cdm:OneBasedIndex&quot; minOccurs=&quot;0&quot;/&gt;
          &lt;/xs:all&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt;
      &lt;xs:element name=&quot;NeutralIndices&quot;&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:list itemType=&quot;cdm:OneBasedIndex&quot;/&gt;
        &lt;/xs:simpleType&gt;
      &lt;/xs:element&gt;
      &lt;xs:element name=&quot;ColorSamples&quot;&gt;
        &lt;xs:complexType&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element name=&quot;Sample&quot; type=&quot;cdm:NonNegativeRGBSampleType&quot; maxOccurs=&quot;unbounded&quot;/&gt; 
          &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name=&quot;TimeStamp&quot; type=&quot;xs:dateTime&quot;/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name=&quot;RGBPrinterMeasurementType&quot;&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name=&quot;ColorCube&quot;&gt;
        &lt;xs:complexType&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element name=&quot;Sample&quot; type=&quot;cdm:NonNegativeRGBSampleType&quot; maxOccurs=&quot;unbounded&quot;/&gt; 
          &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt;       
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name=&quot;TimeStamp&quot; type=&quot;xs:dateTime&quot;/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name=&quot;CMYKPrinterMeasurementType&quot;&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name=&quot;ColorCube&quot;&gt;
        &lt;xs:complexType&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element name=&quot;Sample&quot; type=&quot;cdm:NonNegativeCMYKSampleType&quot; maxOccurs=&quot;unbounded&quot;/&gt; 
          &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt;       
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name=&quot;TimeStamp&quot; type=&quot;xs:dateTime&quot;/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name=&quot;GammaType&quot;&gt;
    &lt;xs:attribute name=&quot;value&quot; type=&quot;wcs:NonNegativeFloatType&quot; use=&quot;required&quot;/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name=&quot;GammaOffsetGainType&quot;&gt;
    &lt;xs:attribute name=&quot;Gamma&quot; type=&quot;wcs:NonNegativeFloatType&quot; use=&quot;required&quot;/&gt;
    &lt;xs:attribute name=&quot;Offset&quot; type=&quot;wcs:NonNegativeFloatType&quot; use=&quot;required&quot;/&gt;
    &lt;xs:attribute name=&quot;Gain&quot; type=&quot;wcs:NonNegativeFloatType&quot; use=&quot;required&quot;/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name=&quot;GammaOffsetGainLinearGainType&quot;&gt;
    &lt;xs:attribute name=&quot;Gamma&quot; type=&quot;wcs:NonNegativeFloatType&quot; use=&quot;required&quot;/&gt;
    &lt;xs:attribute name=&quot;Offset&quot; type=&quot;wcs:NonNegativeFloatType&quot; use=&quot;required&quot;/&gt;
    &lt;xs:attribute name=&quot;Gain&quot; type=&quot;wcs:NonNegativeFloatType&quot; use=&quot;required&quot;/&gt;
    &lt;xs:attribute name=&quot;LinearGain&quot; type=&quot;wcs:NonNegativeFloatType&quot; use=&quot;required&quot;/&gt;
    &lt;xs:attribute name=&quot;TransitionPoint&quot; type=&quot;wcs:NonNegativeFloatType&quot; use=&quot;required&quot;/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:simpleType name=&quot;FloatList&quot;&gt;
    &lt;xs:list itemType=&quot;xs:float&quot;/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:complexType name=&quot;OneDimensionLutType&quot;&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name=&quot;Input&quot; type=&quot;cdm:FloatList&quot;/&gt;
      &lt;xs:element name=&quot;Output&quot; type=&quot;cdm:FloatList&quot;/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name=&quot;HDRToneResponseCurvesType&quot;&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name=&quot;RedTRC&quot; type=&quot;cdm:OneDimensionLutType&quot;/&gt;
      &lt;xs:element name=&quot;GreenTRC&quot; type=&quot;cdm:OneDimensionLutType&quot;/&gt;
      &lt;xs:element name=&quot;BlueTRC&quot; type=&quot;cdm:OneDimensionLutType&quot;/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name=&quot;TRCLength&quot; use=&quot;required&quot;&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base=&quot;xs:int&quot;&gt;
          &lt;xs:minInclusive value=&quot;0&quot; /&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:attribute&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name=&quot;GamutBoundarySamplesType&quot;&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name=&quot;RGB&quot; type=&quot;cdm:RGBType&quot; maxOccurs=&quot;unbounded&quot;/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name=&quot;RGBVirtualMeasurementType&quot;&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name=&quot;MaxColorantUsed&quot; type=&quot;xs:float&quot;/&gt;
      &lt;xs:element name=&quot;MinColorantUsed&quot; type=&quot;xs:float&quot;/&gt;
      &lt;xs:group ref=&quot;cdm:RGBPrimariesGroup&quot;/&gt;
      &lt;xs:choice&gt;
        &lt;xs:element name=&quot;Gamma&quot; type=&quot;cdm:GammaType&quot;/&gt;
        &lt;xs:element name=&quot;GammaOffsetGain&quot; type=&quot;cdm:GammaOffsetGainType&quot;/&gt;
        &lt;xs:element name=&quot;GammaOffsetGainLinearGain&quot; type=&quot;cdm:GammaOffsetGainLinearGainType&quot;/&gt;
        &lt;xs:element name=&quot;HDRToneResponseCurves&quot; type=&quot;cdm:HDRToneResponseCurvesType&quot;/&gt;
      &lt;/xs:choice&gt;
      &lt;xs:element name=&quot;GamutBoundarySamples&quot; type=&quot;cdm:GamutBoundarySamplesType&quot; minOccurs=&quot;0&quot;/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name=&quot;TimeStamp&quot; type=&quot;xs:dateTime&quot;/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:element name=&quot;ColorDeviceModel&quot;&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element name=&quot;ProfileName&quot; type=&quot;wcs:MultiLocalizedTextType&quot;/&gt;
        &lt;xs:element name=&quot;Description&quot; type=&quot;wcs:MultiLocalizedTextType&quot; minOccurs=&quot;0&quot;/&gt;
        &lt;xs:element name=&quot;Author&quot; type=&quot;wcs:MultiLocalizedTextType&quot; minOccurs=&quot;0&quot;/&gt;
        &lt;xs:element name=&quot;MeasurementConditions&quot; type=&quot;cdm:MeasurementConditionsType&quot; minOccurs=&quot;0&quot;/&gt;
        &lt;xs:element name=&quot;SelfLuminous&quot; type=&quot;xs:boolean&quot; /&gt;
        &lt;xs:element name=&quot;MaxColorant&quot; type=&quot;xs:float&quot;/&gt;
        &lt;xs:element name=&quot;MinColorant&quot; type=&quot;xs:float&quot;/&gt;
        &lt;xs:choice&gt;
          &lt;xs:element name=&quot;CRTDevice&quot;&gt;
            &lt;xs:complexType&gt;
              &lt;xs:sequence&gt;
                &lt;xs:element name=&quot;MeasurementData&quot; type=&quot;cdm:DisplayMeasurementType&quot;/&gt;
              &lt;/xs:sequence&gt;
            &lt;/xs:complexType&gt;
          &lt;/xs:element&gt;
          &lt;xs:element name=&quot;LCDDevice&quot;&gt;
            &lt;xs:complexType&gt;
              &lt;xs:sequence&gt;
                &lt;xs:element name=&quot;MeasurementData&quot; type=&quot;cdm:DisplayMeasurementType&quot;/&gt;
              &lt;/xs:sequence&gt;
            &lt;/xs:complexType&gt;
          &lt;/xs:element&gt;
          &lt;xs:element name=&quot;RGBProjectorDevice&quot;&gt;
            &lt;xs:complexType&gt;
              &lt;xs:sequence&gt;
                &lt;xs:element name=&quot;MeasurementData&quot; type=&quot;cdm:RGBProjectorMeasurementType&quot;/&gt;
              &lt;/xs:sequence&gt;
            &lt;/xs:complexType&gt;
          &lt;/xs:element&gt;
          &lt;xs:element name=&quot;ScannerDevice&quot;&gt;
            &lt;xs:complexType&gt;
              &lt;xs:sequence&gt;
                &lt;xs:element name=&quot;MeasurementData&quot; type=&quot;cdm:RGBCaptureMeasurementType&quot;/&gt;
              &lt;/xs:sequence&gt;
            &lt;/xs:complexType&gt;
          &lt;/xs:element&gt;
          &lt;xs:element name=&quot;CameraDevice&quot;&gt;
            &lt;xs:complexType&gt;
              &lt;xs:sequence&gt;
                &lt;xs:element name=&quot;MeasurementData&quot; type=&quot;cdm:RGBCaptureMeasurementType&quot;/&gt;
              &lt;/xs:sequence&gt;
            &lt;/xs:complexType&gt;
          &lt;/xs:element&gt;
          &lt;xs:element name=&quot;RGBPrinterDevice&quot;&gt;
            &lt;xs:complexType&gt;
              &lt;xs:sequence&gt;
                &lt;xs:element name=&quot;MeasurementData&quot; type=&quot;cdm:RGBPrinterMeasurementType&quot;/&gt;
              &lt;/xs:sequence&gt;
            &lt;/xs:complexType&gt;
          &lt;/xs:element&gt;
          &lt;xs:element name=&quot;CMYKPrinterDevice&quot;&gt;
            &lt;xs:complexType&gt;
              &lt;xs:sequence&gt;
                &lt;xs:element name=&quot;MeasurementData&quot; type=&quot;cdm:CMYKPrinterMeasurementType&quot;/&gt;
              &lt;/xs:sequence&gt;
            &lt;/xs:complexType&gt;
          &lt;/xs:element&gt;
          &lt;xs:element name=&quot;RGBVirtualDevice&quot;&gt;
            &lt;xs:complexType&gt;
              &lt;xs:sequence&gt;
                &lt;xs:element name=&quot;MeasurementData&quot; type=&quot;cdm:RGBVirtualMeasurementType&quot;/&gt;
              &lt;/xs:sequence&gt;
            &lt;/xs:complexType&gt;
          &lt;/xs:element&gt;
        &lt;/xs:choice&gt;
        &lt;xs:element name=&quot;PlugInDevice&quot; minOccurs=&quot;0&quot;&gt;
          &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
              &lt;xs:any namespace=&quot;##other&quot; processContents=&quot;skip&quot;
                minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; /&gt;
            &lt;/xs:sequence&gt;
            &lt;xs:attribute name=&quot;GUID&quot; type=&quot;wcs:GUIDType&quot; use=&quot;required&quot;/&gt;
          &lt;/xs:complexType&gt;
        &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name=&quot;ID&quot; type=&quot;xs:string&quot; use=&quot;optional&quot; /&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
&lt;/xs:schema&gt;

</code></pre>
<h2>WCS CDMP v2.0 Calibration Addition</h2>
<p>The <strong>ColorDeviceModel</strong> element of the CDMP schema has been updated in Windows 7 to include the new calibration element. The following shows the change to the CDMP schema.</p>
<pre lang="C++"><code>  ...
  &lt;xs:element name=&quot;ColorDeviceModel&quot;&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        ...
        &lt;xs:element name=&quot;PlugInDevice&quot; minOccurs=&quot;0&quot;&gt;
             ...
        &lt;/xs:element&gt;
        &lt;xs:element name=&quot;Calibration&quot; type=&quot;cal:Calibration&quot; minOccurs=&quot;0&quot;/&gt;
        ...
      &lt;xs:sequence&gt;
    ...
    &lt;xs:complexType&gt;
  ...
</code></pre>
<h2>The CDMP Schema Elements</h2>
<blockquote>
<p>[!Note]<br />
Primaries are primary samples of red, green, blue, black, and white. A primary ramp is a tonal ramp from least luminance to full primary value. The maximum number of entries in a tone ramp is 4096.</p>
</blockquote>
<blockquote>
<p>[!Note]<br />
DMPs are required to have measurement data.</p>
</blockquote>
<h3>ColorDeviceModelProfile</h3>
<p>This element is of type ColorDeviceModel.</p>
<p><strong>Validation conditions:</strong> Each sub-element is validated by its own type.</p>
<h3>ColorDeviceModel</h3>
<p>This element is a sequence of the following sub-elements</p>
<ol>
<li>ProfileName string,</li>
<li>optional Description string,</li>
<li>optional Author string,</li>
<li>optional MeasurementConditions MeasurementConditionsType,</li>
<li>Self-Luminous Boolean,</li>
<li>MaxColorant float,</li>
<li>MinColorant float,</li>
<li>Choice of elements
<ol>
<li>CRTDevice,</li>
<li>LCDDevice,</li>
<li>RGBProjectorDevice,</li>
<li>ScannerDevice,</li>
<li>CameraDevice,</li>
<li>RGBPrinterDevice,</li>
<li>CMYKPrinterDevice,</li>
<li>RGBVirtualDevice,</li>
</ol>
</li>
<li>PlugInDevice,</li>
<li>optional Extension ExtensionType</li>
</ol>
<p><strong>Validation conditions:</strong> Each sub-element is validated by its own type. String sub-elements have a maximum of 10,000 characters. The MaxColorant sub-element must be greater than or equal to zero (0) and greater than the MinColorant sub-element. The MinColorant can be negative.</p>
<h3>NamespaceVersion</h3>
<p>xmlns:cdm=&quot;<a href="http://schemas.microsoft.com/windows/2005/02/color/ColorDeviceModel">http://schemas.microsoft.com/windows/2005/02/color/ColorDeviceModel</a>&quot;</p>
<p>targetNamespace=&quot;<a href="http://schemas.microsoft.com/windows/2005/02/color/ColorDeviceModel">http://schemas.microsoft.com/windows/2005/02/color/ColorDeviceModel</a>&quot;</p>
<h3>Version</h3>
<p>Version = &quot;1.0&quot; with Windows Vista.</p>
<p><strong>Validation conditions:</strong> Any version value &gt;0.1 or &lt;=2.0 is valid to support non-breaking changes to the format.</p>
<h3>Documentation</h3>
<p>Device Model Profile schema.</p>
<p>Copyright (C) Microsoft. All rights reserved.</p>
<h3>CRTDevice element</h3>
<p>This element is a sequence of sub-elements of a MeasurementData DisplayMeasurementType.</p>
<p><strong>Validation conditions:</strong> Each sub-element is validated by its own type.</p>
<h3>LCDDevice element</h3>
<p>This element is a sequence of sub-elements of a MeasurementData DisplayMeasurementType.</p>
<p><strong>Validation conditions:</strong> Each sub-element is validated by its own type.</p>
<h3>ProjectorDevice element</h3>
<p>This element is a sequence of sub-elements of a MeasurementData RGBProjectorMeasurementType.</p>
<p><strong>Validation conditions:</strong> Each sub-element is validated by its own type.</p>
<h3>ScannerDevice element</h3>
<p>This element is a sequence of sub-elements of a MeasurementData RGBCaptureMeasurementType</p>
<p><strong>Validation conditions:</strong> Each sub-element is validated by its own type.</p>
<h3>CameraDevice element</h3>
<p>This element is a sequence of sub-elements of a MeasurementData RGBCaptureMeasurementType</p>
<p><strong>Validation conditions:</strong> Each sub-element is validated by its own type.</p>
<h3>RGBPrinterDevice element</h3>
<p>This element is a sequence of sub-elements of a MeasurementData RGBPrinterMeasurementType.</p>
<p><strong>Validation conditions:</strong> Each sub-element is validated by its own type.</p>
<h3>CMYKPrinterDevice element</h3>
<p>This element is a sequence of sub-elements of a MeasurementData CMYKPrinterMeasurementType.</p>
<p><strong>Validation conditions:</strong> Each sub-element is validated by its own type.</p>
<h3>RGBVirtualDevice element</h3>
<p>This element is a sequence of sub-elements of a RGBVirtualMeasurementDataType.</p>
<p><strong>Validation conditions:</strong> Each sub-element is validated by its own type.</p>
<h3>PlugInDeviceType</h3>
<p>This element is a sequence of a GUID GUIDType and any sub-elements.</p>
<p><strong>Validation conditions:</strong> The GUID is used to match the DM PlugIn Dll GUID. There are a maximum of 100,000 custom sub-elements.</p>
<h3>RGBVirtualMeasurementType</h3>
<p>This element is a sequence consisting of</p>
<ol>
<li>
<p>RGBPrimariesGroup group</p>
</li>
<li>
<p>A choice of</p>
</li>
<li>
<ul>
<li>Gamma</li>
<li>GammaOffsetGain</li>
<li>GammaOffsetGainLinearGam</li>
<li>ToneResponseCurves elements</li>
</ul>
</li>
<li>
<p>optional GamutBoundarySamples GamutBoundarySamplesType</p>
</li>
<li>
<p>TimeStamp dateTime</p>
</li>
</ol>
<p><strong>Validation conditions:</strong> Each sub-element of these types has its own validation conditions.</p>
<h3>GammaType</h3>
<p>This element is a complex type consisting of the attribute</p>
<ul>
<li>Gamma NonNegativeFloatType</li>
</ul>
<p><strong>Validation conditions:</strong> To be determined from industry feedback.</p>
<h3>GammaOffsetGainType</h3>
<p>This element is a complex type consisting of the attributes</p>
<ul>
<li>Gamma NonNegativeFloatType</li>
<li>Offset NonNegativeFloatType</li>
<li>Gain NonNegativeFloatType</li>
</ul>
<p><strong>Validation conditions:</strong> To be determined from industry feedback.</p>
<h3>GammaOffsetGainLinearGainType</h3>
<p>This element is a complex type consisting of the attributes</p>
<ul>
<li>Gamma NonNegativeFloatType</li>
<li>Offset NonNegativeFloatType</li>
<li>Gain NonNegativeFloatType</li>
<li>LinearGain NonNegativeFloatType</li>
<li>TransitionPoint NonNegativeFloatType.</li>
</ul>
<p><strong>Validation conditions:</strong> To be determined from industry feedback.</p>
<h3>ToneResponseCurvesType</h3>
<p>This element is a sequence of</p>
<ol>
<li>RedTRC FloatPairList</li>
<li>GreenTRC FloatPairList</li>
<li>BlueTRC FloatPairList</li>
</ol>
<p>The element also has an attribute TRCLength of unsignedint type.</p>
<p><strong>Validation conditions:</strong> To be determined from industry feedback.</p>
<h3>GamutBoundarySamplesType</h3>
<p>This element is a sequence of RGB RGBTypes.</p>
<p><strong>Validation conditions:</strong> Currently unbounded maximum occurences, to be capped based on industry feedback.</p>
<h3>FloatPairList</h3>
<p>This element is a simple type of list of pairs of floats.</p>
<p><strong>Validation conditions:</strong> To be determined from industry feedback.</p>
<h3>CMYKPrinterMeasurementType</h3>
<p>This element is a</p>
<ol>
<li>
<p>sequence of ColorCube element consisting of a sequence of Sample NonNegativeCMYKSampleType</p>
</li>
<li>
<p>TimeStamp dateTime attribute.</p>
</li>
</ol>
<p><strong>Validation conditions:</strong> To be determined from industry feedback.</p>
<h3>RGBPrinterMeasurementType</h3>
<p>This element is a</p>
<ol>
<li>
<p>sequence of ColorCube element consisting of a sequence of Sample NonNegativeRGBSampleType</p>
</li>
<li>
<p>TimeStamp dateTime attribute.</p>
</li>
</ol>
<p><strong>Validation conditions:</strong> To be determined from industry feedback.</p>
<h3>RGBCaptureMeasurementType</h3>
<p>This element is a sequence of</p>
<ol>
<li>
<p>PrimaryIndex complexType of</p>
</li>
<li>
<ol>
<li>White OneBasedIndex</li>
<li>Optional Black OneBasedIndex</li>
<li>Optional Red OneBasedIndex</li>
<li>Optional Green OneBasedIndex</li>
<li>Optional Blue OneBasedIndex</li>
<li>Optional Cyan OneBasedIndex</li>
<li>Optional Magenta OneBasedIndex</li>
<li>Optional Yellow OneBasedIndex</li>
</ol>
</li>
<li>
<p>NeutralIndices of lines of OneBasedIndex</p>
</li>
<li>
<p>ColorSamples sequence of Sample NonNegativeRGBSampleType</p>
</li>
</ol>
<p>The element also has a TimeStamp dateTime attribute.</p>
<p><strong>Validation conditions:</strong> To be determined from industry feedback.</p>
<h3>OneBasedIndex</h3>
<p>This element is a simple type of restriction base unsigned int with minInclusive value = &quot;1.&quot;</p>
<p><strong>Validation conditions:</strong> To be determined from industry feedback.</p>
<h3>RGBProjectorMeasurementType</h3>
<p>This element is a sequence of</p>
<ol>
<li>RGBPrimariesGroup group</li>
<li>element ColorSamples consisting of sequence of Sample NonNegativeRGBSampleType</li>
</ol>
<p>The element also has a TimeStamp dateTime attribute.</p>
<p><strong>Validation conditions:</strong> To be determined from industry feedback.</p>
<h3>DisplayMeasurementType</h3>
<p>This element is a sequence of</p>
<ol>
<li>group RGBPrimariesGroup</li>
<li>GrayRamp of sequence of Sample NonNegativeRGBType</li>
<li>RedRamp of sequence of Sample NonNegativeRGBType</li>
<li>GreenRamp of sequence of Sample NonNegativeRGBType</li>
<li>BlueRamp of sequence of Sample NonNegativeRGBType</li>
</ol>
<p>The DisplayMeasurementType element also has a TimeStamp dateTime attribute.</p>
<p><strong>Validation conditions:</strong> To be determined from industry feedback.</p>
<h3>MeasurementConditionsType</h3>
<p>The MeasurementConditionsType is a sequence of sub-elements that contains:</p>
<ol>
<li>ColorSpace restricted string enumeration value of &quot;CIEXYZ&quot;</li>
<li>optional choice of WhitePoint NonNegativeXYZType or WhitePointName string enumeration of values D50, D65, A, or F2</li>
<li>Geometry GeometryType</li>
<li>ApertureSize integer in millimeters</li>
</ol>
<p>Defaults are:</p>
<ol>
<li>RGB and CMYK Printers:
<ol>
<li>CIEXYZ MeasurementSpaceType</li>
<li>D50 WhitePointValue</li>
<li>0/45 GeometryType</li>
<li>10mm ApertureSize</li>
</ol>
</li>
<li>Scanners:
<ol>
<li>CIEXYZ MeasurementSpaceType</li>
<li>D50 WhitePointValue</li>
<li>0/45 GeometryType</li>
<li>10mm ApertureSize</li>
</ol>
</li>
<li>Displays and RGB Virtual Device:
<ol>
<li>CIEXYZ MeasurementSpaceType</li>
<li>D65 WhitePointValue</li>
<li>0/45 GeometryType</li>
<li>10mm ApertureSize</li>
</ol>
</li>
<li>Cameras:
<ol>
<li>CIEXYZ MeasurementSpaceType</li>
<li>D65 WhitePointValue</li>
<li>Direct GeometryType</li>
<li>10mm ApertureSize</li>
</ol>
</li>
</ol>
<p><strong>Validation conditions:</strong> Validation of each sub-element is determined by validation conditions for those sub-elements. If any sub-element is missing, the device model type specific default is used.</p>
<h3>GeometryType</h3>
<p>String</p>
<p>Enumeration values:</p>
<ul>
<li>&quot;0/45&quot;</li>
<li>&quot;0/diffuse&quot;</li>
<li>&quot;diffuse/0&quot;</li>
<li>&quot;Direct&quot;</li>
</ul>
<p><strong>Validation conditions:</strong> Any value except the enumberation values listed is invalid. This information will not change baseline processing behavior.</p>
<h3>RGBPrimariesGroup</h3>
<p>This element is a sequence of</p>
<ol>
<li>WhitePrimary NonNegativeXYZType</li>
<li>RedPrimary NonNegativeXYZType</li>
<li>GreenPrimary NonNegativeXYZType</li>
<li>BluePrimary NonNegativeXYZTYpe</li>
<li>BlackPrimary NonNegativeXYZType</li>
</ol>
<p><strong>Validation conditions:</strong> To be determined from industry feedback.</p>
<h3>NonNegativeCMYKSampleType</h3>
<p>This element is a sequence of</p>
<ol>
<li>CMYK NonNegativeCMYKType</li>
<li>CIEXYZ NonNegativeXYZType</li>
</ol>
<p>The element also has an optional attribute Tag string</p>
<p><strong>Validation conditions:</strong> To be determined from industry feedback.</p>
<h3>NonNegativeRGBSampleType</h3>
<p>This element is a sequence of</p>
<ol>
<li>RGB NonNegativeRGBType</li>
<li>CIEXYZ NonNegativeXYZType</li>
</ol>
<p>The element also has an optional attribute Tag string</p>
<p><strong>Validation conditions:</strong> To be determined from industry feedback.</p>
<h3>NonNegativeCMYKType</h3>
<p>This element consisting of attributes</p>
<ol>
<li>C float</li>
<li>M float</li>
<li>Y float</li>
<li>K float</li>
</ol>
<p><strong>Validation conditions:</strong> To be determined from industry feedback.</p>
<h3>NonNegativeRGBType</h3>
<p>This element consisting of attributes</p>
<ol>
<li>R float</li>
<li>G float</li>
<li>B float</li>
</ol>
<p><strong>Validation conditions:</strong> To be determined from industry feedback.</p>
<h3>ExtensionType</h3>
<p>The ExtensionType element is a sequence of any sub-element type and is used for proprietary information from non-Microsoft applications.</p>
<p><strong>Validation conditions:</strong> This element is optional. There can be a maximum of 1000 extension sub-elements.</p>
<h3>NonNegativeXYZType</h3>
<p>The NonNegativeXYZType element is composed of NonNegativeFloatType three single-precision IEEE floating-point elements named &quot;X,&quot; &quot;Y,&quot; and &quot;Z.&quot; These values are limited to the DMP profiles measurement values. These measurements can be either absolute (not relative) CIEXYZ 1931 reflective values or absolute (not relative) CIEXYZ 1931 direct (transmissive) values in candelas per meter squared units.</p>
<p><strong>Validation conditions:</strong> Only real-world values are valid, and negative CIEXYZ measurement values are invalid. Because these are absolute values, values can be greater than 1.0f. A reasonable limit for any &quot;X,&quot; &quot;Y,&quot; or &quot;Z.&quot; value is arbitrarily set to 10000.0f.</p>
<h3>XYZType</h3>
<p>The XYZType element is composed of three single-precision IEEE floating-point values: &quot;X,&quot; &quot;Y,&quot; and &quot;Z.&quot;</p>
<h2>The CDMP Baseline Algorithms</h2>
<h3>CRT Device Model Baseline</h3>
<p>To understand this model, you must consider both the characterization process and the device modeling. In the characterization process, XYZ measurements are first performed on the colors obtained by filling the display buffer of a CRT display device. The following example values will generate good data for the baseline CRT device model:</p>
<p>Red: R = 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 195, 210, 225, 240, 255, G = B = 0</p>
<p>Green: G = 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 195, 210, 225, 240, 255, R = B = 0</p>
<p>Blue: B = 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 195, 210, 225, 240, 255, R = G = 0</p>
<p>Neutrals: R = G= B = 0, 8, 16, 32, 64, 128, 192, 255</p>
<p>Increments other than 15 and nonlinear increments can also be used. Each red, green, blue, and neutral ramp must contain at least three samples, but providing more samples is recommended. You must provide samples for pure red, green, blue, black, and white. The samples do not have to be uniformly spaced.</p>
<p>The process of building the tristimulus matrix consists of two steps. First, estimate the black point XYZ value, or the flare. This step is based largely on work of Berns[3] with a slightly modified objective function for the nonlinear optimization. Second, calculate tristimulus matrix based on the result from step one and also from an averaging calculation on all of the per-channel measurements, not just the one for maximum digital count.</p>
<p>Each of these steps contains detailed procedures. The starting point is the ramps (17 steps in our example) for each of R, G, and B channels. When the XYZ measurements are plotted on the chromaticity <em>xy</em> -plane, a typical situation is shown in Figure 1. Step one consists of solving a nonlinear optimization problem to find the &quot;best fit&quot; black point that will minimize the drift in chromaticity as one traverses along the R, G, and B channels. Based on Berns[3], we seek ( <em>X<!-- raw HTML omitted -->K<!-- raw HTML omitted --></em>,<em>Y<!-- raw HTML omitted -->K<!-- raw HTML omitted --></em>,<em>Z<!-- raw HTML omitted -->K<!-- raw HTML omitted --></em> ) that minimizes the following objective function:</p>
<p><img src="images/cdmp-formula1.png" alt="Shows the objective function where Sr, Sg, and Sb are the set of data points on the R, G, and B channels." /></p>
<p>where <em>S<!-- raw HTML omitted -->R<!-- raw HTML omitted --></em>,<em>S<!-- raw HTML omitted -->G<!-- raw HTML omitted --></em>, and <em>S<!-- raw HTML omitted -->B<!-- raw HTML omitted --></em> are the set of data points corresponding to the points on the R, G, and B channels. For any set <em>S</em>, define:</p>
<p><img src="images/cdmp-formula2.png" alt="Shows a formula for defining any set S." /></p>
<p>In the preceding, | <em>S</em> | is the cardinality of <em>S</em>, i.e., the number of points in the set <em>S</em>. <img src="images/cdmp-formula3.png" alt="Shows a formula for the chromaticity of a point." /> is the chromaticity coordinates of the point <img src="images/cdmp-formula4.png" alt="Shows a formaula for a point." /> , so <img src="images/cdmp-formula5.png" alt="Shows a formula for the average or center of mass." />, is the average, or center of mass, of all the points in the set <em>S</em> in the chromaticity plane. Thus, <img src="images/cdmp-formula6.png" alt="Shows a formula for the sum of a second moments of points." /> is the sum of second moments of the points about the center of mass and is a measure of how spread out the points are about it. Finally, <img src="images/cdmp-formula7.png" alt="Shows a formula for the total measure of the spread of three clusters of points." /> is a total measure of how spread out the three clusters of points are about their respective centers of mass.</p>
<p>In the calculation of <img src="images/cdmp-formula8.png" alt="Shows a formula of f(X,Y,Z; Xk, Yk, Zk)." /> , if <img src="images/cdmp-formula9.png" alt="Shows a formula for X." /> , then the calculation is skipped, and the cardinality of <em>S</em> is adjusted accordingly.</p>
<p>Despite the apparent complexity of the objective function, it is a sum of the squares of many differentiable functions in <em>X<!-- raw HTML omitted -->K<!-- raw HTML omitted --></em>,<em>Y<!-- raw HTML omitted -->K<!-- raw HTML omitted -->Z<!-- raw HTML omitted -->K<!-- raw HTML omitted --></em> (17 points   2<em>xy</em> -components   3 channels = 102, in the example), and, therefore, is amenable to standard nonlinear least squares techniques, such as the Levenberg-Marquardt algorithm, which is the algorithm used in WCS. Note that the preceding objective function is different from the one suggested in Berns[3] in that the latter function measures the variance of the distances from the center of mass, so that the variance is zero when the points are equidistant from the center of mass, even though they may spread out quite a bit about it. In the example, the dispersion of points is contolled directly using the second moments.</p>
<p>As with any iterative algorithm for the nonlinear least squares problem, Levenberg-Marquardt requires an initial guess. There are two obvious candidates. One is (0, 0, 0); the other is the measured black point. For the CTE, the measured black point is first used as the initial guess. If a maximum of 100 iterations is exceeded without achieving a threshold of an average distance of 0.001 of each point from its center of mass (which corresponds to a threshold value of (0.001)    17   3 = 0.000051 for the objective function), then another round of iterations with the initial guess of (0, 0, 0) is performed. The resulting estimate of the black point is XYZ compared with the best estimate from the previous round of iterations (with the measured black point as the initial guess). Use the estimate that gives the smallest value for the objective function. The choice of 100 iterations and the error distance of 0.001 were each selected empirically. In future versions, it might be reasonable to parameterize the error distance.</p>
<p>The result of step one is the estimated black point ( <em>X<!-- raw HTML omitted -->K<!-- raw HTML omitted --></em>,<em>Y<!-- raw HTML omitted -->K<!-- raw HTML omitted --></em>,<em>Z<!-- raw HTML omitted -->K<!-- raw HTML omitted --></em> ). Step two consists of determining the tristimulus matrix by averaging the chromaticity of the points in the three clusters obtained in step one. For CRTs, this is done primarily to minimize the effects of measurement errors. The points used in averaging the chromaticity must be the same points used in the optimization in step one. In other words, if the first point (digital count 15, in the example) in each ramp is discarded in the optimization step, then the same must be done in the averaging. If <img src="images/cdmp-formula10.png" alt="Shows formulas of averaged chromaticity for coordinates in the red and green channels." /> , and <img src="images/cdmp-formula11.png" alt="Shows a formula of averaged chromaticity for coordinates in the blue channel." /> are the averaged chromaticity coordinates of the red, green, and blue channels, then the following procedure determines the tristimulus matrix. First, solve the 3?3 linear system:</p>
<p><img src="images/cdmp-formula12.png" alt="Shows the first part of the procedure to solve a 3?3 linear system." /></p>
<p><img src="images/cdmp-formula13.gif" alt="Shows the second part of the 3?3 linear system." /><img src="images/cdmp-formula14.gif" alt="Show the t subscript b value at the end of the second part of the 3?3 linear system." /></p>
<p><em>X<!-- raw HTML omitted -->W<!-- raw HTML omitted --></em>,<em>Y<!-- raw HTML omitted -->W<!-- raw HTML omitted --></em>,<em>Z<!-- raw HTML omitted -->W<!-- raw HTML omitted --></em></p>
<p><img src="images/cdmp-formula15.png" alt="Shows the final part of the procedure to solve a 3?3 linear system." /></p>
<p>After the tristimulus matrix is determined, the determination of tone curves follows the standard approach. For CRT displays, the individual channels are assumed to follow the &quot;GOG&quot; model:</p>
<p><img src="images/cdmp-formula16.png" alt="Shows the formula for the 'G O G' model." /></p>
<p>where <em>k<!-- raw HTML omitted -->g<!-- raw HTML omitted --></em> is the &quot;gain&quot;,1 -<em>k<!-- raw HTML omitted -->g<!-- raw HTML omitted --></em> is the &quot;offset&quot;, and ? is the &quot;gamma.&quot; The inverse matrix of the tristimulus matrix is applied to the XYZ data of the neutrals to obtain the linear RGB data, which is then correlated with the digital RGB values using nonlinear regression on the GOG model. These characteristics do not have to be the same for the R, G, and B channels, and generally are not the same.</p>
<p>Berns[1]: Berns, <em>Billmeyer and Saltzman's Principles of Color Technology</em>, 3 <!-- raw HTML omitted -->rd<!-- raw HTML omitted --> Ed. John Wiley &amp; Sons (2000).</p>
<p>Berns[2]: Berns and Katoh, The digital to radiometric transfer function for computer controlled CRT displays, <em>CIE Expert Symposium '97 Colour Standards for Imaging Technology</em>, Nov. 1997.</p>
<p>Berns[3]: Berns, Fernandez and Taplin, Estimating Black-Level Emissions of Computer-Controlled Displays, <em>Color Research and Application</em>, 28: 379-383 Wiley Periodicals, Inc. (2003)</p>
<p>Kang[1]: Kang, <em>Color Technology for Electronic Imaging Devices</em>, SPIE (1997)</p>
<p>Katoh[1]: Katoh, Deguchi and Berns, An accurate characterization of CRT monitor (II) proposal for an extension to CIE method and its verification, <em>Opt. Rev.</em> 8: 397-408 (2001)</p>
<h3>LCD Device Model Baseline</h3>
<p>The LCD Device Model Baseline is similar to the CRT Device Model Baseline. This section will explain the ways in which LCD modeling differs from CRT modeling.</p>
<p>One difference is that you cannot assume that LCD displays follow the GOG model used for CRTs, and the tone curves are obtained by interpolation of measured data. Because of that, the device neutral axis should be sampled more frequently.</p>
<p>Here are some typical example values that can generate good data for the LCD device model baseline:</p>
<p>Red: R = 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 195, 210, 225, 240, 255, G = B = 0</p>
<p>Green: G = 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 195, 210, 225, 240, 255, R = B = 0</p>
<p>Blue: B = 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 195, 210, 225, 240, 255, R = G = 0</p>
<p>Neutrals: R = G = B = 0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 195, 210, 225, 240, 255.</p>
<p>The process of averaging measured color chromaticies to obtain the chromaticities for the device primaries is more critical for LCDs than it is for CRTs. When XYZ measurements are plotted on the chromaticity <em>xy</em> -plane, a typical situation is shown in Figure 1. Notice how the chromaticity drifts toward the black point. This is because all LCDs have a certain amount of light leakage.</p>
<p><img src="images/cdmp-lcd-dmp-figure1.png" alt="Diagram that shows a graph of the chromaticity using raw data with no correction." /></p>
<p><strong>Figure 1</strong> : The chromaticity diagram using raw data with no correction</p>
<p>When this is subtracted from the raw XYZ measurements, a typical situation is depicted in Figure 2. Tthe points are now clustered about three centers, although they don't fall identically on them. The averaging process described for CRTs greatly improves the results for LCDs.</p>
<p><img src="images/cdmp-lcd-dmp-figure2.png" alt="Diagram that shows a graph of the chromaticity using raw data with an adjusted black point." /></p>
<p><strong>Figure 2</strong> : The chromaticity diagram using data with adjusted black point</p>
<h3>RGB Capture Device Model Baseline</h3>
<p>The baseline RGB capture device model is a subclass of the IDeviceModel class. In the colorimetric characterization of color capture devices, such as scanners and digital cameras, the following approach is used. A target consisting of color patches with known CIEXYZ values is captured using the capture device. The result of the capture is an RGB bitmap image in which the color of each patch is encoded in an RGB value. These device RGB values are specific to a particular capture device. The goal of colorimetric characterization is to establish an empirical relationship between the device RGB values and CIEXYZ values, or a mathematical transformation from RGB to XYZ that models as accurately as possible the behavior of the capture device.</p>
<p>Such a mathematical transformation can be modeled reasonably by polynomials of low degrees. This procedure is detailed in the literature, for example Kang[92], Kang[97]. In Kang[97], an approach is reported that uses a set of three polynomials with 3, 6, 8, 9, 11, 14 or 20 terms in the R, G, and B variables, while the three polynomials regress respectively into the X, Y, Z components of the CIEXYZ space. For the 20-term polynomial, the form is:</p>
<p><img src="images/cdmp-formula20.png" alt="Shows the 20-term polynomial." /></p>
<p>There are similar expressions for Y and Z. The mathematical technique for fitting the polynomials falls within &quot;Multivariate Linear Regression&quot; and is described in any elementary text in Statistics.</p>
<p>This method of linear regression suffers from not minimizing the &quot;right&quot; objective function. By design, linear regression finds the least squares solution, which implies that the coefficients obtained will minimize the total sum of squares of errors in the underlying space, or equivalently, the sum of squares of the Euclidean distances. In practice, you want to minimize the sum of squares of ?Es, where ?E is one of the accepted standards such as CIE94. Minimizing this objective function is a nonlinear regression problem.</p>
<p>In the new engine, Lab to XYZ is the CIE color space that is regressed into, and the 20-term cubic polynomial is used as the model for the capture device, or coefficients ls,as,bs such that the following polynomials minimize the sum of squares of ?E <!-- raw HTML omitted -->CIE94<!-- raw HTML omitted --> s.</p>
<p><img src="images/cdmp-formula21.png" alt="Shows a set of polynomial formulas." /></p>
<p>The solution ( <em>l<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em>, <em>a<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em>, <em>b<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em> ) in the 60-dimensional real numeric space <strong>R</strong>203 must be such that the following total error is minimized:</p>
<p><img src="images/cdmp-formula22.png" alt="Shows the total error to be minimized." /></p>
<p>where the summation is through all the data point pairs (<em>R<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em>,<em>G<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em>,<em>B<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em>;<em>L<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em>,<em>u<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em>,<em>v<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em> ) in the sampled data set plus additional control points to be detailed in the following. This is a nonlinear regression problem because the parameters <em>?<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em>, <em>a<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em>, * <!-- raw HTML omitted -->i<!-- raw HTML omitted -->* enter into the objective function in a nonlinear way (not quadratically).</p>
<p>Because the objective function ? is a nonlinear (and nonquadratic) function of the parameters <em>?<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em>, <em>a<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em> and * <!-- raw HTML omitted -->i<!-- raw HTML omitted -->*, you must resort to iterative techniques to solve the optimization problem. Because the form of the objective function is a sum of squares, a standard optimization technique called the Levenberg-Marquardt algorithm is used. It is considered the method of choice for nonlinear least squares problems. For iterative algorithms such as Levenberg-Marquardt, you must supply an initial guess. A good initial guess is usually critical in finding the correct minimum value. In this case, one good candidate for the initial guess is the solution of the linear regression problem. First, minimize the sum of the square of Euclidean distances in Lab space, by defining a quadratic objective function:</p>
<p><img src="images/cdmp-formula23.png" alt="Shows a defined quadratic objective function." /></p>
<p>The mathematical solution to such &quot;linear least squares&quot; problem is well known. Because <em>?<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em> only appears in the <em>L</em> modeling, <em>a<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em> only appears in the <em>u</em> modeling, and * <!-- raw HTML omitted -->i<!-- raw HTML omitted -->* only appears in the <em>v</em> modeling; the optimization problem can be decomposed into three subproblems: one for <em>L</em>, one for <em>u</em> and one for <em>v</em>. Consider the <em>L</em> equations. (The <em>u</em> equations and the <em>v</em> equations follow exactly the same argument.) The problem of minimizing the sum of squares of errors in <em>L</em> can be stated as solving the following matrix equation in the least squares sense:</p>
<p><img src="images/cdmp-formula24.png" alt="Shows a matrix equation for L." /></p>
<p>where <em>N</em> is the total number of data points (original sampled points plus control points created in a manner described below). Typically, <em>N</em> is much larger than 20, so the preceding equation is over-determined, requiring a least squares solution. A closed form solution for <strong>?</strong> is available:</p>
<p><img src="images/cdmp-formula25.png" alt="Shows a closed form solution." /></p>
<p>In practice, direct evaluation using the closed form solution is not used because it has poor numerical properties. Instead, some kind of matrix factorization algorithm is applied to the coefficient matrix which reduces the system of equations to a canonical form. In the current implementation, Singular Value Decomposition (SVD) is applied to the matrix <strong>R</strong> and then the resulting decomposed system is solved.</p>
<p>The solution to the linear regression problem, denoted by <img src="images/cdmp-formula26.png" alt="Shows the solution to the linear regression problem." /> , is used as the starting point of the Levenberg-Marquardt algorithm. In this algorithm, a trial step is computed that should move the point closer to the optimal solution. The trial step satisfies a set of linear equations dependent on the functional value and values of the derivatives at the current point. For this reason, the derivatives of the objective function ? with respect to the parameters <em>?<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em>, <em>a<!-- raw HTML omitted -->i<!-- raw HTML omitted --> <!-- raw HTML omitted -->i<!-- raw HTML omitted --></em> are required inputs to the Levenberg-Marquardt algorithm. Although there are 60 parameters, there is a shortcut that allows you to compute a lot less. By the Chain Rule of Calculus,</p>
<p><img src="images/cdmp-formula27.png" alt="Shows an equation that allows a shortcut using the Chain Rule of Calculus." /></p>
<p>where <em>j</em> = 1, 2,  , 20, <em>L<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em>,<em>u<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em>,<em>v<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em> are the CIELAB value of the <em>i</em> th sample point, and <em>R<!-- raw HTML omitted -->ij<!-- raw HTML omitted --></em> is the (<em>i</em>,<em>j</em> )th entry of the matrix <strong>R</strong> defined above. So instead of computing derivatives for 60 parameters, you can compute derivatives for <em>L</em>,<em>a</em>, and <em>b</em> using numerical forward differencing.</p>
<p>It is also necessary to set up a stopping criterion for iterative algorithms. In the current implementation, the iterations are terminated if the mean square DECIE94 is less than 1, or the number of iterations performed has exceeded 10. The number 10 comes from the practical experience that if the first few iterations do not reduce the error significantly, further iterations would not help much other than moving the point in an oscillatory manner, i.e., the algorithm may not converge. Even in the case that the algorithm diverges, we can be sure that the DECIE94 is no worse than what we started, i.e. with the parameters obtained from linear regression.</p>
<p>Even with the preceding method of nonlinear regression, there are several problems with the fitting. One problem is that the polynomials tend to overshoot or undershoot beyond the data points. Artificial local maxima and minima may be introduced in the fitting process. This can be counteracted by using polynomials of low degree, which is the reason you should not use higher than three degrees. A more serious aspect of overshooting or undershooting is that, while a polynomial can take any real value theoretically, the space it tries to model typically has physical constraints and practical constraints. CIEXYZ must have all of X, Y, Z non-negative, which is a physical constraint. In practice, they only take values in the magnitude of hundreds, not thousands or higher. Similarly, CIELAB or CIELUV has its own physical and practical constraints. When the RGB space is filled sufficiently with sample points, the problem of overshooting or undershooting is not serious. However, the captured RGB points from the capture device do not usually fill up the RGB space uniformly. The points may fill up only inner the 80% of the RGB cube, or worse, they may reside in a lower dimensional manifold. When this happens, the regressed polynomials may do a poor job at extrapolating the values beyond the data points, sometimes returning unrealistic predictions. You want a model that always returns reasonably realistic values. This requires a method that can effectively control the boundary behavior of regression polynomials by imposing additional cost to those polynomials that behave erratically near the boundary of the RGB cube. A further measure to ensure that the polynomials always return realistic values is applied by clipping the output to within the CIE spectral locus.</p>
<p>It is at this point that the scanner modeling and camera modeling diverge from each other. The camera model is expected to extrapolate to regions beyond the sampled points including the &quot;specular highlights,&quot; the same extrapolation is not required for the scanner model. The scanner target is expected to cover a characterization that is similar to the printed materials to be scanned. The scanner model is still required to be robust in the sense that it should not return unrealistic values, but extrapolation far beyond the characterization target is not required. To ensure robustness, the L-polynomial above is clipped at 100, that is, the polynomial model is forced not to extrapolate beyond &quot;Dmin&quot; of the scanner target.</p>
<p>The camera model is expected to extrapolate to specular highlights, so clipping at 100 is undesirable. Instead, the following algorithm is used.</p>
<p>Artificial control points are introduced to control the behavior of the polynomials in regions with insufficient sampling. By strategically placing these control points with appropriate values, they serve to &quot;pull&quot; the polynomials in the required direction. In the current implementation, eight control points corresponding to the corners of the RGB cube are used. If the device values are normalized to unity, then these points are:</p>
<p><em>R</em> = 0, <em>G</em> = 0, <em>B</em> = 0</p>
<p><em>R</em> = 0, <em>G</em> = 0, <em>B</em> = 1</p>
<p><em>R</em> = 0, <em>G</em> = 1, <em>B</em> = 0</p>
<p><em>R</em> = 0. <em>G</em> = 1, <em>B</em> = 1</p>
<p><em>R</em> = 1, <em>G</em> = 0, <em>B</em> = 0</p>
<p><em>R</em> = 1, <em>G</em> = 0, <em>B</em> = 1</p>
<p><em>R</em> = 1, <em>G</em> = 1, <em>B</em> = 0</p>
<p><em>R</em> = 1, <em>G</em> = 1, <em>B</em> = 1</p>
<p>Except for the white <em>R</em> =<em>G</em> =<em>B</em> = 1, which is associated with a CIELAB value of <em>L</em> = 100, <em>u</em> =<em>v</em> = 0, the following extrapolation algorithm is used to determine the appropriate CIELAB value to be associated with. Generally, for a given (<em>R</em>,<em>G</em>,<em>B</em> ), a weight is associated with each of the (<em>R<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em>,<em>G<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em>,<em>B<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em> ) in the sampled data set. There are two goals to assigning the weight. First, the weight is inversely proportional to the distance between (<em>R</em>,<em>G</em>,<em>B</em> ) and (<em>R<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em>,<em>G<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em>,<em>B<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em> ). Second, you want to discard, or assign weight 0 to, points that have a different hue than the given point (<em>R</em>,<em>G</em>,<em>B</em> ). To take the hue into account, consider points that lie within a cone whose vertex is at (0, 0, 0), whose axis coincides with the line joining (0, 0, 0) to (<em>R</em>,<em>G</em>,<em>B</em> ), and whose semi-vertical angle ? satisfies cos ? = 0.9. See Figure 3 for an illustration of this cone.</p>
<p><img src="images/cdmp-lcd-dmp-figure3.png" alt="Diagram that shows the shape of the neighborhood." /></p>
<p><strong>Figure 3</strong> : Filtering the sample points by angle and distance. The shape of the neighborhood depicted is for illustration purpose only. The actual shape depends on the distance used; it is a diamond-shaped neighborhood if the 1-norm is used.</p>
<p>Within this cone, a second filtering is performed that is based on the RGB distance, which uses the 1-norm, defined by</p>
<p><img src="images/cdmp-formula28.png" alt="Shows the formula for the second filtering within the cone." /></p>
<p>With the current cone, the initial search is for points that are within a distance of 0.1 from (<em>R</em>,<em>G</em>,<em>B</em> ). If no point is found within this radius, the radius is increased by 0.1, and the search is restarted. If the next round nets no point either, the radius is increased by 0.1. This process continues until the radius exceeds MaxDist/5, where MaxDist = 3, in the case of 1-norm. If no point is found, the cone is enlarged by decreasing the cos ? by 0.05, that is, increasing the angle ? and restarting the whole process with an increasing radius. This process continues until a non-empty set of points is found, or cos ? reaches 0, that is, the cone has opened up to become a plane. At this point, the search is restarted by increasing the radius, except that the search continues until the radius reaches MaxDist. This guarantees that in the worst-case scenario, a non-empty set of points will be found. The algorithm is summarized in the flow diagram in Figure 4.</p>
<p><img src="images/cdmp-lcd-dmp-figure4.png" alt="Diagram that shows the flow of the algorithm." /></p>
<p><strong>Figure 4</strong> : Flow diagram for determining the set S of sample points used in the extrapolation for an input RGB value</p>
<p>Assuming that the preceding process yields a non-empty set <em>S</em> of points (<em>R<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em>,<em>G<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em>,<em>B<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em> ) and corresponding (<em>L<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em>,<em>a<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em>,<em>b<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em> ), then for each such point, a weight <em>w<!-- raw HTML omitted -->i<!-- raw HTML omitted --></em> is assigned, given by</p>
<p><img src="images/cdmp-formula29.png" alt="Shows the formula for a weight for each point." /></p>
<p>Finally, the extrapolant is defined by</p>
<p><img src="images/cdmp-formula30.png" alt="Shows the definition for the extrapolant." /></p>
<p>The preceding equations constitute an instance of the &quot;inverse-distance weighted methods,&quot; commonly called the Shepard methods. By running each of the eight points from eq (6) through the algorithm, eight control points are obtained, each with <em>R</em>,<em>G</em>,<em>B</em> and <em>L</em>,<em>a</em>,<em>b</em> values, which are put into the pool with the original sample data.</p>
<p>To ensure that the model always produces valid color values and for system integrity and stability down the whole color processing pipeline, you must perform a final clipping to the output of the polynomial model. The CIE visual gamut is described by the achromatic component (<em>Y</em> or <em>L</em> ) and the chromatic component (<em>xy</em> or <em>a'b'</em>, which are related to the XYZ space by a projective transformation). In the current implementation, the <em>a'b'</em> chromaticity is used because it is directly related to the CIELUV space. For any <em>CIELAB</em> value, first clip <em>L</em> to a non-negative value:</p>
<p><img src="images/cdmp-formula31.png" alt="Shows the clipping of L to a non-negative value." /></p>
<p>To allow extrapolation for specular highlights, <em>L</em> is not clipped at 100, the &quot;conventional&quot; upper bound for <em>L</em> in Lab space.</p>
<p>Next, if <em>L</em> = 0, then <em>a</em> and <em>b</em> are clipped such that a*= b =* 0. If <em>L</em> ? 0, calculate</p>
<p><img src="images/cdmp-formula32.png" alt="Shows the formula if L=0." /></p>
<p>These are the components of a vector in the <em>a'b'</em> diagram from the white point (<em>u?'</em>,<em>v?'</em> ) to the color in question. Define the CIE spectral locus as the convex hull of all the points (<em>a'</em>,<em>b'</em> ), parameterized by the wavelength ?:</p>
<p><img src="images/cdmp-formula33.png" alt="Shows the formula for the wavelength." /></p>
<p>where <img src="images/cdmp-formula34.png" alt="Shows the functions for CIE color-matching." /> are the CIE color-matching functions for the 2-degree observer. If the vector lies outside the CIE locus, the color is clipped to the point on the CIE locus that is the intersection of the locus and the line defined by the vector. See Figure 5. If clipping has occurred, the <em>a</em> and <em>b</em> value is reconstructed by first subtracting <em>a?'</em> and <em>b?'</em> from the clipped <em>a'</em> and <em>b'</em>, and then multiplying by 13 <em>L</em>.</p>
<p><img src="images/cdmp-lcd-dmp-figure5.png" alt="Diagram that shows the graph for the clipping algorithm." /></p>
<p><strong>Figure 5</strong> : Clipping algorithm for Lab values that are outside the CIE visual gamut</p>
<p>In the current implementation, the CIE spectral locus in the <em>a'b'</em> plane is represented by a piecewise linear curve with 35 segments (corresponding to a wavelength from 360 nm to 700 nm inclusive). By ordering the line segments so that their subtended angles at the white point are ascending, which is equivalent to descending wavelengths, the line segment that intersects with the ray formed by the above vector can be found by a simple binary search.</p>
<h3>RGB Printer Device Model Baseline</h3>
<p>A device characterization of a RGB printer consists of constructing an empirical model of the device that predicts the device-independent CIELUV color for any given RGB value</p>
<p>There are two ways to construct the empirical model. One way is to use the device data for a RGB printer, and the other is to use analytical parameter data. In the first one, measurement data provided by a user for a RGB printer device is used to construct 3-D lookup table (LUT). The measurement data consists of XYZ values for uniformly sampled RGB patches. Typical sampling sizes are 9 or 17 for each component. Each patch is measured with a colorimeter or spectrophotometer in CIEXYZ space. The XYZ value for a patch is then converted into CIELUV value, forming a 3-D LUT. In the device model, the Sakamoto's tetrahedral interpolation method is applied to the 3-D LUT in order to predict the CIELUV data for a given RGB data. (Confer US Patent 4275413 (Sakamoto et al.), US Patent 4511989 (Sakamoto), Kang [1]. The two patents mentioned have expired.). The analytical parameter data passed in the second method is simply a LUT that was built previously. Typically, that LUT was built using the first method, although it could be hand-built.</p>
<p>In the current color management, the source map is defined as the map that goes from RGB space to a device-independent CIEXYZ color space. The destination map is defined as the map that goes from the device-independent CIEXYZ color space to RGB space. It is the inverse of the source map.</p>
<p>The empirical model is directly used in the source map. It first maps a given RGB data into a CIELUV data, which is converted into XYZ data. In the destination map, device-independent CIEXYZ data is first converted into CIELUV data. Then, the empirical model and the classical Newton-Raphson method are used to predict the best RGB data for the CIELUV data. The details about conversion from CieLUV to RGB data are as follows:</p>
<p>After generating a 3-D LUT from RGB to CieLUV, the map from RGB to LUV is built using tetrahedral interpolation on RGB. This map is denoted by the following equations:</p>
<p><img src="images/cdmp-image125.png" alt="Shows the equations for the map from R G B to L U V." /></p>
<p>Inversion of the map consists of solving, for any color <img src="images/cdmp-image127.png" alt="Shows L U V." /> , the following system of nonlinear equations:</p>
<p><img src="images/cdmp-image129.png" alt="Shows the nonlinear equations for lolving any color L U V." /></p>
<p>A nonlinear equation that is based on the classical Newton-Raphson method is used in the new CTE. An initial guess, or <em>a priori</em> see, s <!-- raw HTML omitted -->prior<!-- raw HTML omitted --> -(R 0, G 0, B 0 ) is obtained by searching through a &quot;seed matrix&quot; consisting of a uniform 8x8x8 grid of pre-computed (RGB,Luv) pairs. The RGB corresponding Luv that is closest to the L*u*v* is chosen. Each point in the seed matrix corresponds to the center of a cell so that the iterations don't start with a point on the boundary face of the RGB cube. In other words, the RGB of the seeds is defined by: STEP = 1/8 s <!-- raw HTML omitted -->ijk<!-- raw HTML omitted --> = (STEP/2 + (i-1) STEP, STEP/2+(j-1)STEP, STEP/2+(k-1)STEP) with i,j,k = 1...8 At the <em>i</em> th step of Newton-Raphson, the next estimate <img src="images/cdmp-image133.png" alt="Shows the variables for the next estimate." /> is obtained by the formula:</p>
<p><img src="images/cdmp-image135.png" alt="Shows the formula for the estimate." /></p>
<p>Iteration stops when the error (distance in the CIELUV space) is less than a pre-set tolerance level (0.1 in the CTE), or when the number of iterations has exceeded the maximum allowed number of iterations (10 in the CTE). The values for the tolerance and the number of iterations were empirically determined to be effective. In future versions, the tolerance value may be changed.</p>
<p>The Jacobian matrix is calculated using forward difference, except at a boundary point (one or more of the R, G, B is 1) where backward difference is used instead. Instead of calculating the inverse of the Jacobian matrix, the linear system is solved directly using Gauss-Jordan elimination with full pivoting.</p>
<p>At the end of the iterations, convergence still might not be achieved because Newton-Raphson is a &quot;local&quot; algorithm, that is, it only works well if you start with an initial guess that is close to the true solution. If, at the end of the Newton-Raphson iterations, convergence within the pre-defined error tolerance has not been achieved, the iterations are restarted with a new set of seeds, defined as follows.</p>
<p>For example, the best solution obtained so far is (r, g, b). From this solution, N a posteriori seeds are derived, where N = 4. Intuitively, the solution is moved &quot;toward the center&quot; in a step size that depends on N. See Figure 6.</p>
<p><img src="images/cdmp-image136.png" alt="Diagram that shows perturbation directions of the solution." /></p>
<p><strong>Figure 6</strong> : Perturbation direction of the solution depends on which octant it is in.</p>
<p>In other words, if r &gt; 0.5, the value on the R channel is decreased, otherwise the value is increased. There is similar logic for the G and B channels. The precise definitions are:</p>
<p>PERTURBATION = 0.5/(N+1)</p>
<p>Dir(r) = -1 if r &gt; 0.5; +1 otherwise. Similarly for Dir(g) and Dir(b)</p>
<p>The jth a posteriori seed, s ????, is (r + Dir(r) *j * PERTURBATION, g + Dir(g) * j * PERTURBATION, b + Dir(b) * j * PERTURBATION)</p>
<p>Try the first s ???? and if it gives a new solution within error tolerance, you can stop. Otherwise, try the second s ???? and so on until the Nth s ????.</p>
<p>The schematics of the whole algorithm is shown in Figure 7.</p>
<p><img src="images/cdmp-image138.png" alt="Diagram that shows the flow for inverting the device model." /></p>
<p><strong>Figure 7</strong> : Schematics of inverting the device model</p>
<h3>RGB Virtual Device Model Baseline</h3>
<p>This device model(DM) is a simple matrix/tone reproduction algorithm. The matrix is derived from the white point and primaries using standard color science algorithms. The tone reproduction curve is derived from the measurement parameters according to the ICC descriptions of CurveType and ParametricType (or inverted as required). Details of the internal algorithms will be provided after additional validation of high dynamic range issues.</p>
<p>The RGB virtual device model is an idealized matrix/tone reproduction curve RGB similar to the ICC three-component matrix-based profile design. The &quot;virtual measurement&quot; parameters of the DM include a white point value (absolute CIEXYZ), RGB primary values (absolute CIEXYZ), and a tone reproduction curve that is based on the ICC ParametricCurveType and CurveType in XML formatting consistent with the DMP schemas.</p>
<p>ICC parametricCurveType function type encoding and corresponding support in IRGBVirtualDeviceModelBase are shown in the following table.</p>
<table>
<thead>
<tr>
<th>Function type</th>
<th>Parameters</th>
<th>Type</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="images/cdmp-image154.png" alt="Shows the 'GammaType' function." /><!-- raw HTML omitted --></td>
<td>g<!-- raw HTML omitted --></td>
<td>GammaType<!-- raw HTML omitted --></td>
<td>Common implementation<!-- raw HTML omitted --></td>
</tr>
<tr>
<td><img src="images/cdmp-image156.png" alt="Shows the 'GammaOffsetGainType' function." /><!-- raw HTML omitted --></td>
<td>ga b<!-- raw HTML omitted --></td>
<td>GammaOffsetGainType<!-- raw HTML omitted --></td>
<td>CIE 122-1966<!-- raw HTML omitted --></td>
</tr>
<tr>
<td><img src="images/cdmp-image158.png" alt="Shows the 'GammaOffsetGainOffsetType' function." /><!-- raw HTML omitted --></td>
<td>ga b c<!-- raw HTML omitted --></td>
<td>GammaOffsetGainOffsetType<!-- raw HTML omitted --></td>
<td>IEC 61966-3<!-- raw HTML omitted --></td>
</tr>
<tr>
<td><img src="images/cdmp-image160.png" alt="Shows the 'GammaOffsetGainGainType' function." /><!-- raw HTML omitted --></td>
<td>ga b c d<!-- raw HTML omitted --></td>
<td>GammaOffsetGainGainType<!-- raw HTML omitted --></td>
<td>IEC 61966-2.1<!-- raw HTML omitted --> (sRGB)<!-- raw HTML omitted --></td>
</tr>
<tr>
<td><img src="images/cdmp-image162.png" alt="Shows a function for 'g a b c d e f' parameters." /><!-- raw HTML omitted --></td>
<td>ga b c d e f<!-- raw HTML omitted --></td>
<td>N/A<!-- raw HTML omitted --></td>
<td>Not supported in WCS<!-- raw HTML omitted --></td>
</tr>
</tbody>
</table>
<p>The tone curve for RGB virtual devices is applied in DeviceToColorimetric between the input data, pDeviceColors, and the matrix multiply. For ColorimetricToDevice, a method must be used to invert the tone curve. In the baseline implementation, this is done by direct interpolation in the same tone curve used for DeviceToColorimetric.</p>
<p>The curves should be specified in the profiles as pairs of numbers in float space. The first number represents values in pDeviceColors. The second number represents the output of the tone curve. All values in the tone curve must be between minColorantUsed and maxColorantUsed. Tone curves must contain at least two entries: one for minColorantUsed and one for maxColorantUsed. The maximum number of entries in the ToneCurve is 2048. In general, the more entries in the table, the more accurately you can model curvature. A piecewise linear interpolation is performed between the entries.</p>
<p>You might consider alternative interpolation methods. If you know something about the underlying behavior of the device, you can use fewer samples and model more accurately with a higher order curve. But if you use the wrong curve type, you will be very inaccurate. Without more information, you cannot guess the curve type. So, use linear interpolation and provide many data points.</p>
<h3>CMYK Printer Device Model Baseline</h3>
<p>A device characterization of a CMYK printer consists of constructing an empirical model of the device that predicts the printed color for any given CMYK value. The characterization also includes the inversion of this model so that a prescription of the CMYK value to us for a given color to be printed can be given. This is typically defined in terms of CIEXYZ or CIELAB value.</p>
<p>Typically, an IT8.7/3 target containing CMYK patches is used. The patches consist of sampling of the CMYK space in a well-defined manner so that a rectangular grid (with non-uniform spacing in C, M, Y and K) is formed. Each patch is then measured with a colorimeter or spectrophotometer. The measurements in CIEXYZ values then form a lookup table (LUT), from which an empirical model of the printer is built using Sakamoto's interpolation method. US Patent 4275413 (Sakamoto et al.), US Patent 4511989 (Sakamoto), Kang [1]. The two patents mentioned have expired.</p>
<p>Specific requirements for the CMYK measurement samples necessary for a device model profile to be accepted as valid by the CMYK printer baseline device model are as follows. (The sample set is most clearly described as a set of CMY sample cubes, each associated with a specific K level.)</p>
<ul>
<li>
<p>At minimum, valid CMY cubes must be provided for the K = 0 and K = 100 levels.</p>
</li>
<li>
<p>Intermediate K levels may be non-uniformly spaced.</p>
</li>
<li>
<p>Any intermediate K level without a valid CMY cube will be ignored.</p>
</li>
<li>
<p>The CMY cubes may use non-uniform sample intervals (grid spacing), but the same set of sample intervals must be used in all of the C,M, and Y dimensions in the CMY cube for a given K level.</p>
</li>
<li>
<p>Each K level CMY cube can use a different number and spacing of sample intervals.</p>
</li>
<li>
<p>All CMY cubes must contain the &quot;corners&quot; of the CMY cube, that is, CMY samples at [0,0,0], [0,0,100], [0,100,0], [100,0,0], [0,100,100], [100,0,100], [100,100, 0], [100,100,100].</p>
</li>
<li>
<p>Any intermediate CMY grid levels must be fully sampled in each channel. In other words, a sample must exist at each 3-D grid intersection within the CMY cube.</p>
</li>
<li>
<p>For the K = 0 and K = 100 CMY cubes, 2x2x2 &quot;corners-only&quot; cubes are the minimum accepted as valid.</p>
<p>[NOTE: for K=0 and K=100 levels, a 3x3x3 CMY cube will be processed as a 2x2x2 &quot;corners-only&quot; cube; the intermediate sample level is ignored. 4x4x4 and larger cubes will have all on-grid samples used.]</p>
</li>
<li>
<p>For intermediate K levels, 4x4x4 CMY cubes are the minimum accepted as valid.</p>
</li>
</ul>
<p>A high-quality profile will use finer sampling grids than the minimum required for validity, usually 9x9x9x9 or higher. The samples from the IT8.7/3, IT8.7/4, and ECI targets produce valid device model profiles (DMPs)for the CMYK printer baseline device model. While this device model is able to ignore the extraneous (off-grid) samples in these targets, it is not guaranteed to be able to do so for other targets, and so, it is recommended that extraneous samples be removed from measurement sets going into profiles for this device model.</p>
<p>The inversion of the printer model presents more difficulties. Given an input color in CIECAM, there is a question of whether this color is within the printer gamut. There is also the issue regarding the arrangement of points in the color appearance space. While we can arrange the CMYK values to fall on a rectangular grid, as is done in the IT8.7/3 target, the same cannot be said of the resulting printed colors as they are situated in the color appearance space. In general, they are scattered in the color appearance space with no particular pattern.</p>
<p>There are generally two approaches to the inversion problem of scattered points. One approach is to use a geometric subdivision of the printer gamut using elementary 3-dimensional solids, such as tetrahedra. A subdivision of the printer gamut in the color appearance space can be induced from the corresponding subdivision of the CMY(K) space, see Hung[93], Kang[97].This approach has the advantage of computational simplicity. In the case of a tetrahedron, only four points are used in an interpolation. On the other hand, the result depends heavily on a few points, which means that a measurement error will have a significant effect on the result. The interpolant also tends to be not as smooth. The second approach does not assume any subdivision, and is based on the technique of scattered data interpolation. A classical example is the technique of Shepard interpolation, or inverse weighted method (See Shepard [68]). Here, several points surrounding the input point are chosen in some manner, each assigned a weight, usually inversely proportional to the distance, and the interpolant is taken as the weighted average of the neighboring points. In this approach, the choice of neighboring points is paramount to performance. While too few points can render the interpolant inaccurate and non-smooth, too many points impose a high computational cost, as the weights are typically non-linear functions and costly to compute.</p>
<p>The two approaches described above both have problems. The subdivision approach depends critically on the data being reasonably void of noise, and generally the interpolant is not very smooth. The scattered data interpolation is more tolerant to data noise, and generally gives a smoother interpolant, but it is computationally more expensive.</p>
<p>The new CTE takes an alternative approach. The CMYK device is treated as a collection of several CMY devices, each of which has a specific value of black (K). Using a selection algorithm that takes as parameters lightness and chroma, a level of black is chosen. The CMY values are obtained by inversion of the corresponding CMY to Luv table using the Newton methods employed elsewhere by the RGB printer algorithm.</p>
<p>Use the following steps.</p>
<ol>
<li>Print the characterization target, which is either the IT8.7/3 target, or a target containing sampling of the CMYK space at regularly or irregularly spaced intervals.</li>
<li>Measure the target using a spectrophotometer, and convert the measurements to CIELUV space.</li>
<li>Construct the forward map from CMYK to Luv.</li>
<li>Use the forward map to construct a set of CMY to Luv maps for a range of K values.</li>
<li>For any input Luv value, the corresponding CMYK value is obtained by selecting one of the maps constructed in step 4 above and inverting using Newton's method to obtain a CMY colorant set to accompany the K value selected.</li>
</ol>
<p>Steps 1 and 2, which are standard procedures, are performed by a profiling program that is not part of the new CTE. The IT8.7/3 target contains a reasonably detailed sampling of all the CMYK values at various levels of C, M, Y, and K. Alternatively, a custom target with uniform sampling of the C, M, Y, and K channels can be used. After the target is printed, a spectrophotometer or colorimeter can be used to measure the XYZ value of each patch, and the XYZ value can be converted to the Luv value using the CIELUV model.</p>
<p>Step 3, construction of the forward map from CMYK to Luv, can be achieved by applying any known interpolation technique, such as tetrahedral or multilinear method, on the rectangular grid in CMYK space. In the new CTE, a 4-dimensional tetrahedral interpolation is used. Because the CMY sampling grids are generally different on each level of K, however, we use a technique of super-sampling, as detailed below. For a given CMYK point, the sandwiching K levels are first determined based on the K value. Then introduce a &quot;super-grid&quot; on each K level that is a union of the CMY grids on each of the two K levels. On each K level, the Luv value of any newly introduced grid point is obtained by a 3-dimensional tetrahedral interpolation within that K level. Finally, a 4-dimensional tetrahedral interpolation for the specific CMYK point is performed on this new grid.</p>
<p><img src="images/cdmp-image163.png" alt="Diagram that shows supersampling." /></p>
<p><strong>Figure 8</strong> : Supersampling</p>
<p>Step 4 constructs a set of CMY-to-Luv lookup tables (LUTs). The forward map constructed in Step 3 is called repeatedly to resample the CMYK space. The CMYK color space is sampled using an even spacing of K and a different, but still evenly spaced, sampling of CMY.</p>
<p>Step 5 is a procedure to obtain the CMYK value using the LUTs constructed in Step 4 for any input Luv point. The appropriate value of K is chosen by analyzing the lightness as well as the degree of color in the Luv requested. After the table is selected, the CMY values are obtained from the table by using Newton's method (as documented under the RGB printer device model earlier).</p>
<p>CIELUV space is used in the printer model instead of CIEJab because the device model should be based solely on colorimetric data available in the DMP. The DMP contains colorimetric data for each measured patch, including the media white point, so it is possible to convert CIEXYZ data into CIELUV data. However, it is not possible to convert to CIECAM02 JCh or Jab, because there is no access to the viewing condition information in the DMP.</p>
<h3>RGB Projector Device Model Baseline</h3>
<p>Note: Many RGB projectors have more than one operating mode. In one mode, which is often the default and might be called something like &quot;presentation,&quot; the color response of the projector is optimized for maximum brightness. However, in this mode, the projector loses the ability to reproduce light, slightly chromatic colors such as pale yellows and some flesh tones. In another mode, often called &quot;film,&quot; &quot;video,&quot; or &quot;sRGB,&quot; the projector is optimized for reproduction of realistic images and natural scenes. In this mode, maximum brightness is traded off to improve the overall quality of the color reproduction. To obtain satisfactory color reproduction with RGB projectors, it is necessary to place the projector in a mode where a smooth gamut of colors can be reproduced.</p>
<p><img src="images/cdmp-image167.png" alt="Diagram that shows a D L P device model." /></p>
<p><strong>Figure 9</strong> : DLP device model</p>
<p>An incoming RGB value passes through two computational pathways. The first is the matrix model, which results in an XYZ value. This is immediately followed by the conversion from XYZ to Luv. The second is the non-uniform LUT interpolation using tetrahedral interpolation. The output of the interpolation is already in Luv space by construction. The two outputs are added to obtain the predicted Luv value. This is finally converted to XYZ, which is the expected output of the colorimetric model for the DLP device.</p>
<p>Since projectors are display devices, they also support the inversion of the model, that is, the transform from XYZ to RGB. Because the device model transforms RGB space to XYZ space, which are both three dimensional, inversion is equivalent to solving three nonlinear equations in three unknowns. This can done by standard equation solving techniques, such as Newton-Raphson. It is preferable, however, to first convert XYZ to Luv, and then invert the Luv To RGB transform, because Luv space is more perceptually linear than XYZ space.</p>
<h3>ICC Device Model Baseline</h3>
<p>The CITE ICC workflow interoperability is enabled by creating a special ICC device baseline device model profile that stores the profile object and creates a ICC transform using a no-op XYZ profile. This transform is then used to translate between device and CIEXYZ colors.</p>
<p><img src="images/cdmp-image168.png" alt="Diagram that shows the C I T E I C C Workflow Interoperability." /></p>
<p><strong>Figure 10</strong> : CITE ICC Workflow Interoperability</p>
<h2>Related topics</h2>
<!-- raw HTML omitted -->
<p><a href="basic-color-management-concepts.html">Basic color management concepts</a></p>
<!-- raw HTML omitted -->
<p><a href="windows-color-system-schemas-and-algorithms.html">Windows Color System Schemas and Algorithms</a></p>
<!-- raw HTML omitted -->
</body>
