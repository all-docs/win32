<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Taking Advantage of High-Definition Mouse Movement</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<h2>title: Taking Advantage of High-Definition Mouse Movement
description: This article focuses on the best way to optimize the performance of high-definition mouse input in a game like a first-person shooter.
ms.assetid: 0138a248-e8e0-a392-564e-7a9229b94b56
ms.topic: article
ms.date: 05/31/2018</h2>
<h1>Taking Advantage of High-Definition Mouse Movement</h1>
<p>A standard computer mouse returns data at 400 dots per inch (DPI), whereas a high-definition mouse generates data at 800 DPI or greater. This makes input from a high-definition mouse much more precise than that from a standard mouse. However, high-definition data cannot be obtained through the standard WM_MOUSEMOVE messages. In general, games will benefit from high-definition mouse devices but games that obtain mouse data using just WM_MOUSEMOVE won't be able to access the full, unfiltered resolution of the mouse.</p>
<p>A number of companies are manufacturing high-definition mouse devices, such as Microsoft and Logitech. With the increasing popularity of high-resolution mouse devices, it is important that developers understand how to use the information generated by these devices optimally. This article focuses on the best way to optimize the performance of high-definition mouse input in a game like a first-person shooter.</p>
<h2>Retrieving Mouse Movement Data</h2>
<p>Here are the three primary methods to retrieve mouse data:</p>
<ul>
<li><a href="/windows">WM_MOUSEMOVE</a></li>
<li><a href="/windows">WM_INPUT</a></li>
<li><a href="#directinput">DirectInput</a></li>
</ul>
<p>There are advantages and disadvantages to each method, depending on how the data will be used.</p>
<h3>WM_MOUSEMOVE</h3>
<p>The simplest method of reading mouse movement data is through WM_MOUSEMOVE messages. The following is an example of how to read mouse movement data from the WM_MOUSEMOVE message:</p>
<pre lang="cpp"><code>case WM_MOUSEMOVE:
{
    int xPosAbsolute = GET_X_PARAM(lParam); 
    int yPosAbsolute = GET_Y_PARAM(lParam);
    // ...
    break;
}
</code></pre>
<p>The primary disadvantage to data from WM_MOUSEMOVE is that it is limited to the screen resolution. This means that if you move the mouse slightly â€” but not enough to cause the pointer to move to the next pixel â€” then no WM_MOUSEMOVE message is generated. So, using this method to read mouse movement negates the benefits of high-definition input.</p>
<p>The advantage to WM_MOUSEMOVE, however, is that Windows applies pointer acceleration (also known as ballistics) to the raw mouse data, which makes the mouse pointer behave as customers expect. This makes WM_MOUSEMOVE the preferred option for pointer control (over WM_INPUT or DirectInput), since it results in more natural behavior for users. While WM_MOUSEMOVE is ideal for moving mouse pointers, it is not so good for moving a first-person camera, since the high-definition precision will be lost.</p>
<p>For more info about WM_MOUSEMOVE, see <a href="/windows/desktop/inputdev/wm-mousemove"><strong>WM_MOUSEMOVE</strong></a>.</p>
<h3>WM_INPUT</h3>
<p>The second method of obtaining mouse data is to read WM_INPUT messages. Processing WM_INPUT messages is more complicated than processing WM_MOUSEMOVE messages, but WM_INPUT messages are read directly from the Human Interface Device (HID) stack and reflect high-definition results.</p>
<p>To read mouse movement data from the WM_INPUT message, the device must first be registered; the following code provides an example of this:</p>
<pre lang="cpp"><code>// you can #include &lt;hidusage.h&gt; for these defines
#ifndef HID_USAGE_PAGE_GENERIC
#define HID_USAGE_PAGE_GENERIC         ((USHORT) 0x01)
#endif
#ifndef HID_USAGE_GENERIC_MOUSE
#define HID_USAGE_GENERIC_MOUSE        ((USHORT) 0x02)
#endif

RAWINPUTDEVICE Rid[1];
Rid[0].usUsagePage = HID_USAGE_PAGE_GENERIC; 
Rid[0].usUsage = HID_USAGE_GENERIC_MOUSE; 
Rid[0].dwFlags = RIDEV_INPUTSINK;   
Rid[0].hwndTarget = hWnd;
RegisterRawInputDevices(Rid, 1, sizeof(Rid[0]));
</code></pre>
<p>The following code handles WM_INPUT messages in the application's WinProc handler:</p>
<pre lang="cpp"><code>case WM_INPUT: 
{
    UINT dwSize = sizeof(RAWINPUT);
    static BYTE lpb[sizeof(RAWINPUT)];

    GetRawInputData((HRAWINPUT)lParam, RID_INPUT, lpb, &amp;dwSize, sizeof(RAWINPUTHEADER));

    RAWINPUT* raw = (RAWINPUT*)lpb;

    if (raw-&gt;header.dwType == RIM_TYPEMOUSE) 
    {
        int xPosRelative = raw-&gt;data.mouse.lLastX;
        int yPosRelative = raw-&gt;data.mouse.lLastY;
    } 
    break;
}
</code></pre>
<p>The advantage to using WM_INPUT is that your game receives raw data from the mouse at the lowest level possible.</p>
<p>The disadvantage is that WM_INPUT has no ballistics applied to its data, so if you want to drive a cursor with this data, extra effort will be required to make the cursor behave like it does in Windows. For more information about applying pointer ballistics, see <a href="https://web.archive.org/web/20110623221617/http://msdn.microsoft.com/en-us/windows/hardware/gg463319.aspx">Pointer ballistics for Windows XP</a>.</p>
<p>For more info about WM_INPUT, see <a href="/windows/desktop/inputdev/about-raw-input">About raw input</a>.</p>
<h3>DirectInput</h3>
<p><a href="/windows-hardware/drivers/hid/directinput">DirectInput</a> is a set of API calls that abstracts input devices on the system. Internally, DirectInput creates a second thread to read WM_INPUT data, and using the DirectInput APIs will add more overhead than simply reading WM_INPUT directly. DirectInput is only useful for reading data from DirectInput joysticks; however, if you only need to support controllers for Windows, use <a href="/windows/desktop/xinput/xinput-game-controller-apis-portal">XInput</a> instead. Overall, using DirectInput offers no advantages when reading data from mouse or keyboard devices, and the use of DirectInput in these scenarios is discouraged.</p>
<p>Compare the complexity of using <a href="/windows-hardware/drivers/hid/directinput">DirectInput</a>, shown in the following code, to the methods previously described. The following set of calls are needed to create a DirectInput mouse:</p>
<pre lang="cpp"><code>LPDIRECTINPUT8 pDI;
LPDIRECTINPUTDEVICE8 pMouse;

hr = DirectInput8Create(GetModuleHandle(NULL), DIRECTINPUT_VERSION, IID_IDirectInput8, (VOID**)&amp;pDI, NULL);
if(FAILED(hr))
    return hr;

hr = pDI-&gt;CreateDevice(GUID_SysMouse, &amp;pMouse, NULL);
if(FAILED(hr))
    return hr;

hr = pMouse-&gt;SetDataFormat(&amp;c_dfDIMouse2);
if(FAILED(hr))
    return hr;

hr = pMouse-&gt;SetCooperativeLevel(hWnd, DISCL_NONEXCLUSIVE | DISCL_FOREGROUND);
if(FAILED(hr))
    return hr;

if(!bImmediate)
{
    DIPROPDWORD dipdw;
    dipdw.diph.dwSize       = sizeof(DIPROPDWORD);
    dipdw.diph.dwHeaderSize = sizeof(DIPROPHEADER);
    dipdw.diph.dwObj        = 0;
    dipdw.diph.dwHow        = DIPH_DEVICE;
    dipdw.dwData            = 16; // Arbitrary buffer size

    if(FAILED(hr = pMouse-&gt;SetProperty(DIPROP_BUFFERSIZE, &amp;dipdw.diph)))
        return hr;
}

pMouse-&gt;Acquire();
</code></pre>
<p>And then the DirectInput mouse device can be read each frame:</p>
<pre lang="cpp"><code>DIMOUSESTATE2 dims2; 
ZeroMemory(&amp;dims2, sizeof(dims2));

hr = pMouse-&gt;GetDeviceState(sizeof(DIMOUSESTATE2), &amp;dims2);
if(FAILED(hr)) 
{
    hr = pMouse-&gt;Acquire();
    while(hr == DIERR_INPUTLOST) 
        hr = pMouse-&gt;Acquire();

    return S_OK; 
}

int xPosRelative = dims2.lX;
int yPosRelative = dims2.lY;
</code></pre>
<h2>Summary</h2>
<p>Overall, the best method to receive high-definition mouse movement data is WM_INPUT. If your users are just moving a mouse pointer, then consider using WM_MOUSEMOVE to avoid needing to perform pointer ballistics. Both of these window messages will work well even if the mouse isn't a high-definition mouse. By supporting high definition, Windows games can offer more precise control to users.</p>
</body>
