<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>SYNTAX Clause</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<h2>description: Contains a SYNTAX clause that defines the data and type for the MIB object.
ms.assetid: 24c483c8-db50-492f-9c2e-72620395331a
ms.tgt_platform: multiple
title: SYNTAX Clause
ms.topic: article
ms.date: 05/31/2018</h2>
<h1>SYNTAX Clause</h1>
<p>The <a href="object-type-macro.html">OBJECT-TYPE</a> macro contains a SYNTAX clause that defines the data and type for the MIB object. While the SNMP Provider observes general rules for mapping SYNTAX clauses, the provider also follows rules specific to several data types.</p>
<blockquote>
<p>[!Note]<br />
For more information about installing the provider, see <a href="setting-up-the-wmi-snmp-environment.html">Setting up the WMI SNMP Environment</a>.</p>
</blockquote>
<p>The following mapping rules apply to all of the data types described in the table below:</p>
<ul>
<li>The textual representation of the SYNTAX clause maps to the CIM property qualifier <strong>textual_convention</strong>.</li>
<li>The named type definition in the SYNTAX clause maps to the CIM property qualifier <strong>object_syntax</strong>. This mapping differs depending on the data type. For more information, see the mapping descriptions.</li>
<li>The SNMP type used when encoding SNMPv1 and SNMPv2C protocol frames maps to the CIM property qualifier <strong>encoding</strong>.</li>
<li>The CIM property qualifier <strong>cimtype</strong> contains the textual representation that formats the underlying CIM protocol value.</li>
</ul>
<p>The following table lists data types that have specific rules that govern the provider mapping behavior.</p>
<table>
<thead>
<tr>
<th>SNMP data type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#primitive-type">Primitive type</a></td>
<td>One of the basic data types defined in the Structure of Management Information (SMI) documents RFC 1213 and RFC 1903.</td>
</tr>
<tr>
<td><a href="textual-convention-macro.html">Textual convention</a></td>
<td>Type definition generated through the explicit use of the SNMPv2C <strong>TEXTUAL-CONVENTION</strong> macro or generated through the use of a named type. A textual convention assigns a name and, in some cases, a range of values to an existing data type.</td>
</tr>
<tr>
<td><a href="#named-type">Named type</a></td>
<td>Named reference to a primitive type, textual convention, or constrained type.</td>
</tr>
<tr>
<td><a href="#constrained-type">Constrained type</a></td>
<td>Primitive type, named type, or textual convention that has been constrained by some subtyping mechanism defined in the SMI documents RFC 1213 and RFC 1903.</td>
</tr>
</tbody>
</table>
<h2>Primitive Type</h2>
<p>The primitive type is one of the basic data types defined in the Structure of Management Information (SMI) documents RFC 1213 and RFC 1903. SNMP primitive types map to CIM-defined types. The following table lists the mapping that occurs when the SYNTAX clause explicitly refers to a primitive type for SNMPv1. The <strong>textual_convention</strong>, <strong>encoding</strong>, and <strong>object_syntax</strong> qualifiers are always the same as the MIB type and the default value is always <strong>NULL</strong>.</p>
<table>
<thead>
<tr>
<th>MIB type</th>
<th>CIM variant type</th>
<th>cimtype value</th>
</tr>
</thead>
<tbody>
<tr>
<td>INTEGER</td>
<td>VT_I4</td>
<td><strong>sint32</strong></td>
</tr>
<tr>
<td>OCTETSTRING</td>
<td>VT_BSTR</td>
<td><strong>string</strong></td>
</tr>
<tr>
<td>OBJECTIDENTIFIER</td>
<td>VT_BSTR</td>
<td><strong>string</strong></td>
</tr>
<tr>
<td>NULL</td>
<td>VT_NULL</td>
<td>Not supported</td>
</tr>
<tr>
<td>IpAddress</td>
<td>VT_BSTR</td>
<td><strong>string</strong></td>
</tr>
<tr>
<td>Counter</td>
<td>VT_I4</td>
<td><strong>uint32</strong></td>
</tr>
<tr>
<td>Gauge</td>
<td>VT_I4</td>
<td><strong>uint32</strong></td>
</tr>
<tr>
<td>TimeTicks</td>
<td>VT_I4</td>
<td><strong>uint32</strong></td>
</tr>
<tr>
<td>Opaque</td>
<td>VT_BSTR</td>
<td><strong>string</strong></td>
</tr>
<tr>
<td>NetworkAddress</td>
<td>VT_BSTR</td>
<td><strong>string</strong></td>
</tr>
</tbody>
</table>
<p>The provider ignores the OBJECT-TYPE macro when the SYNTAX clause refers to <strong>NULL</strong>, either explicitly or through a named type assignment. The following table lists the mapping that occurs when the SYNTAX clause explicitly refers to a primitive type for SNMPv2. The <strong>textual_convention</strong>, <strong>encoding</strong>, and <strong>object_syntax</strong> qualifiers are always the same as the MIB type and the default value is always <strong>NULL</strong>.</p>
<table>
<thead>
<tr>
<th>MIB type</th>
<th>CIM variant type</th>
<th>cimtype value</th>
</tr>
</thead>
<tbody>
<tr>
<td>INTEGER</td>
<td>VT_I4</td>
<td><strong>sint32</strong></td>
</tr>
<tr>
<td>OCTET STRING</td>
<td>VT_BSTR</td>
<td><strong>string</strong></td>
</tr>
<tr>
<td>OBJECT IDENTIFIER</td>
<td>VT_BSTR</td>
<td><strong>string</strong></td>
</tr>
<tr>
<td>IpAddress</td>
<td>VT_BSTR</td>
<td><strong>string</strong></td>
</tr>
<tr>
<td>Counter32</td>
<td>VT_I4</td>
<td><strong>uint32</strong></td>
</tr>
<tr>
<td>Gauge32</td>
<td>VT_I4</td>
<td><strong>uint32</strong></td>
</tr>
<tr>
<td>Unsigned32</td>
<td>VT_I4</td>
<td><strong>uint32</strong></td>
</tr>
<tr>
<td>Integer32</td>
<td>VT_I4</td>
<td><strong>sint32</strong></td>
</tr>
<tr>
<td>Counter64</td>
<td>VT_BSTR</td>
<td><strong>uint64</strong></td>
</tr>
<tr>
<td>TimeTicks</td>
<td>VT_I4</td>
<td><strong>uint32</strong></td>
</tr>
<tr>
<td>Opaque</td>
<td>VT_BSTR</td>
<td><strong>string</strong></td>
</tr>
</tbody>
</table>
<h2>Named Type</h2>
<p>SNMP named types map to CIM-defined types. When the SYNTAX clause refers to a <a href="#primitive-type">primitive type</a>, <a href="textual-convention-macro.html">textual convention</a>, or <a href="#constrained-type">constrained type</a> through a type assignment derivation, use the those types to determine which mapping procedures apply.</p>
<ul>
<li>
<p>If, through derivation of the type assignment rules, you encounter a constrained type definition:</p>
<ul>
<li>And if, through further derivation, you encounter one of the textual conventions listed in <a href="textual-convention-macro.html">TEXTUAL-CONVENTION Macro</a>, then apply the mapping rules for constrained types and textual conventions.</li>
<li>Otherwise, if you encounter one of the primitive types listed in either primitive type table, apply the mapping rules for primitive types and constrained types.</li>
</ul>
</li>
<li>
<p>If you encounter one of the textual conventions listed in <a href="textual-convention-macro.html">TEXTUAL_CONVENTION Macro</a>, apply the mapping rules for textual conventions.</p>
</li>
<li>
<p>If you encounter one of the primitive types listed in either primitive type table, apply the mapping rules for primitive types.</p>
</li>
</ul>
<blockquote>
<p>[!Note]<br />
Classes containing property types that do not conform to the mapping described above are not valid. In this case, the provider returns an error if and when the provider requests the retrieval of a class definition while executing an instance retrieval function.</p>
</blockquote>
<h2>Constrained Type</h2>
<p>A constrained type is a primitive type, named type, or textual convention that has been constrained by some subtyping mechanism defined in the SMI documents RFC 1213 and RFC 1903. When subtyping occurs, additional CIM qualifiers are required to specify the subtype values. The named-type definition in the SYNTAX clause maps verbatim to the CIM property qualifier <strong>object_syntax</strong> up to, but not including the constraints of the subtype.</p>
<p>Subtypes may follow any of the following formats:</p>
<ul>
<li>
<p>Enumerated INTEGER</p>
<p>The CIM property qualifier <strong>enumeration</strong> specifies the enumerated values. This qualifier is represented as a string containing a comma-separated list of signed 32-bit integer values. The following table lists the mapping types. The default value is always <strong>NULL</strong>.</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Constrained MIB type</th>
<th>CIM variant type</th>
<th>CIM qualifiers</th>
</tr>
</thead>
<tbody>
<tr>
<td>Enumerated INTEGER</td>
<td>VT_BSTR</td>
<td><strong>textual_convention</strong>: enumeratedinteger<!-- raw HTML omitted --> <strong>encoding</strong>: INTEGER<!-- raw HTML omitted --> <strong>cimtype</strong>: string<!-- raw HTML omitted --></td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>BITS</p>
<p>The CIM property qualifier <strong>bits</strong> specifies the enumerated values. This qualifier is represented as a string containing a comma-separated list of signed 32-bit integer values. The following table lists the mapping types. The default value is always <strong>NULL</strong>.</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Constrained MIB type</th>
<th>CIM variant type</th>
<th>CIM qualifiers</th>
</tr>
</thead>
<tbody>
<tr>
<td>BITS</td>
<td>VT_ARRAY | VT_BSTR</td>
<td><strong>textual_convention</strong>: bits<!-- raw HTML omitted --> <strong>encoding</strong>: OCTETSTRING<!-- raw HTML omitted --> <strong>cimtype</strong>: string<!-- raw HTML omitted --></td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>Variable-length</p>
<p>When the SYNTAX clause refers to a primitive type, named type, or textual convention that is subtyped as a variable-length OCTET STRING or Opaque, the CIM property qualifier <strong>variable_length</strong> specifies the minimum, maximum, and fixed-length values associated with the type definition. This qualifier is implemented as a string in the following format where the variable-length values are represented as unsigned 32-bit integers.</p>
<pre lang="syntax"><code>(((0.9) .. (0.9)) | (0.9))(, (((0.9) .. (0.9)) | (0.9)))*
</code></pre>
</li>
<li>
<p>Fixed-length</p>
<p>When the SYNTAX clause refers to a primitive type, named type, or textual convention that is subtyped as a fixed-length OCTET STRING or Opaque, the CIM property qualifier <strong>fixed_length</strong> specifies the fixed-length value. This qualifier is represented as an unsigned 32-bit integer value.</p>
</li>
<li>
<p>Range</p>
<p>When the SYNTAX clause refers to a primitive type, named type, or textual convention that is subtyped as a ranged or fixed-value INTEGER or Gauge, the CIM property qualifier <strong>variable_value</strong> specifies the ranged and fixed values associated with the type definition. This qualifier is implemented as a string in the following format where the range and fixed-length values are represented as unsigned 32-bit integers.</p>
<pre lang="syntax"><code>(((0.9)..(0.9))|(0.9))(,(((0.9)..(0.9))|(0.9)))*
</code></pre>
</li>
</ul>
<h2>Example Code</h2>
<p>The following example describes an enumerated INTEGER subtype.</p>
<pre lang="syntax"><code>Status := INTEGER {
up(1),
down(2),
testing(3)
}
</code></pre>
<p>This example maps to:</p>
<pre lang="syntax"><code>enumeration(&quot;up(1),down(2),testing(3)&quot;)
</code></pre>
<p>The following code example describes a BITS subtype.</p>
<pre lang="syntax"><code>Status := BITS {
up(1),
down(2), 
testing(3)
}
</code></pre>
<p>The following code example maps to:</p>
<pre lang="syntax"><code>bits(&quot;up(1),down(2),testing(3)&quot;)
</code></pre>
<p>The following code example describes a variable-length subtype.</p>
<pre lang="syntax"><code>MySnmpOSIAddress ::=  TEXTUAL-CONVENTION

    DISPLAY-HINT    &quot;*1x:/1x:&quot;
    STATUS        current
    DESCRIPTION
            &quot;Represents an OSI transport-address:

            octets    contents         encoding
              1        length of NSAP   'n' as an unsigned-integer
                                        (either 0 or from 3 to 20)
              2..(n+1)  NSAP          concrete binary representation
              (n+2)..m  TSEL             string of (up to 64) octets
            &quot;
    SYNTAX         OCTET STRING (SIZE (1|4..85))
</code></pre>
<p>This example maps to:</p>
<pre lang="syntax"><code>display_hint(&quot;*1x:/1x:&quot;),
encoding(&quot;OCTETSTRING&quot;),
textual_convention(&quot;OCTETSTRING&quot;),
variable_length (&quot;1,4..85&quot;)
</code></pre>
<p>The following example describes a fixed-length subtype.</p>
<pre lang="syntax"><code>IPXADDRESS := OCTET STRING (SIZE (6))
</code></pre>
<p>This example maps to:</p>
<pre lang="syntax"><code>fixed_length(6)
</code></pre>
<p>The following example describes a range subtype.</p>
<pre lang="syntax"><code>Status := INTEGER (10..20|8)
</code></pre>
<p>This example maps to:</p>
<pre lang="syntax"><code>variable_value(&quot;10..20,8&quot;)
</code></pre>
</body>
