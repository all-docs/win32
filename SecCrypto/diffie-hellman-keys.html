<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Diffie-Hellman Keys</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<h2>description: Explains how to generate, exchange, import, and export Diffie-Hellman keys.
ms.assetid: 623a8c9e-3f6a-470b-be30-dec13342bb90
title: Diffie-Hellman Keys
ms.topic: article
ms.date: 05/31/2018</h2>
<h1>Diffie-Hellman Keys</h1>
<ul>
<li><a href="#generating-diffie-hellman-keys">Generating Diffie-Hellman Keys</a></li>
<li><a href="#exchanging-diffie-hellman-keys">Exchanging Diffie-Hellman Keys</a></li>
<li><a href="#exporting-a-diffie-hellman-private-key">Exporting a Diffie-Hellman Private Key</a></li>
<li><a href="#example-code">Example Code</a></li>
</ul>
<h2>Generating Diffie-Hellman Keys</h2>
<p>To generate a Diffie-Hellman key, perform the following steps:</p>
<ol>
<li>
<p>Call the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptacquirecontexta"><strong>CryptAcquireContext</strong></a> function to get a handle to the Microsoft Diffie-Hellman Cryptographic Provider.</p>
</li>
<li>
<p>Generate the new key. There are two ways to accomplish thisâ€”by having CryptoAPI generate all new values for G, P, and X or by using existing values for G and P, and generating a new value for X.</p>
<p><strong>To generate the key by generating all new values</strong></p>
<ol>
<li>Call the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptgenkey"><strong>CryptGenKey</strong></a> function, passing either <strong>CALG_DH_SF</strong> (store and forward) or <strong>CALG_DH_EPHEM</strong> (ephemeral) in the <em>Algid</em> parameter. The key will be generated using new, random values for G and P, a newly calculated value for X, and its handle will be returned in the <em>phKey</em> parameter.</li>
<li>The new key is now ready for use. The values of G and P must be sent to the recipient along with the key (or sent by some other method) when doing a <a href="../secgloss/e-gly.html"><em>key exchange</em></a>.</li>
</ol>
<p><strong>To generate the key by using predefined values for G and P</strong></p>
<ol>
<li>Call <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptgenkey"><strong>CryptGenKey</strong></a> passing either <strong>CALG_DH_SF</strong> (store and forward) or <strong>CALG_DH_EPHEM</strong> (ephemeral) in the <em>Algid</em> parameter and <strong>CRYPT_PREGEN</strong> for the <em>dwFlags</em> parameter. A key handle will be generated and returned in the <em>phKey</em> parameter.</li>
<li>Initialize a <a href="/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)"><strong>CRYPT_DATA_BLOB</strong></a> structure with the <strong>pbData</strong> member set to the P value. The <a href="../secgloss/b-gly.html"><em>BLOB</em></a> contains no header information and the <strong>pbData</strong> member is in <a href="../secgloss/l-gly.html"><em>little-endian</em></a> format.</li>
<li>The value of P is set by calling the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptsetkeyparam"><strong>CryptSetKeyParam</strong></a> function, passing the key handle retrieved in step a in the <em>hKey</em> parameter, the <strong>KP_P</strong> flag in the <em>dwParam</em> parameter, and a pointer to the structure that contains the value of P in the <em>pbData</em> parameter.</li>
<li>Initialize a <a href="/previous-versions/windows/desktop/legacy/aa381414(v=vs.85)"><strong>CRYPT_DATA_BLOB</strong></a> structure with the <strong>pbData</strong> member set to the G value. The BLOB contains no header information and the <strong>pbData</strong> member is in little-endian format.</li>
<li>The value of G is set by calling the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptsetkeyparam"><strong>CryptSetKeyParam</strong></a> function, passing the key handle retrieved in step a in the <em>hKey</em> parameter, the <strong>KP_G</strong> flag in the <em>dwParam</em> parameter, and a pointer to the structure that contains the value of G in the <em>pbData</em> parameter.</li>
<li>The value of X is generated by calling the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptsetkeyparam"><strong>CryptSetKeyParam</strong></a> function, passing the key handle retrieved in step a in the <em>hKey</em> parameter, the <strong>KP_X</strong> flag in the <em>dwParam</em> parameter, and <strong>NULL</strong> in the <em>pbData</em> parameter.</li>
<li>If all the function calls succeeded, the Diffie-Hellman public key is ready for use.</li>
</ol>
</li>
<li>
<p>When the key is no longer needed, destroy it by passing the key handle to the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptdestroykey"><strong>CryptDestroyKey</strong></a> function.</p>
</li>
</ol>
<p>If <strong>CALG_DH_SF</strong> was specified in the previous procedures, the key values are persisted to storage with each call to <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptsetkeyparam"><strong>CryptSetKeyParam</strong></a>. The G and P values can then be retrieved by using the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptgetkeyparam"><strong>CryptGetKeyParam</strong></a> function. Some CSPs may have hard-coded G and P values. In this case a <strong>NTE_FIXEDPARAMETER</strong> error will be returned if <strong>CryptSetKeyParam</strong> is called with <strong>KP_G</strong> or <strong>KP_P</strong> specified in the <em>dwParam</em> parameter. If <strong>CryptDestroyKey</strong> is called, the handle to the key is destroyed, but the key values are retained in the CSP. However, if <strong>CALG_DH_EPHEM</strong> was specified, the handle to the key is destroyed, and all values are cleared from the CSP.</p>
<h2>Exchanging Diffie-Hellman Keys</h2>
<p>The purpose of the Diffie-Hellman algorithm is to make it possible for two or more parties to create and share an identical, secret session key by sharing information over a network that is not secure. The information that gets shared over the network is in the form of a couple of constant values and a Diffie-Hellman public key. The process used by two key-exchange parties is as follows:</p>
<ul>
<li>Both parties agree to the Diffie-Hellman parameters which are a prime number (P) and a generator number (G).</li>
<li>Party 1 sends its Diffie-Hellman public key to party 2.</li>
<li>Party 2 computes the secret session key by using the information contained in its private key and party 1's public key.</li>
<li>Party 2 sends its Diffie-Hellman public key to party 1.</li>
<li>Party 1 computes the secret session key by using the information contained in its private key and party 2's public key.</li>
<li>Both parties now have the same session key, which can be used for encrypting and decrypting data. The steps necessary for this are shown in the following procedure.</li>
</ul>
<p><strong>To prepare a Diffie-Hellman public key for transmission</strong></p>
<ol>
<li>Call the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptacquirecontexta"><strong>CryptAcquireContext</strong></a> function to get a handle to the Microsoft Diffie-Hellman Cryptographic Provider.</li>
<li>Create a Diffie-Hellman key by calling the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptgenkey"><strong>CryptGenKey</strong></a> function to create a new key, or by calling the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptgetuserkey"><strong>CryptGetUserKey</strong></a> function to retrieve an existing key.</li>
<li>Get the size needed to hold the Diffie-Hellman key BLOB by calling the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptexportkey"><strong>CryptExportKey</strong></a>, passing <strong>NULL</strong> for the <em>pbData</em> parameter. The required size will be returned in <em>pdwDataLen</em>.</li>
<li>Allocate memory for the key BLOB.</li>
<li>Create a Diffie-Hellman <a href="../secgloss/p-gly.html"><em>public key BLOB</em></a> by calling the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptexportkey"><strong>CryptExportKey</strong></a> function, passing <strong>PUBLICKEYBLOB</strong> in the <em>dwBlobType</em> parameter and the handle to the Diffie-Hellman key in the <em>hKey</em> parameter. This function call causes the calculation of the public key value, (G^X) mod P.</li>
<li>If all the preceding function calls were successful, the Diffie-Hellman public key BLOB is now ready to be encoded and transmitted.</li>
</ol>
<p><strong>To import a Diffie-Hellman public key and calculate the secret session key</strong></p>
<ol>
<li>Call the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptacquirecontexta"><strong>CryptAcquireContext</strong></a> function to get a handle to the Microsoft Diffie-Hellman Cryptographic Provider.</li>
<li>Create a Diffie-Hellman key by calling the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptgenkey"><strong>CryptGenKey</strong></a> function to create a new key, or by calling the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptgetuserkey"><strong>CryptGetUserKey</strong></a> function to retrieve an existing key.</li>
<li>To import the Diffie-Hellman public key into the CSP, call the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptimportkey"><strong>CryptImportKey</strong></a> function, passing a pointer to the public key BLOB in the <em>pbData</em> parameter, the length of the BLOB in the <em>dwDataLen</em> parameter, and the handle to the Diffie-Hellman key in the <em>hPubKey</em> parameter. This causes the calculation, (Y^X) mod P, to be performed, thus creating the shared, secret key and completing the <a href="../secgloss/e-gly.html"><em>key exchange</em></a>. This function call returns a handle to the new, secret, session key in the <em>hKey</em> parameter.</li>
<li>At this point, the imported Diffie-Hellman is of type <strong>CALG_AGREEDKEY_ANY</strong>. Before the key can be used, it must be converted into a session key type. This is accomplished by calling the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptsetkeyparam"><strong>CryptSetKeyParam</strong></a> function with <em>dwParam</em> set to <strong>KP_ALGID</strong> and with <em>pbData</em> set to a pointer to a <a href="alg-id.html"><strong>ALG_ID</strong></a> value that represents a session key, such as <strong>CALG_RC4</strong>. The key must be converted before using the shared key in the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptencrypt"><strong>CryptEncrypt</strong></a> or <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptdecrypt"><strong>CryptDecrypt</strong></a> function. Calls made to either of these functions prior to converting the key type will fail.</li>
<li>The secret session key is now ready to be used for encryption or decryption.</li>
<li>When the key is no longer needed, destroy the key handle by calling the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptdestroykey"><strong>CryptDestroyKey</strong></a> function.</li>
</ol>
<h2>Exporting a Diffie-Hellman Private Key</h2>
<p>To export a Diffie-Hellman private key, perform the following steps:</p>
<ol>
<li>Call the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptacquirecontexta"><strong>CryptAcquireContext</strong></a> function to get a handle to the Microsoft Diffie-Hellman Cryptographic Provider.</li>
<li>Create a Diffie-Hellman key by calling the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptgenkey"><strong>CryptGenKey</strong></a> function to create a new key, or by calling the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptgetuserkey"><strong>CryptGetUserKey</strong></a> function to retrieve an existing key.</li>
<li>Create a Diffie-Hellman <a href="../secgloss/p-gly.html"><em>private key BLOB</em></a> by calling the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptexportkey"><strong>CryptExportKey</strong></a> function, passing <strong>PRIVATEKEYBLOB</strong> in the <em>dwBlobType</em> parameter and the handle to the Diffie-Hellman key in the <em>hKey</em> parameter.</li>
<li>When the key handle is no longer needed, call the <a href="/windows/desktop/api/Wincrypt/nf-wincrypt-cryptdestroykey"><strong>CryptDestroyKey</strong></a> function to destroy the key handle.</li>
</ol>
<h2>Example Code</h2>
<p>The following example shows how to create, export, import, and use a Diffie-Hellman key to perform a key exchange.</p>
<pre lang="C++"><code>#include &lt;tchar.h&gt;
#include &lt;windows.h&gt;
#include &lt;wincrypt.h&gt;
#pragma comment(lib, &quot;crypt32.lib&quot;)

// The key size, in bits.
#define DHKEYSIZE 512

// Prime in little-endian format.
static const BYTE g_rgbPrime[] = 
{
    0x91, 0x02, 0xc8, 0x31, 0xee, 0x36, 0x07, 0xec, 
    0xc2, 0x24, 0x37, 0xf8, 0xfb, 0x3d, 0x69, 0x49, 
    0xac, 0x7a, 0xab, 0x32, 0xac, 0xad, 0xe9, 0xc2, 
    0xaf, 0x0e, 0x21, 0xb7, 0xc5, 0x2f, 0x76, 0xd0, 
    0xe5, 0x82, 0x78, 0x0d, 0x4f, 0x32, 0xb8, 0xcb,
    0xf7, 0x0c, 0x8d, 0xfb, 0x3a, 0xd8, 0xc0, 0xea, 
    0xcb, 0x69, 0x68, 0xb0, 0x9b, 0x75, 0x25, 0x3d,
    0xaa, 0x76, 0x22, 0x49, 0x94, 0xa4, 0xf2, 0x8d 
};

// Generator in little-endian format.
static BYTE g_rgbGenerator[] = 
{
    0x02, 0x88, 0xd7, 0xe6, 0x53, 0xaf, 0x72, 0xc5,
    0x8c, 0x08, 0x4b, 0x46, 0x6f, 0x9f, 0x2e, 0xc4,
    0x9c, 0x5c, 0x92, 0x21, 0x95, 0xb7, 0xe5, 0x58, 
    0xbf, 0xba, 0x24, 0xfa, 0xe5, 0x9d, 0xcb, 0x71, 
    0x2e, 0x2c, 0xce, 0x99, 0xf3, 0x10, 0xff, 0x3b,
    0xcb, 0xef, 0x6c, 0x95, 0x22, 0x55, 0x9d, 0x29,
    0x00, 0xb5, 0x4c, 0x5b, 0xa5, 0x63, 0x31, 0x41,
    0x13, 0x0a, 0xea, 0x39, 0x78, 0x02, 0x6d, 0x62
};

BYTE g_rgbData[] = {0x01, 0x02, 0x03, 0x04,    0x05, 0x06, 0x07, 0x08};

int _tmain(int argc, _TCHAR* argv[])
{
    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);
    
    BOOL fReturn;
    HCRYPTPROV hProvParty1 = NULL; 
    HCRYPTPROV hProvParty2 = NULL; 
    DATA_BLOB P;
    DATA_BLOB G;
    HCRYPTKEY hPrivateKey1 = NULL;
    HCRYPTKEY hPrivateKey2 = NULL;
    PBYTE pbKeyBlob1 = NULL;
    PBYTE pbKeyBlob2 = NULL;
    HCRYPTKEY hSessionKey1 = NULL;
    HCRYPTKEY hSessionKey2 = NULL;
    PBYTE pbData = NULL;

    /************************
    Construct data BLOBs for the prime and generator. The P and G 
    values, represented by the g_rgbPrime and g_rgbGenerator arrays 
    respectively, are shared values that have been agreed to by both 
    parties.
    ************************/
    P.cbData = DHKEYSIZE/8;
    P.pbData = (BYTE*)(g_rgbPrime);

    G.cbData = DHKEYSIZE/8;
    G.pbData = (BYTE*)(g_rgbGenerator);

    /************************
    Create the private Diffie-Hellman key for party 1. 
    ************************/
    // Acquire a provider handle for party 1.
    fReturn = CryptAcquireContext(
        &amp;hProvParty1, 
        NULL,
        MS_ENH_DSS_DH_PROV,
        PROV_DSS_DH, 
        CRYPT_VERIFYCONTEXT);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Create an ephemeral private key for party 1.
    fReturn = CryptGenKey(
        hProvParty1, 
        CALG_DH_EPHEM, 
        DHKEYSIZE &lt;&lt; 16 | CRYPT_EXPORTABLE | CRYPT_PREGEN,
        &amp;hPrivateKey1);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Set the prime for party 1's private key.
    fReturn = CryptSetKeyParam(
        hPrivateKey1,
        KP_P,
        (PBYTE)&amp;P,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Set the generator for party 1's private key.
    fReturn = CryptSetKeyParam(
        hPrivateKey1,
        KP_G,
        (PBYTE)&amp;G,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Generate the secret values for party 1's private key.
    fReturn = CryptSetKeyParam(
        hPrivateKey1,
        KP_X,
        NULL,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    /************************
    Create the private Diffie-Hellman key for party 2. 
    ************************/
    // Acquire a provider handle for party 2.
    fReturn = CryptAcquireContext(
        &amp;hProvParty2, 
        NULL,
        MS_ENH_DSS_DH_PROV,
        PROV_DSS_DH, 
        CRYPT_VERIFYCONTEXT);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Create an ephemeral private key for party 2.
    fReturn = CryptGenKey(
        hProvParty2, 
        CALG_DH_EPHEM, 
        DHKEYSIZE &lt;&lt; 16 | CRYPT_EXPORTABLE | CRYPT_PREGEN,
        &amp;hPrivateKey2);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Set the prime for party 2's private key.
    fReturn = CryptSetKeyParam(
        hPrivateKey2,
        KP_P,
        (PBYTE)&amp;P,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Set the generator for party 2's private key.
    fReturn = CryptSetKeyParam(
        hPrivateKey2,
        KP_G,
        (PBYTE)&amp;G,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Generate the secret values for party 2's private key.
    fReturn = CryptSetKeyParam(
        hPrivateKey2,
        KP_X,
        NULL,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    /************************
    Export Party 1's public key.
    ************************/
    // Public key value, (G^X) mod P is calculated.
    DWORD dwDataLen1;

    // Get the size for the key BLOB.
    fReturn = CryptExportKey(
        hPrivateKey1,
        NULL,
        PUBLICKEYBLOB,
        0,
        NULL,
        &amp;dwDataLen1);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Allocate the memory for the key BLOB.
    if(!(pbKeyBlob1 = (PBYTE)malloc(dwDataLen1)))
    { 
        goto ErrorExit;
    }

    // Get the key BLOB.
    fReturn = CryptExportKey(
        hPrivateKey1,
        0,
        PUBLICKEYBLOB,
        0,
        pbKeyBlob1,
        &amp;dwDataLen1);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    /************************
    Export Party 2's public key.
    ************************/
    // Public key value, (G^X) mod P is calculated.
    DWORD dwDataLen2;

    // Get the size for the key BLOB.
    fReturn = CryptExportKey(
        hPrivateKey2,
        NULL,
        PUBLICKEYBLOB,
        0,
        NULL,
        &amp;dwDataLen2);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Allocate the memory for the key BLOB.
    if(!(pbKeyBlob2 = (PBYTE)malloc(dwDataLen2)))
    { 
        goto ErrorExit;
    }

    // Get the key BLOB.
    fReturn = CryptExportKey(
        hPrivateKey2,
        0,
        PUBLICKEYBLOB,
        0,
        pbKeyBlob2,
        &amp;dwDataLen2);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    /************************
    Party 1 imports party 2's public key.
    The imported key will contain the new shared secret 
    key (Y^X) mod P. 
    ************************/
    fReturn = CryptImportKey(
        hProvParty1,
        pbKeyBlob2,
        dwDataLen2,
        hPrivateKey1,
        0,
        &amp;hSessionKey2);
    if(!fReturn)
    {
        goto ErrorExit;
    }
    
    /************************
    Party 2 imports party 1's public key.
    The imported key will contain the new shared secret 
    key (Y^X) mod P. 
    ************************/
    fReturn = CryptImportKey(
        hProvParty2,
        pbKeyBlob1,
        dwDataLen1,
        hPrivateKey2,
        0,
        &amp;hSessionKey1);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    /************************
    Convert the agreed keys to symmetric keys. They are currently of 
    the form CALG_AGREEDKEY_ANY. Convert them to CALG_RC4.
    ************************/
    ALG_ID Algid = CALG_RC4;

    // Enable the party 1 public session key for use by setting the 
    // ALGID.
    fReturn = CryptSetKeyParam(
        hSessionKey1,
        KP_ALGID,
        (PBYTE)&amp;Algid,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Enable the party 2 public session key for use by setting the 
    // ALGID.
    fReturn = CryptSetKeyParam(
        hSessionKey2,
        KP_ALGID,
        (PBYTE)&amp;Algid,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    /************************
    Encrypt some data with party 1's session key. 
    ************************/
    // Get the size.
    DWORD dwLength = sizeof(g_rgbData);
    fReturn = CryptEncrypt(
        hSessionKey1, 
        0, 
        TRUE,
        0, 
        NULL, 
        &amp;dwLength,
        sizeof(g_rgbData));
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Allocate a buffer to hold the encrypted data.
    pbData = (PBYTE)malloc(dwLength);
    if(!pbData)
    {
        goto ErrorExit;
    }

    // Copy the unencrypted data to the buffer. The data will be 
    // encrypted in place.
    memcpy(pbData, g_rgbData, sizeof(g_rgbData)); 

    // Encrypt the data.
    dwLength = sizeof(g_rgbData);
    fReturn = CryptEncrypt(
        hSessionKey1, 
        0, 
        TRUE,
        0, 
        pbData, 
        &amp;dwLength,
        sizeof(g_rgbData));
    if(!fReturn)
    {
        goto ErrorExit;
    }
  
    /************************
    Decrypt the data with party 2's session key. 
    ************************/
    dwLength = sizeof(g_rgbData);
    fReturn = CryptDecrypt(
        hSessionKey2,
        0,
        TRUE,
        0,
        pbData,
        &amp;dwLength);
    if(!fReturn)
    {
        goto ErrorExit;
    }


ErrorExit:
    if(pbData)
    {
        free(pbData);
        pbData = NULL;
    }

    if(hSessionKey2)
    {
        CryptDestroyKey(hSessionKey2);
        hSessionKey2 = NULL;
    }

    if(hSessionKey1)
    {
        CryptDestroyKey(hSessionKey1);
        hSessionKey1 = NULL;
    }

    if(pbKeyBlob2)
    {
        free(pbKeyBlob2);
        pbKeyBlob2 = NULL;
    }

    if(pbKeyBlob1)
    {
        free(pbKeyBlob1);
        pbKeyBlob1 = NULL;
    }

    if(hPrivateKey2)
    {
        CryptDestroyKey(hPrivateKey2);
        hPrivateKey2 = NULL;
    }

    if(hPrivateKey1)
    {
        CryptDestroyKey(hPrivateKey1);
        hPrivateKey1 = NULL;
    }

    if(hProvParty2)
    {
        CryptReleaseContext(hProvParty2, 0);
        hProvParty2 = NULL;
    }

    if(hProvParty1)
    {
        CryptReleaseContext(hProvParty1, 0);
        hProvParty1 = NULL;
    }

    return 0;
}
</code></pre>
<p>Â </p>
<p>Â </p>
</body>
