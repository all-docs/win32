<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Indirect Drawing</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<h2>title: Indirect Drawing
description: Indirect drawing enables some scene-traversal and culling to be moved from the CPU to the GPU, which can improve performance. The command buffer can be generated by the CPU or GPU.
ms.assetid: F8D6C88A-101E-4F66-999F-43206F6527B6
ms.topic: article
ms.date: 05/31/2018</h2>
<h1>Indirect Drawing</h1>
<p>Indirect drawing enables some scene-traversal and culling to be moved from the CPU to the GPU, which can improve performance. The command buffer can be generated by the CPU or GPU.</p>
<ul>
<li><a href="#command-signatures">Command Signatures</a></li>
<li><a href="#indirect-argument-buffer-structures">Indirect Argument Buffer Structures</a></li>
<li><a href="#command-signature-creation">Command Signature Creation</a>
<ul>
<li><a href="#no-argument-changes">No Argument Changes</a></li>
<li><a href="#root-constants-and-vertex-buffers">Root Constants and Vertex Buffers</a></li>
</ul>
</li>
<li><a href="#related-topics">Related topics</a></li>
</ul>
<h2>Command Signatures</h2>
<p>The command signature object (<a href="/windows/win32/api/d3d12/nn-d3d12-id3d12commandsignature"><strong>ID3D12CommandSignature</strong></a>) enables apps to specify indirect drawing, in particular setting the following:</p>
<ul>
<li>The indirect argument buffer format.</li>
<li>The command type that will be used (from the <a href="/windows/desktop/api/d3d12/nn-d3d12-id3d12graphicscommandlist"><strong>ID3D12GraphicsCommandList</strong></a> methods <a href="/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-drawinstanced"><strong>DrawInstanced</strong></a>, <a href="/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-drawindexedinstanced"><strong>DrawIndexedInstanced</strong></a>, or <a href="/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-dispatch"><strong>Dispatch</strong></a>).</li>
<li>The set of resource bindings which will change per-command call versus the set which will be inherited.</li>
</ul>
<p>At startup, an app creates a small set of <strong>command signatures</strong>. At runtime, the application fills a buffer with commands (via whatever means the app developer chooses). The commands optionally containing state to set for vertex buffer views, index buffer views, root constants and root descriptors (raw or structured SRV/UAV/CBVs). These argument layouts are not hardware specific so apps can generate the buffers directly. The command signature inherits the remaining state from the command list. Then the app calls <a href="/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-executeindirect"><strong>ExecuteIndirect</strong></a> to instruct the GPU to interpret the contents of the indirect argument buffer according to the format defined by a particular command signature.</p>
<p>If the command signature changes any root arguments, then that's stored within the command signature as a subset of a root signature.</p>
<p>No command signature state leaks back to the command list after the execution is complete. But, after <strong>ExecuteIndirect</strong>, all bindings are reset to known values. In particular:</p>
<ul>
<li>If the command signature binds a vertex buffer to a particular slot, then after <strong>ExecuteIndirect</strong> is called, a NULL vertex buffer is bound to that slot.</li>
<li>If the command signature binds an index buffer, then after <strong>ExecuteIndirect</strong>, a NULL index buffer is bound.</li>
<li>If the command signature sets a root constant, then after <strong>ExecuteIndirect</strong> is called, the root constant value is set to 0.</li>
<li>If the command signature sets a root view (CBV/SRV/UAV), then after <strong>ExecuteIndirect</strong> is called, the root view is set to a NULL view.</li>
</ul>
<p>As an example of using command signatures: suppose an app developer wants a unique root constant to be specified per-draw call in the indirect argument buffer. The app would create a command signature that enables the indirect argument buffer to specify the following parameters per draw call:</p>
<ul>
<li>The value of one root constant.</li>
<li>The draw arguments (vertex count, instance count, etc).</li>
</ul>
<p>The indirect argument buffer generated by the application would contain an array of fixed-size records. Each structure corresponds to one draw call. Each structure contains the drawing arguments, and the value of the root constant. The number of draw calls is specified in a separate GPU-visible buffer.</p>
<p>An example command buffer generated by the app follows:</p>
<p><img src="images/indirect-drawing-command-buffer.png" alt="command buffer format" /></p>
<h2>Indirect Argument Buffer Structures</h2>
<p>The following structures define how particular arguments appear in an indirect argument buffer. These structures do not appear in any D3D12 API. Applications use these definitions when writing to an indirect argument buffer (with the CPU or GPU):</p>
<ul>
<li><a href="/windows/desktop/api/d3d12/ns-d3d12-d3d12_draw_arguments"><strong>D3D12_DRAW_ARGUMENTS</strong></a></li>
<li><a href="/windows/desktop/api/d3d12/ns-d3d12-d3d12_draw_indexed_arguments"><strong>D3D12_DRAW_INDEXED_ARGUMENTS</strong></a></li>
<li><a href="/windows/desktop/api/d3d12/ns-d3d12-d3d12_dispatch_arguments"><strong>D3D12_DISPATCH_ARGUMENTS</strong></a></li>
<li><a href="/windows/desktop/api/d3d12/ns-d3d12-d3d12_vertex_buffer_view"><strong>D3D12_VERTEX_BUFFER_VIEW</strong></a></li>
<li><a href="/windows/desktop/api/d3d12/ns-d3d12-d3d12_index_buffer_view"><strong>D3D12_INDEX_BUFFER_VIEW</strong></a></li>
<li>D3D12_GPU_VIRTUAL_ADDRESS (a typedef'd synonym of UINT64).</li>
<li><a href="/windows/desktop/api/d3d12/ns-d3d12-d3d12_constant_buffer_view_desc"><strong>D3D12_CONSTANT_BUFFER_VIEW</strong></a></li>
</ul>
<h2>Command Signature Creation</h2>
<p>To create a command signature, use the following API items:</p>
<ul>
<li><a href="/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createcommandsignature"><strong>ID3D12Device::CreateCommandSignature</strong></a> (outputs an <a href="/windows/win32/api/d3d12/nn-d3d12-id3d12commandsignature"><strong>ID3D12CommandSignature</strong></a>)</li>
<li><a href="/windows/desktop/api/d3d12/ne-d3d12-d3d12_indirect_argument_type"><strong>D3D12_INDIRECT_ARGUMENT_TYPE</strong></a></li>
<li><a href="/windows/desktop/api/d3d12/ns-d3d12-d3d12_indirect_argument_desc"><strong>D3D12_INDIRECT_ARGUMENT_DESC</strong></a></li>
<li><a href="/windows/desktop/api/d3d12/ns-d3d12-d3d12_command_signature_desc"><strong>D3D12_COMMAND_SIGNATURE_DESC</strong></a></li>
</ul>
<p>The ordering of arguments within an indirect argument buffer is defined to exactly match the order of arguments specified in the <em>pArguments</em> parameter of <a href="/windows/desktop/api/d3d12/ns-d3d12-d3d12_command_signature_desc"><strong>D3D12_COMMAND_SIGNATURE_DESC</strong></a>. All of the arguments for one draw (graphics)/dispatch (compute) call within an indirect argument buffer are tightly packed. However, applications are allowed to specify an arbitrary byte stride between draw/dispatch commands in an indirect argument buffer.</p>
<p>The root signature must be specified if and only if the command signature changes one of the root arguments.</p>
<p>For root SRV/UAV/CBV, the application specified size is in bytes. The debug layer will validate the following restrictions on the address:</p>
<ul>
<li>CBV â€“ address must be a multiple of 256 bytes.</li>
<li>Raw SRV/UAV â€“ address must be a multiple of 4 bytes.</li>
<li>Structured SRV/UAV â€“ address must be a multiple of the structure byte stride (declared in the shader).</li>
</ul>
<p>A given command signature is either a draw or a compute command signature. If a command signature contains a drawing operation, then it is a graphics command signature. Otherwise, the command signature must contain a dispatch operation, and it is a compute command signature.</p>
<p>The following sections show some example command signatures.</p>
<h3>No Argument Changes</h3>
<p>In this example, the indirect argument buffer generated by the application holds an array of 36-byte structures. Each structure only contains the five parameters passed to <a href="/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-drawindexedinstanced"><strong>DrawIndexedInstanced</strong></a> (plus padding).</p>
<p>The code to create the command signature description follows:</p>
<pre lang="syntax"><code>D3D12_INDIRECT_ARGUMENT_DESC Args[1];
Args[0].Type = D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED;

D3D12_COMMAND_SIGNATURE_DESC ProgramDesc;
ProgramDesc.ByteStride = 36;
ProgramDesc.NumArgumentDescs = 1;
ProgramDesc.pArguments = Args;
</code></pre>
<p>The layout of a single structure within an indirect argument buffer is:</p>
<table>
<thead>
<tr>
<th>Bytes</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0:3</td>
<td>IndexCountPerInstance</td>
</tr>
<tr>
<td>4:7</td>
<td>InstanceCount</td>
</tr>
<tr>
<td>8:11</td>
<td>StartIndexLocation</td>
</tr>
<tr>
<td>12:15</td>
<td>BaseVertexLocation</td>
</tr>
<tr>
<td>16:19</td>
<td>StartInstanceLocation</td>
</tr>
<tr>
<td>20:35</td>
<td>Padding</td>
</tr>
</tbody>
</table>
<p>Â </p>
<h3>Root Constants and Vertex Buffers</h3>
<p>In this example, each structure in an indirect argument buffer changes two root constants, changes one vertex buffer binding, and performs one drawing non-indexed operation. There is no padding between structures.</p>
<p>The code to create the command signature description is:</p>
<pre lang="syntax"><code>D3D12_INDIRECT_ARGUMENT_DESC Args[4];
Args[0].Type = D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT;
Args[0].Constant.RootParameterIndex = 2;
Args[0].Constant.DestOffsetIn32BitValues = 0;
Args[0].Constant.Num32BitValuesToSet = 1;

Args[1].Type = D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT;
Args[1].Constant.RootParameterIndex = 6;
Args[1].Constant.DestOffsetIn32BitValues = 0;
Args[1].Constant.Num32BitValuesToSet = 1;

Args[2].Type = D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW;
Args[2].VertexBuffer.Slot = 3;

Args[3].Type = D3D12_INDIRECT_ARGUMENT_TYPE_DRAW;

D3D12_COMMAND_SIGNATURE_DESC ProgramDesc;
ProgramDesc.ByteStride = 40;
ProgramDesc.NumArgumentDescs = 4;
ProgramDesc.pArguments = Args;
</code></pre>
<p>The layout of a single structure within the indirect argument buffer is the following:</p>
<table>
<thead>
<tr>
<th>Bytes</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0:3</td>
<td>Data for root parameter index 2</td>
</tr>
<tr>
<td>4:7</td>
<td>Data for root parameter index 6</td>
</tr>
<tr>
<td>8:15</td>
<td>Virtual address of VB at slot 3 (64-bit)</td>
</tr>
<tr>
<td>16:19</td>
<td>VB size</td>
</tr>
<tr>
<td>20:23</td>
<td>VB stride</td>
</tr>
<tr>
<td>24:27</td>
<td>VertexCountPerInstance</td>
</tr>
<tr>
<td>28:31</td>
<td>InstanceCount</td>
</tr>
<tr>
<td>32:35</td>
<td>StartVertexLocation</td>
</tr>
<tr>
<td>36:39</td>
<td>StartInstanceLocation</td>
</tr>
</tbody>
</table>
<p>Â </p>
<h2>Related topics</h2>
<!-- raw HTML omitted -->
<p><a href="https://www.youtube.com/watch?v=fKD-VKJeeds">DirectX advanced learning video tutorials : Execute Indirect and Async GPU culling</a></p>
<!-- raw HTML omitted -->
<p><a href="indirect-drawing-and-gpu-culling-.html">Indirect drawing and GPU culling : code walk-through</a></p>
<!-- raw HTML omitted -->
<p><a href="rendering.html">Rendering</a></p>
<!-- raw HTML omitted -->
<p>Â </p>
<p>Â </p>
</body>
