<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Synchronization Objects</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<h2>description: A synchronization object is an object whose handle can be specified in one of the wait functions to coordinate the execution of multiple threads.
ms.assetid: 11558ae9-1056-48bf-96f5-94a051df41c3
title: Synchronization Objects
ms.topic: article
ms.date: 05/31/2018</h2>
<h1>Synchronization Objects</h1>
<p>A <em>synchronization object</em> is an object whose handle can be specified in one of the <a href="wait-functions.html">wait functions</a> to coordinate the execution of multiple threads. More than one process can have a handle to the same synchronization object, making interprocess synchronization possible.</p>
<p>The following object types are provided exclusively for synchronization.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Event</td>
<td>Notifies one or more waiting threads that an event has occurred. For more information, see <a href="event-objects.html">Event Objects</a>.</td>
</tr>
<tr>
<td>Mutex</td>
<td>Can be owned by only one thread at a time, enabling threads to coordinate mutually exclusive access to a shared resource. For more information, see <a href="mutex-objects.html">Mutex Objects</a>.</td>
</tr>
<tr>
<td>Semaphore</td>
<td>Maintains a count between zero and some maximum value, limiting the number of threads that are simultaneously accessing a shared resource. For more information, see <a href="semaphore-objects.html">Semaphore Objects</a>.</td>
</tr>
<tr>
<td>Waitable timer</td>
<td>Notifies one or more waiting threads that a specified time has arrived. For more information, see <a href="waitable-timer-objects.html">Waitable Timer Objects</a>.</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>Though available for other uses, the following objects can also be used for synchronization.</p>
<table>
<thead>
<tr>
<th>Object</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Change notification</td>
<td>Created by the <a href="/windows/win32/api/fileapi/nf-fileapi-findfirstchangenotificationa"><strong>FindFirstChangeNotification</strong></a> function, its state is set to signaled when a specified type of change occurs within a specified directory or directory tree. For more information, see <a href="../fileio/obtaining-directory-change-notifications.html">Obtaining Directory Change Notifications</a>.</td>
</tr>
<tr>
<td>Console input</td>
<td>Created when a console is created. The handle to console input is returned by the <a href="/windows/win32/api/fileapi/nf-fileapi-createfilea"><strong>CreateFile</strong></a> function when CONIN$ is specified, or by the <a href="/windows/console/getstdhandle"><strong>GetStdHandle</strong></a> function. Its state is set to signaled when there is unread input in the console's input buffer, and set to nonsignaled when the input buffer is empty. For more information about consoles, see <a href="/windows/console/character-mode-applications">Character-Mode Applications</a></td>
</tr>
<tr>
<td>Job</td>
<td>Created by calling the <a href="/windows/win32/api/jobapi2/nf-jobapi2-createjobobjectw"><strong>CreateJobObject</strong></a> function. The state of a job object is set to signaled when all its processes are terminated because the specified end-of-job time limit has been exceeded. For more information about job objects, see <a href="../procthread/job-objects.html">Job Objects</a>.</td>
</tr>
<tr>
<td>Memory resource notification</td>
<td>Created by the <a href="/windows/win32/api/memoryapi/nf-memoryapi-creatememoryresourcenotification"><strong>CreateMemoryResourceNotification</strong></a> function. Its state is set to signaled when a specified type of change occurs within physical memory. For more information about memory, see <a href="../memory/memory-management.html">Memory Management</a>.</td>
</tr>
<tr>
<td>Process</td>
<td>Created by calling the <a href="/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa"><strong>CreateProcess</strong></a> function. Its state is set to nonsignaled while the process is running, and set to signaled when the process terminates. For more information about processes, see <a href="../procthread/processes-and-threads.html">Processes and Threads</a>.</td>
</tr>
<tr>
<td>Thread</td>
<td>Created when a new thread is created by calling the <a href="/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa"><strong>CreateProcess</strong></a>, <a href="/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread"><strong>CreateThread</strong></a>, or <a href="/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread"><strong>CreateRemoteThread</strong></a> function. Its state is set to nonsignaled while the thread is running, and set to signaled when the thread terminates. For more information about threads, see <a href="../procthread/processes-and-threads.html">Processes and Threads</a>.</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>In some circumstances, you can also use a file, named pipe, or communications device as a synchronization object; however, their use for this purpose is discouraged. Instead, use asynchronous I/O and wait on the event object set in the <a href="/windows/win32/api/minwinbase/ns-minwinbase-overlapped"><strong>OVERLAPPED</strong></a> structure. It is safer to use the event object because of the confusion that can occur when multiple simultaneous overlapped operations are performed on the same file, named pipe, or communications device. In this situation, there is no way to know which operation caused the object's state to be signaled.</p>
<p>For additional information about I/O operations on files, named pipes, or communications, see <a href="synchronization-and-overlapped-input-and-output.html">Synchronization and Overlapped Input and Output</a>.</p>
<p>Â </p>
<p>Â </p>
</body>
