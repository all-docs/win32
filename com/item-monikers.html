<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Item Monikers</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<h2>title: Item Monikers
description: Another OLE-implemented moniker class is the item moniker, which can be used to identify an object contained in another object.
ms.assetid: ddcf3669-4ad0-4a4e-80a6-eb78058cff09
ms.topic: article
ms.date: 05/31/2018</h2>
<h1>Item Monikers</h1>
<p>Another OLE-implemented moniker class is the <em>item moniker</em>, which can be used to identify an object contained in another object. One type of contained object is an OLE object embedded in a compound document. A compound document could identify the embedded objects it contains by assigning each one an arbitrary name, such as &quot;embedobj1,&quot; &quot;embedobj2,&quot; and so forth. Another type of contained object is a user selection in a document, such as a range of cells in a spreadsheet or a range of characters in a text document. An object that consists of a selection is called a <em>pseudo-object</em> because it isn't treated as a distinct object until a user marks the selection. A spreadsheet might identify a cell range using a name such as &quot;1A:7F,&quot; while a word processing document might identify a range of characters using the name of a bookmark.</p>
<p>An item moniker is useful primarily when concatenated, or <em>composed</em>, with another moniker, one that identifies the container. An item moniker is usually created and then composed onto (for example) a file moniker to create the equivalent of a complete path to the object. For example, you can compose the file moniker &quot;c:\work\report.doc&quot; (which identifies the container object) with the item moniker &quot;embedobj1&quot; (which identifies an object within the container) to form the moniker &quot;c:\work\report.doc\embedobj1,&quot; which uniquely identifies a particular object within a particular file. You can also concatenate additional item monikers to identify deeply nested objects. For example, if &quot;embedobj1&quot; is the name of a spreadsheet object, to identify a certain range of cells in that spreadsheet object you could append another item moniker to create a moniker that would be the equivalent of &quot;c:\work\report.doc\embedobj1\1A:7F.&quot;</p>
<p>When combined with a file moniker, an item moniker forms a complete path. Item monikers thus extend the notion of path names beyond the file system, defining path names to identify individual objects, not just files.</p>
<p>There is a significant difference between an item moniker and a file moniker. The path contained in a file moniker is meaningful to anyone who understands the file system, while the partial path contained in an item moniker is meaningful only to a particular container. Everyone knows what &quot;c:\work\report.doc&quot; refers to, but only one particular container object knows what &quot;1A:7F&quot; refers to. One container cannot interpret an item moniker created by another application; the only container that knows which object is referred to by an item moniker is the container that assigned the item moniker to the object in the first place. For this reason, the source of the object named by the combination of a file and item moniker must not only implement <a href="/windows/desktop/api/ObjIdl/nn-objidl-ipersistfile"><strong>IPersistFile</strong></a>, to facilitate binding the file moniker, but also <a href="/windows/desktop/api/OleIdl/nn-oleidl-ioleitemcontainer"><strong>IOleItemContainer</strong></a> to facilitate resolving the name of the item moniker into the appropriate object, in the context of a file.</p>
<p>The advantage of monikers is that someone using a moniker to locate an object doesn't need to understand the name contained within the item moniker, as long as the item moniker is part of a composite. Generally, it would not make sense for an item moniker to exist on its own. Instead, you would compose an item moniker onto a file moniker. You would then call <a href="/windows/desktop/api/ObjIdl/nf-objidl-imoniker-bindtoobject"><strong>IMoniker::BindToObject</strong></a> on the composite, which binds the individual monikers within it, interpreting the names.</p>
<p>To create an item moniker object and return its pointer to the moniker provider, OLE provides the helper function <a href="/windows/desktop/api/Objbase/nf-objbase-createitemmoniker"><strong>CreateItemMoniker</strong></a>. This function creates an item moniker object and returns its pointer to the provider.</p>
<h2>Related topics</h2>
<!-- raw HTML omitted -->
<p><a href="anti-monikers.html">Anti-Monikers</a></p>
<!-- raw HTML omitted -->
<p><a href="class-monikers.html">Class Monikers</a></p>
<!-- raw HTML omitted -->
<p><a href="composite-monikers.html">Composite Monikers</a></p>
<!-- raw HTML omitted -->
<p><a href="file-monikers.html">File Monikers</a></p>
<!-- raw HTML omitted -->
<p><a href="pointer-monikers.html">Pointer Monikers</a></p>
<!-- raw HTML omitted -->
<p>Â </p>
<p>Â </p>
</body>
