<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Marshaling Details</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<h2>title: Marshaling Details
description: If you use standard marshaling, COM handles all of the details described here for you.
ms.assetid: bf3fe212-648e-4d00-ad1d-43d2e5e6a7ae
ms.topic: article
ms.date: 05/31/2018</h2>
<h1>Marshaling Details</h1>
<p>If you use standard marshaling, COM handles all of the details described here for you. However, there are those few programmers who need these details and for those interested in the underlying information. Marshaling is the process of packaging and unpackaging parameters so a remote procedure call can take place.</p>
<p>Different parameter types are marshaled in different ways. For example, marshaling an integer parameter involves simply copying the value into the message buffer. (Although even in this simple case, there are issues such as byte ordering to deal with in cross-computer calls.) Marshaling an array, however, is a more complex process. Array members are copied in a specific order so that the other side can reconstruct the array exactly. When a pointer is marshaled, the data that the pointer is pointing to is copied following rules and conventions for dealing with nested pointers in structures. Unique functions exist to handle the marshaling of each parameter type.</p>
<p>With standard marshaling, the proxies and stubs are systemwide resources for the interface and they interact with the channel through a standard protocol. Standard marshaling can be used both by standard COM-defined interfaces and by custom interfaces, as follows:</p>
<ul>
<li>In the case of most COM interfaces, the proxies and stubs for standard marshaling are in-process component objects which are loaded from a systemwide DLL provided by COM in Ole32.dll.</li>
<li>In the case of custom interfaces, the proxies and stubs for standard marshaling are generated by the interface designer, typically with MIDL. These proxies and stubs are statically configured in the registry, so any potential client can use the custom interface across process boundaries. These proxies and stubs are loaded from a DLL that is located via the system registry, using the interface ID (IID) for the custom interface they marshal.</li>
<li>An alternative to using MIDL to generate proxies and stubs for custom interfaces, a type library can be generated instead and the system provided, type-library-driven marshaling engine will marshal the interface.</li>
</ul>
<p>As an alternative to standard marshaling, an interface (standard or custom) can use custom marshaling. With custom marshaling, an object dynamically implements the proxies at run time for each interface that it supports. For any given interface, the object can select COM-provided standard marshaling or custom marshaling. This choice is made by the object on an interface-by-interface basis. Once the choice is made for a given interface, it remains in effect during the object's lifetime. However, one interface on an object can use custom marshaling while another uses standard marshaling.</p>
<p>Custom marshaling is inherently unique to the object that implements it. It uses proxies implemented by the object and provided to the system on request at run time. Objects that implement custom marshaling must implement the <a href="/windows/win32/api/objidlbase/nn-objidlbase-imarshal"><strong>IMarshal</strong></a> interface, whereas objects that support standard marshaling do not.</p>
<p>If you decide to write a custom interface, you must provide marshaling support for it. Typically, you will provide a standard marshaling DLL for the interface you design. You can create the proxy/stub code and the proxy/stub DLL, or you can create a type library that COM will use to do data-driven marshaling (using the data in the type library).</p>
<p>For a client to make a call to an interface method in an object in another process involves the cooperation of several components. The standard proxy is a piece of interface-specific code that resides in the client's process space and prepares the interface parameters for transmittal. It packages, or marshals, them in such a way that they can be re-created and understood in the receiving process. The standard stub, also a piece of interface-specific code, resides in the server's process space and reverses the work of the proxy. The stub unpackages, or unmarshals, the sent parameters and forwards them to the object application. It also packages reply information to send back to the client.</p>
<blockquote>
<p>[!Note]<br />
Readers more familiar with RPC than COM may be used to seeing the terms client stub and server stub. These terms are analogous to proxy and stub.</p>
</blockquote>
<p>Â </p>
<h2>Components of Interprocess Communications</h2>
<p>The following diagram shows the flow of communication between the components involved. On the client side of the process boundary, the client's method call goes through the proxy and then onto the channel, which is part of the COM library. The channel sends the buffer containing the marshaled parameters to the RPC run-time library, which transmits it across the process boundary. The RPC run time and the COM libraries exist on both sides of the process. The distinction between the channel and the RPC run time is a characteristic of this implementation and is not part of the programming model or the conceptual model for COM client/server objects. COM servers see only the proxy or stub and, indirectly, the channel. Future implementations may use different layers below the channel or no layers.</p>
<p><img src="images/457036c1-98b8-4f35-aebe-70de38112b83.png" alt="Diagram that shows the Client.exe and Server.exe flows on each side fo the Process Boundary." /></p>
<h2>Related topics</h2>
<!-- raw HTML omitted -->
<p><a href="channel.html">Channel</a></p>
<!-- raw HTML omitted -->
<p><a href="inter-object-communication.html">Inter-Object Communication</a></p>
<!-- raw HTML omitted -->
<p><a href="microsoft-rpc.html">Microsoft RPC</a></p>
<!-- raw HTML omitted -->
<p><a href="proxy.html">Proxy</a></p>
<!-- raw HTML omitted -->
<p><a href="stub.html">Stub</a></p>
<!-- raw HTML omitted -->
<p>Â </p>
<p>Â </p>
</body>
