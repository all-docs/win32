<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Proxy</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<h2>title: Proxy
description: A proxy resides in the address space of the calling process and acts as a surrogate for the remote object.
ms.assetid: '6c82f655-ac46-4ed9-992b-0387b324a8f9'
ms.topic: article
ms.date: 05/31/2018</h2>
<h1>Proxy</h1>
<p>A proxy resides in the address space of the calling process and acts as a surrogate for the remote object. From the perspective of the calling object, the proxy is the object. Typically, the proxy's role is to package the interface parameters for calls to methods in its object interfaces. The proxy packages the parameters into a message buffer and passes the buffer onto the channel, which handles the transport between processes. The proxy is implemented as an aggregate, or composite, object. It contains a system-provided, manager piece called the proxy manager and one or more interface-specific components called interface proxies. The number of interface proxies equals the number of object interfaces that have been exposed to that particular client. To the client complying with the component object model, the proxy appears to be the real object.</p>
<blockquote>
<p>[!Note]<br />
With custom marshaling, the proxy can be implemented similarly or it can communicate directly with the object without using a stub.</p>
</blockquote>
<p>Â </p>
<p>Each interface proxy is a component object that implements the marshaling code for one of the object's interfaces. The proxy represents the object for which it provides marshaling code. Each proxy also implements the <a href="/windows/win32/api/objidlbase/nn-objidlbase-irpcproxybuffer"><strong>IRpcProxyBuffer</strong></a> interface. Although the object interface represented by the proxy is public, the <strong>IRpcProxyBuffer</strong> implementation is private and is used internally within the proxy. The proxy manager keeps track of the interface proxies and also contains the public implementation of the controlling <a href="/windows/desktop/api/Unknwn/nn-unknwn-iunknown"><strong>IUnknown</strong></a> interface for the aggregate. Each interface proxy can exist in a separate DLL that is loaded when the interface it supports is materialized to the client.</p>
<h2>Structure of the Proxy</h2>
<p>The following diagram shows the structure of a proxy that supports the standard marshaling of parameters belonging to two interfaces: IA1 and IA2. Each interface proxy implements <a href="/windows/win32/api/objidlbase/nn-objidlbase-irpcproxybuffer"><strong>IRpcProxyBuffer</strong></a> for internal communication between the aggregate pieces. When the proxy is ready to pass its marshaled parameters across the process boundary, it calls methods in the <a href="/windows/win32/api/objidlbase/nn-objidlbase-irpcchannelbuffer"><strong>IRpcChannelBuffer</strong></a> interface, which is implemented by the channel. The channel in turn forwards the call to the RPC run-time library so that it can reach its destination in the object.</p>
<p><img src="images/4432d8d3-dfab-4635-90f8-408aecf70134.png" alt="Diagram that shows the structure of the proxy." /></p>
<h2>Related topics</h2>
<!-- raw HTML omitted -->
<p><a href="channel.html">Channel</a></p>
<!-- raw HTML omitted -->
<p><a href="inter-object-communication.html">Inter-Object Communication</a></p>
<!-- raw HTML omitted -->
<p><a href="marshaling-details.html">Marshaling Details</a></p>
<!-- raw HTML omitted -->
<p><a href="microsoft-rpc.html">Microsoft RPC</a></p>
<!-- raw HTML omitted -->
<p><a href="stub.html">Stub</a></p>
<!-- raw HTML omitted -->
<p>Â </p>
<p>Â </p>
</body>
