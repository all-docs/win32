<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>D3DXComputeTangentFrameEx function</title>
<style>
table th { border: 1px solid; }
table td { border: 1px solid; }
</style>
</head>
<body>
<hr />
<p>description: Performs tangent frame computations on a mesh. Tangent, binormal, and optionally normal vectors are generated. Singularities are handled as required by grouping edges and splitting vertices.
ms.assetid: 15cc46bc-6db6-4e1d-a95e-cd60d2666600
title: D3DXComputeTangentFrameEx function (D3DX9Mesh.h)
ms.topic: reference
ms.date: 05/31/2018
topic_type:</p>
<ul>
<li>APIRef</li>
<li>kbSyntax
api_name:</li>
<li>D3DXComputeTangentFrameEx
api_type:</li>
<li>LibDef
api_location:</li>
<li>d3dx9.lib</li>
<li>d3dx9.dll</li>
</ul>
<hr />
<h1>D3DXComputeTangentFrameEx function</h1>
<p>Performs tangent frame computations on a mesh. Tangent, binormal, and optionally normal vectors are generated. Singularities are handled as required by grouping edges and splitting vertices.</p>
<h2>Syntax</h2>
<pre lang="C++"><code>HRESULT D3DXComputeTangentFrameEx(
  _In_Â Â Â Â Â Â Â Â ID3DXMesh Â Â *pMesh,
  _In_Â Â Â Â Â Â Â Â DWORD Â Â Â Â Â Â dwTextureInSemantic,
  _In_Â Â Â Â Â Â Â Â DWORD Â Â Â Â Â Â dwTextureInIndex,
  _In_Â Â Â Â Â Â Â Â DWORD Â Â Â Â Â Â dwUPartialOutSemantic,
  _In_Â Â Â Â Â Â Â Â DWORD Â Â Â Â Â Â dwUPartialOutIndex,
  _In_Â Â Â Â Â Â Â Â DWORD Â Â Â Â Â Â dwVPartialOutSemantic,
  _In_Â Â Â Â Â Â Â Â DWORD Â Â Â Â Â Â dwVPartialOutIndex,
  _In_Â Â Â Â Â Â Â Â DWORD Â Â Â Â Â Â dwNormalOutSemantic,
  _In_Â Â Â Â Â Â Â Â DWORD Â Â Â Â Â Â dwNormalOutIndex,
  _In_Â Â Â Â Â Â Â Â DWORD Â Â Â Â Â Â dwOptions,
  _In_Â Â const DWORD Â Â Â Â Â Â *pdwAdjacency,
  _In_Â Â Â Â Â Â Â Â FLOAT Â Â Â Â Â Â fPartialEdgeThreshold,
  _In_Â Â Â Â Â Â Â Â FLOAT Â Â Â Â Â Â fSingularPointThreshold,
  _In_Â Â Â Â Â Â Â Â FLOAT Â Â Â Â Â Â fNormalEdgeThreshold,
  _Out_Â Â Â Â Â Â Â ID3DXMesh Â Â **ppMeshOut,
  _Out_Â Â Â Â Â Â Â ID3DXBuffer **ppVertexMapping
);
</code></pre>
<h2>Parameters</h2>
<!-- raw HTML omitted -->
<p><em>pMesh</em> [in]</p>
<!-- raw HTML omitted -->
<p>Type: <strong><a href="id3dxmesh.html"><strong>ID3DXMesh</strong></a>*</strong></p>
<p>Pointer to an input <a href="id3dxmesh.html"><strong>ID3DXMesh</strong></a> mesh object.</p>
<!-- raw HTML omitted -->
<p><em>dwTextureInSemantic</em> [in]</p>
<!-- raw HTML omitted -->
<p>Type: <strong><a href="../winprog/windows-data-types.html"><strong>DWORD</strong></a></strong></p>
<p>Specifies the texture coordinate input semantic. If D3DX_DEFAULT, the function assumes that there are no texture coordinates, and the function will fail unless normal vector calculation is specified.</p>
<!-- raw HTML omitted -->
<p><em>dwTextureInIndex</em> [in]</p>
<!-- raw HTML omitted -->
<p>Type: <strong><a href="../winprog/windows-data-types.html"><strong>DWORD</strong></a></strong></p>
<p>If a mesh has multiple texture coordinates, specifies the texture coordinate to use for the tangent frame computations. If zero, the mesh has only a single texture coordinate.</p>
<!-- raw HTML omitted -->
<p><em>dwUPartialOutSemantic</em> [in]</p>
<!-- raw HTML omitted -->
<p>Type: <strong><a href="../winprog/windows-data-types.html"><strong>DWORD</strong></a></strong></p>
<p>Specifies the output semantic for the type, typically D3DDECLUSAGE_TANGENT, that describes where the partial derivative with respect to the U texture coordinate will be stored. If D3DX_DEFAULT, then this partial derivative will not be stored.</p>
<!-- raw HTML omitted -->
<p><em>dwUPartialOutIndex</em> [in]</p>
<!-- raw HTML omitted -->
<p>Type: <strong><a href="../winprog/windows-data-types.html"><strong>DWORD</strong></a></strong></p>
<p>Specifies the semantic index at which to store the partial derivative with respect to the U texture coordinate.</p>
<!-- raw HTML omitted -->
<p><em>dwVPartialOutSemantic</em> [in]</p>
<!-- raw HTML omitted -->
<p>Type: <strong><a href="../winprog/windows-data-types.html"><strong>DWORD</strong></a></strong></p>
<p>Specifies the <a href="./d3ddeclusage.html"><strong>D3DDECLUSAGE</strong></a> type, typically D3DDECLUSAGE_BINORMAL, that describes where the partial derivative with respect to the V texture coordinate will be stored. If D3DX_DEFAULT, then this partial derivative will not be stored.</p>
<!-- raw HTML omitted -->
<p><em>dwVPartialOutIndex</em> [in]</p>
<!-- raw HTML omitted -->
<p>Type: <strong><a href="../winprog/windows-data-types.html"><strong>DWORD</strong></a></strong></p>
<p>Specifies the semantic index at which to store the partial derivative with respect to the V texture coordinate.</p>
<!-- raw HTML omitted -->
<p><em>dwNormalOutSemantic</em> [in]</p>
<!-- raw HTML omitted -->
<p>Type: <strong><a href="../winprog/windows-data-types.html"><strong>DWORD</strong></a></strong></p>
<p>Specifies the output normal semantic, typically D3DDECLUSAGE_NORMAL, that describes where the normal vector at each vertex will be stored. If D3DX_DEFAULT, then this normal vector will not be stored.</p>
<!-- raw HTML omitted -->
<p><em>dwNormalOutIndex</em> [in]</p>
<!-- raw HTML omitted -->
<p>Type: <strong><a href="../winprog/windows-data-types.html"><strong>DWORD</strong></a></strong></p>
<p>Specifies the semantic index at which to store the normal vector at each vertex.</p>
<!-- raw HTML omitted -->
<p><em>dwOptions</em> [in]</p>
<!-- raw HTML omitted -->
<p>Type: <strong><a href="../winprog/windows-data-types.html"><strong>DWORD</strong></a></strong></p>
<p>Combination of one or more <a href="./d3dxtangent.html"><strong>D3DXTANGENT</strong></a> flags that specify tangent frame computation options. If <strong>NULL</strong>, the following options will be specified:</p>
<table>
<thead>
<tr>
<th>Description</th>
<th><a href="./d3dxtangent.html"><strong>D3DXTANGENT</strong></a> Flag Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Weight the normal vector length by the angle, in radians, subtended by the two edges leaving the vertex.</td>
<td>&amp; !( D3DXTANGENT_WEIGHT_BY_AREA | D3DXTANGENT_WEIGHT_EQUAL )</td>
</tr>
<tr>
<td>Compute orthogonal Cartesian coordinates from texture coordinates (u, v). See Remarks.</td>
<td>&amp; !( D3DXTANGENT_ORTHOGONALIZE_FROM_U | D3DXTANGENT_ORTHOGONALIZE_FROM_V )</td>
</tr>
<tr>
<td>Textures are not wrapped in either u or v directions</td>
<td>&amp; !( D3DXTANGENT_WRAP_UV )</td>
</tr>
<tr>
<td>Partial derivatives with respect to texture coordinates are normalized.</td>
<td>&amp; !( D3DXTANGENT_DONT_NORMALIZE_PARTIALS )</td>
</tr>
<tr>
<td>Vertices are ordered in a counterclockwise direction around each triangle.</td>
<td>&amp; !( D3DXTANGENT_WIND_CW )</td>
</tr>
<tr>
<td>Use per-vertex normal vectors already present in the input mesh.</td>
<td>&amp; !( D3DXTANGENT_CALCULATE_NORMALS )</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>If D3DXTANGENT_GENERATE_IN_PLACE is not set, the input mesh is cloned. The original mesh must therefore have sufficient space to store the computed normal vector and partial derivative data.</p>
<!-- raw HTML omitted -->
<p><em>pdwAdjacency</em> [in]</p>
<!-- raw HTML omitted -->
<p>Type: <strong>const <a href="../winprog/windows-data-types.html"><strong>DWORD</strong></a>*</strong></p>
<p>Pointer to an array of three DWORDs per face that specify the three neighbors for each face in the mesh. The number of bytes in this array must be at least 3 * <a href="id3dxbasemesh--getnumfaces.html"><strong>GetNumFaces</strong></a> * sizeof(DWORD).</p>
<!-- raw HTML omitted -->
<p><em>fPartialEdgeThreshold</em> [in]</p>
<!-- raw HTML omitted -->
<p>Type: <strong><a href="../winprog/windows-data-types.html"><strong>FLOAT</strong></a></strong></p>
<p>Specifies the maximum cosine of the angle at which two partial derivatives are deemed to be incompatible with each other. If the dot product of the direction of the two partial derivatives in adjacent triangles is less than or equal to this threshold, then the vertices shared between these triangles will be split.</p>
<!-- raw HTML omitted -->
<p><em>fSingularPointThreshold</em> [in]</p>
<!-- raw HTML omitted -->
<p>Type: <strong><a href="../winprog/windows-data-types.html"><strong>FLOAT</strong></a></strong></p>
<p>Specifies the maximum magnitude of a partial derivative at which a vertex will be deemed singular. As multiple triangles are incident on a point that have nearby tangent frames, but altogether cancel each other out (such as at the top of a sphere), the magnitude of the partial derivative will decrease. If the magnitude is less than or equal to this threshold, then the vertex will be split for every triangle that contains it.</p>
<!-- raw HTML omitted -->
<p><em>fNormalEdgeThreshold</em> [in]</p>
<!-- raw HTML omitted -->
<p>Type: <strong><a href="../winprog/windows-data-types.html"><strong>FLOAT</strong></a></strong></p>
<p>Similar to fPartialEdgeThreshold, specifies the maximum cosine of the angle between two normals that is a threshold beyond which vertices shared between triangles will be split. If the dot product of the two normals is less than the threshold, the shared vertices will be split, forming a hard edge between neighboring triangles. If the dot product is more than the threshold, neighboring triangles will have their normals interpolated.</p>
<!-- raw HTML omitted -->
<p><em>ppMeshOut</em> [out]</p>
<!-- raw HTML omitted -->
<p>Type: <strong><a href="id3dxmesh.html"><strong>ID3DXMesh</strong></a>**</strong></p>
<p>Address of a pointer to an output <a href="id3dxmesh.html"><strong>ID3DXMesh</strong></a> mesh object that receives the computed tangent, binormal, and normal vector data.</p>
<!-- raw HTML omitted -->
<p><em>ppVertexMapping</em> [out]</p>
<!-- raw HTML omitted -->
<p>Type: <strong><a href="id3dxbuffer.html"><strong>ID3DXBuffer</strong></a>**</strong></p>
<p>Address of a pointer to an output <a href="id3dxbuffer.html"><strong>ID3DXBuffer</strong></a> buffer object that receives a mapping of new vertices computed by this method to the original vertices. The buffer is an array of DWORDs, with the array size defined as the number of vertices in ppMeshOut.</p>
<!-- raw HTML omitted -->
<h2>Return value</h2>
<p>Type: <strong><a href="https://msdn.microsoft.com/library/Bb401631(v=MSDN.10).aspx"><strong>HRESULT</strong></a></strong></p>
<p>If the function succeeds, the return value is S_OK. If the function fails, the return value can be one of the following: D3DERR_INVALIDCALL, D3DXERR_INVALIDDATA, E_OUTOFMEMORY.</p>
<h2>Remarks</h2>
<p>A simplified version of this function is available as <a href="d3dxcomputetangentframe.html"><strong>D3DXComputeTangentFrame</strong></a>.</p>
<p>The computed normal vector at each vertex is always normalized to have unit length.</p>
<p>The most robust solution for computing orthogonal Cartesian coordinates is to not set flags D3DXTANGENT_ORTHOGONALIZE_FROM_U and D3DXTANGENT_ORTHOGONALIZE_FROM_V, so that orthogonal coordinates are computed from both texture coordinates u and v. However, in this case, if either u or v is zero, then the function will compute orthogonal coordinates using D3DXTANGENT_ORTHOGONALIZE_FROM_V or D3DXTANGENT_ORTHOGONALIZE_FROM_U, respectively.</p>
<h2>Requirements</h2>
<table>
<thead>
<tr>
<th>Requirement</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Header<!-- raw HTML omitted --></td>
<td><!-- raw HTML omitted --> <!-- raw HTML omitted -->D3DX9Mesh.h<!-- raw HTML omitted --> <!-- raw HTML omitted --></td>
</tr>
<tr>
<td>Library<!-- raw HTML omitted --></td>
<td><!-- raw HTML omitted --> <!-- raw HTML omitted -->D3dx9.lib<!-- raw HTML omitted --> <!-- raw HTML omitted --></td>
</tr>
</tbody>
</table>
<h2>See also</h2>
<!-- raw HTML omitted -->
<p><a href="dx9-graphics-reference-d3dx-functions-mesh.html">Mesh Functions</a></p>
<!-- raw HTML omitted -->
<p><a href="d3dxcomputetangentframe.html"><strong>D3DXComputeTangentFrame</strong></a></p>
<!-- raw HTML omitted -->
<p>Â </p>
<p>Â </p>
</body>
